import {
  __publicField
} from "./chunk-E3EO7R6B.js";

// node_modules/@novorender/webgl-api/index.js
var t = Symbol("Comlink.proxy");
var e = Symbol("Comlink.endpoint");
var i = Symbol("Comlink.releaseProxy");
var s = Symbol("Comlink.thrown");
var a = (t2) => "object" == typeof t2 && null !== t2 || "function" == typeof t2;
var r = /* @__PURE__ */ new Map([["proxy", { canHandle: (e2) => a(e2) && e2[t], serialize(t2) {
  const { port1: e2, port2: i2 } = new MessageChannel();
  return n(t2, e2), [i2, [i2]];
}, deserialize: (t2) => (t2.start(), h(t2)) }], ["throw", { canHandle: (t2) => a(t2) && s in t2, serialize({ value: t2 }) {
  let e2;
  return e2 = t2 instanceof Error ? { isError: true, value: { message: t2.message, name: t2.name, stack: t2.stack } } : { isError: false, value: t2 }, [e2, []];
}, deserialize(t2) {
  if (t2.isError)
    throw Object.assign(new Error(t2.value.message), t2.value);
  throw t2.value;
} }]]);
function n(t2, e2 = self) {
  e2.addEventListener("message", function i2(a2) {
    if (!a2 || !a2.data)
      return;
    const { id: r2, type: h2, path: c2 } = Object.assign({ path: [] }, a2.data), l2 = (a2.data.argumentList || []).map(w);
    let d2;
    try {
      const e3 = c2.slice(0, -1).reduce((t3, e4) => t3[e4], t2), i3 = c2.reduce((t3, e4) => t3[e4], t2);
      switch (h2) {
        case "GET":
          d2 = i3;
          break;
        case "SET":
          e3[c2.slice(-1)[0]] = w(a2.data.value), d2 = true;
          break;
        case "APPLY":
          d2 = i3.apply(e3, l2);
          break;
        case "CONSTRUCT":
          d2 = p(new i3(...l2));
          break;
        case "ENDPOINT":
          {
            const { port1: e4, port2: i4 } = new MessageChannel();
            n(t2, i4), d2 = m(e4, [e4]);
          }
          break;
        case "RELEASE":
          d2 = void 0;
          break;
        default:
          return;
      }
    } catch (t3) {
      d2 = { value: t3, [s]: 0 };
    }
    Promise.resolve(d2).catch((t3) => ({ value: t3, [s]: 0 })).then((t3) => {
      const [s2, a3] = f(t3);
      e2.postMessage(Object.assign(Object.assign({}, s2), { id: r2 }), a3), "RELEASE" === h2 && (e2.removeEventListener("message", i2), o(e2));
    });
  }), e2.start && e2.start();
}
function o(t2) {
  (function(t3) {
    return "MessagePort" === t3.constructor.name;
  })(t2) && t2.close();
}
function h(t2, e2) {
  return l(t2, [], e2);
}
function c(t2) {
  if (t2)
    throw new Error("Proxy has been released and is not useable");
}
function l(t2, s2 = [], a2 = function() {
}) {
  let r2 = false;
  const n2 = new Proxy(a2, { get(e2, a3) {
    if (c(r2), a3 === i)
      return () => v(t2, { type: "RELEASE", path: s2.map((t3) => t3.toString()) }).then(() => {
        o(t2), r2 = true;
      });
    if ("then" === a3) {
      if (0 === s2.length)
        return { then: () => n2 };
      const e3 = v(t2, { type: "GET", path: s2.map((t3) => t3.toString()) }).then(w);
      return e3.then.bind(e3);
    }
    return l(t2, [...s2, a3]);
  }, set(e2, i2, a3) {
    c(r2);
    const [n3, o2] = f(a3);
    return v(t2, { type: "SET", path: [...s2, i2].map((t3) => t3.toString()), value: n3 }, o2).then(w);
  }, apply(i2, a3, n3) {
    c(r2);
    const o2 = s2[s2.length - 1];
    if (o2 === e)
      return v(t2, { type: "ENDPOINT" }).then(w);
    if ("bind" === o2)
      return l(t2, s2.slice(0, -1));
    const [h2, u2] = d(n3);
    return v(t2, { type: "APPLY", path: s2.map((t3) => t3.toString()), argumentList: h2 }, u2).then(w);
  }, construct(e2, i2) {
    c(r2);
    const [a3, n3] = d(i2);
    return v(t2, { type: "CONSTRUCT", path: s2.map((t3) => t3.toString()), argumentList: a3 }, n3).then(w);
  } });
  return n2;
}
function d(t2) {
  const e2 = t2.map(f);
  return [e2.map((t3) => t3[0]), (i2 = e2.map((t3) => t3[1]), Array.prototype.concat.apply([], i2))];
  var i2;
}
var u = /* @__PURE__ */ new WeakMap();
function m(t2, e2) {
  return u.set(t2, e2), t2;
}
function p(e2) {
  return Object.assign(e2, { [t]: true });
}
function f(t2) {
  for (const [e2, i2] of r)
    if (i2.canHandle(t2)) {
      const [s2, a2] = i2.serialize(t2);
      return [{ type: "HANDLER", name: e2, value: s2 }, a2];
    }
  return [{ type: "RAW", value: t2 }, u.get(t2) || []];
}
function w(t2) {
  switch (t2.type) {
    case "HANDLER":
      return r.get(t2.name).deserialize(t2.value);
    case "RAW":
      return t2.value;
  }
}
function v(t2, e2, i2) {
  return new Promise((s2) => {
    const a2 = new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
    t2.addEventListener("message", function e3(i3) {
      i3.data && i3.data.id && i3.data.id === a2 && (t2.removeEventListener("message", e3), s2(i3.data));
    }), t2.start && t2.start(), t2.postMessage(Object.assign({ id: a2 }, e2), i2);
  });
}
var g = "undefined" != typeof Float32Array ? Float32Array : Array;
function y(t2) {
  g = t2;
}
var b = Math.PI / 180;
function M(t2) {
  return t2 * b;
}
function k(t2, e2) {
  return Math.abs(t2 - e2) <= 1e-6 * Math.max(1, Math.abs(t2), Math.abs(e2));
}
function P() {
  var t2 = new g(9);
  return g != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0), t2[0] = 1, t2[4] = 1, t2[8] = 1, t2;
}
function x(t2, e2) {
  var i2 = e2[0], s2 = e2[1], a2 = e2[2], r2 = e2[3], n2 = i2 + i2, o2 = s2 + s2, h2 = a2 + a2, c2 = i2 * n2, l2 = s2 * n2, d2 = s2 * o2, u2 = a2 * n2, m2 = a2 * o2, p2 = a2 * h2, f2 = r2 * n2, w2 = r2 * o2, v2 = r2 * h2;
  return t2[0] = 1 - d2 - p2, t2[3] = l2 - v2, t2[6] = u2 + w2, t2[1] = l2 + v2, t2[4] = 1 - c2 - p2, t2[7] = m2 - f2, t2[2] = u2 - w2, t2[5] = m2 + f2, t2[8] = 1 - c2 - d2, t2;
}
function _() {
  var t2 = new g(16);
  return g != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
}
function V(t2, e2) {
  var i2 = e2[0], s2 = e2[1], a2 = e2[2], r2 = e2[3], n2 = e2[4], o2 = e2[5], h2 = e2[6], c2 = e2[7], l2 = e2[8], d2 = e2[9], u2 = e2[10], m2 = e2[11], p2 = e2[12], f2 = e2[13], w2 = e2[14], v2 = e2[15], g2 = i2 * o2 - s2 * n2, y2 = i2 * h2 - a2 * n2, b2 = i2 * c2 - r2 * n2, M2 = s2 * h2 - a2 * o2, k2 = s2 * c2 - r2 * o2, P2 = a2 * c2 - r2 * h2, x2 = l2 * f2 - d2 * p2, _2 = l2 * w2 - u2 * p2, V2 = l2 * v2 - m2 * p2, S2 = d2 * w2 - u2 * f2, E2 = d2 * v2 - m2 * f2, T2 = u2 * v2 - m2 * w2, L2 = g2 * T2 - y2 * E2 + b2 * S2 + M2 * V2 - k2 * _2 + P2 * x2;
  return L2 ? (L2 = 1 / L2, t2[0] = (o2 * T2 - h2 * E2 + c2 * S2) * L2, t2[1] = (a2 * E2 - s2 * T2 - r2 * S2) * L2, t2[2] = (f2 * P2 - w2 * k2 + v2 * M2) * L2, t2[3] = (u2 * k2 - d2 * P2 - m2 * M2) * L2, t2[4] = (h2 * V2 - n2 * T2 - c2 * _2) * L2, t2[5] = (i2 * T2 - a2 * V2 + r2 * _2) * L2, t2[6] = (w2 * b2 - p2 * P2 - v2 * y2) * L2, t2[7] = (l2 * P2 - u2 * b2 + m2 * y2) * L2, t2[8] = (n2 * E2 - o2 * V2 + c2 * x2) * L2, t2[9] = (s2 * V2 - i2 * E2 - r2 * x2) * L2, t2[10] = (p2 * k2 - f2 * b2 + v2 * g2) * L2, t2[11] = (d2 * b2 - l2 * k2 - m2 * g2) * L2, t2[12] = (o2 * _2 - n2 * S2 - h2 * x2) * L2, t2[13] = (i2 * S2 - s2 * _2 + a2 * x2) * L2, t2[14] = (f2 * y2 - p2 * M2 - w2 * g2) * L2, t2[15] = (l2 * M2 - d2 * y2 + u2 * g2) * L2, t2) : null;
}
function S(t2, e2, i2) {
  var s2 = e2[0], a2 = e2[1], r2 = e2[2], n2 = e2[3], o2 = e2[4], h2 = e2[5], c2 = e2[6], l2 = e2[7], d2 = e2[8], u2 = e2[9], m2 = e2[10], p2 = e2[11], f2 = e2[12], w2 = e2[13], v2 = e2[14], g2 = e2[15], y2 = i2[0], b2 = i2[1], M2 = i2[2], k2 = i2[3];
  return t2[0] = y2 * s2 + b2 * o2 + M2 * d2 + k2 * f2, t2[1] = y2 * a2 + b2 * h2 + M2 * u2 + k2 * w2, t2[2] = y2 * r2 + b2 * c2 + M2 * m2 + k2 * v2, t2[3] = y2 * n2 + b2 * l2 + M2 * p2 + k2 * g2, y2 = i2[4], b2 = i2[5], M2 = i2[6], k2 = i2[7], t2[4] = y2 * s2 + b2 * o2 + M2 * d2 + k2 * f2, t2[5] = y2 * a2 + b2 * h2 + M2 * u2 + k2 * w2, t2[6] = y2 * r2 + b2 * c2 + M2 * m2 + k2 * v2, t2[7] = y2 * n2 + b2 * l2 + M2 * p2 + k2 * g2, y2 = i2[8], b2 = i2[9], M2 = i2[10], k2 = i2[11], t2[8] = y2 * s2 + b2 * o2 + M2 * d2 + k2 * f2, t2[9] = y2 * a2 + b2 * h2 + M2 * u2 + k2 * w2, t2[10] = y2 * r2 + b2 * c2 + M2 * m2 + k2 * v2, t2[11] = y2 * n2 + b2 * l2 + M2 * p2 + k2 * g2, y2 = i2[12], b2 = i2[13], M2 = i2[14], k2 = i2[15], t2[12] = y2 * s2 + b2 * o2 + M2 * d2 + k2 * f2, t2[13] = y2 * a2 + b2 * h2 + M2 * u2 + k2 * w2, t2[14] = y2 * r2 + b2 * c2 + M2 * m2 + k2 * v2, t2[15] = y2 * n2 + b2 * l2 + M2 * p2 + k2 * g2, t2;
}
function E(t2, e2, i2) {
  var s2 = Math.sin(i2), a2 = Math.cos(i2), r2 = e2[0], n2 = e2[1], o2 = e2[2], h2 = e2[3], c2 = e2[4], l2 = e2[5], d2 = e2[6], u2 = e2[7];
  return e2 !== t2 && (t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = r2 * a2 + c2 * s2, t2[1] = n2 * a2 + l2 * s2, t2[2] = o2 * a2 + d2 * s2, t2[3] = h2 * a2 + u2 * s2, t2[4] = c2 * a2 - r2 * s2, t2[5] = l2 * a2 - n2 * s2, t2[6] = d2 * a2 - o2 * s2, t2[7] = u2 * a2 - h2 * s2, t2;
}
function T(t2, e2, i2) {
  var s2 = e2[0], a2 = e2[1], r2 = e2[2], n2 = e2[3], o2 = s2 + s2, h2 = a2 + a2, c2 = r2 + r2, l2 = s2 * o2, d2 = s2 * h2, u2 = s2 * c2, m2 = a2 * h2, p2 = a2 * c2, f2 = r2 * c2, w2 = n2 * o2, v2 = n2 * h2, g2 = n2 * c2;
  return t2[0] = 1 - (m2 + f2), t2[1] = d2 + g2, t2[2] = u2 - v2, t2[3] = 0, t2[4] = d2 - g2, t2[5] = 1 - (l2 + f2), t2[6] = p2 + w2, t2[7] = 0, t2[8] = u2 + v2, t2[9] = p2 - w2, t2[10] = 1 - (l2 + m2), t2[11] = 0, t2[12] = i2[0], t2[13] = i2[1], t2[14] = i2[2], t2[15] = 1, t2;
}
function L(t2, e2) {
  var i2 = e2[0], s2 = e2[1], a2 = e2[2], r2 = e2[4], n2 = e2[5], o2 = e2[6], h2 = e2[8], c2 = e2[9], l2 = e2[10];
  return t2[0] = Math.hypot(i2, s2, a2), t2[1] = Math.hypot(r2, n2, o2), t2[2] = Math.hypot(h2, c2, l2), t2;
}
function C(t2, e2) {
  var i2 = new g(3);
  L(i2, e2);
  var s2 = 1 / i2[0], a2 = 1 / i2[1], r2 = 1 / i2[2], n2 = e2[0] * s2, o2 = e2[1] * a2, h2 = e2[2] * r2, c2 = e2[4] * s2, l2 = e2[5] * a2, d2 = e2[6] * r2, u2 = e2[8] * s2, m2 = e2[9] * a2, p2 = e2[10] * r2, f2 = n2 + l2 + p2, w2 = 0;
  return f2 > 0 ? (w2 = 2 * Math.sqrt(f2 + 1), t2[3] = 0.25 * w2, t2[0] = (d2 - m2) / w2, t2[1] = (u2 - h2) / w2, t2[2] = (o2 - c2) / w2) : n2 > l2 && n2 > p2 ? (w2 = 2 * Math.sqrt(1 + n2 - l2 - p2), t2[3] = (d2 - m2) / w2, t2[0] = 0.25 * w2, t2[1] = (o2 + c2) / w2, t2[2] = (u2 + h2) / w2) : l2 > p2 ? (w2 = 2 * Math.sqrt(1 + l2 - n2 - p2), t2[3] = (u2 - h2) / w2, t2[0] = (o2 + c2) / w2, t2[1] = 0.25 * w2, t2[2] = (d2 + m2) / w2) : (w2 = 2 * Math.sqrt(1 + p2 - n2 - l2), t2[3] = (o2 - c2) / w2, t2[0] = (u2 + h2) / w2, t2[1] = (d2 + m2) / w2, t2[2] = 0.25 * w2), t2;
}
Math.hypot || (Math.hypot = function() {
  for (var t2 = 0, e2 = arguments.length; e2--; )
    t2 += arguments[e2] * arguments[e2];
  return Math.sqrt(t2);
});
var R = function(t2, e2, i2, s2, a2) {
  var r2, n2 = 1 / Math.tan(e2 / 2);
  return t2[0] = n2 / i2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = n2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, null != a2 && a2 !== 1 / 0 ? (r2 = 1 / (s2 - a2), t2[10] = (a2 + s2) * r2, t2[14] = 2 * a2 * s2 * r2) : (t2[10] = -1, t2[14] = -2 * s2), t2;
};
function O() {
  var t2 = new g(3);
  return g != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2;
}
function A(t2, e2, i2) {
  var s2 = new g(3);
  return s2[0] = t2, s2[1] = e2, s2[2] = i2, s2;
}
function B(t2, e2) {
  return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2;
}
function D(t2, e2, i2, s2) {
  return t2[0] = e2, t2[1] = i2, t2[2] = s2, t2;
}
function j(t2, e2, i2) {
  return t2[0] = e2[0] + i2[0], t2[1] = e2[1] + i2[1], t2[2] = e2[2] + i2[2], t2;
}
function W(t2, e2, i2) {
  return t2[0] = e2[0] - i2[0], t2[1] = e2[1] - i2[1], t2[2] = e2[2] - i2[2], t2;
}
function I(t2, e2, i2) {
  return t2[0] = e2[0] * i2, t2[1] = e2[1] * i2, t2[2] = e2[2] * i2, t2;
}
function z(t2, e2) {
  var i2 = e2[0] - t2[0], s2 = e2[1] - t2[1], a2 = e2[2] - t2[2];
  return Math.hypot(i2, s2, a2);
}
function N(t2, e2) {
  var i2 = e2[0], s2 = e2[1], a2 = e2[2], r2 = i2 * i2 + s2 * s2 + a2 * a2;
  return r2 > 0 && (r2 = 1 / Math.sqrt(r2)), t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2[2] = e2[2] * r2, t2;
}
function H(t2, e2) {
  return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2];
}
function U(t2, e2, i2) {
  var s2 = e2[0], a2 = e2[1], r2 = e2[2], n2 = i2[0], o2 = i2[1], h2 = i2[2];
  return t2[0] = a2 * h2 - r2 * o2, t2[1] = r2 * n2 - s2 * h2, t2[2] = s2 * o2 - a2 * n2, t2;
}
function K(t2, e2, i2) {
  var s2 = e2[0], a2 = e2[1], r2 = e2[2], n2 = i2[3] * s2 + i2[7] * a2 + i2[11] * r2 + i2[15];
  return n2 = n2 || 1, t2[0] = (i2[0] * s2 + i2[4] * a2 + i2[8] * r2 + i2[12]) / n2, t2[1] = (i2[1] * s2 + i2[5] * a2 + i2[9] * r2 + i2[13]) / n2, t2[2] = (i2[2] * s2 + i2[6] * a2 + i2[10] * r2 + i2[14]) / n2, t2;
}
function G(t2, e2, i2) {
  var s2 = e2[0], a2 = e2[1], r2 = e2[2];
  return t2[0] = s2 * i2[0] + a2 * i2[3] + r2 * i2[6], t2[1] = s2 * i2[1] + a2 * i2[4] + r2 * i2[7], t2[2] = s2 * i2[2] + a2 * i2[5] + r2 * i2[8], t2;
}
function F(t2, e2, i2) {
  var s2 = i2[0], a2 = i2[1], r2 = i2[2], n2 = i2[3], o2 = e2[0], h2 = e2[1], c2 = e2[2], l2 = a2 * c2 - r2 * h2, d2 = r2 * o2 - s2 * c2, u2 = s2 * h2 - a2 * o2, m2 = a2 * u2 - r2 * d2, p2 = r2 * l2 - s2 * u2, f2 = s2 * d2 - a2 * l2, w2 = 2 * n2;
  return l2 *= w2, d2 *= w2, u2 *= w2, m2 *= 2, p2 *= 2, f2 *= 2, t2[0] = o2 + l2 + m2, t2[1] = h2 + d2 + p2, t2[2] = c2 + u2 + f2, t2;
}
function q(t2, e2) {
  var i2 = t2[0], s2 = t2[1], a2 = t2[2], r2 = e2[0], n2 = e2[1], o2 = e2[2];
  return Math.abs(i2 - r2) <= 1e-6 * Math.max(1, Math.abs(i2), Math.abs(r2)) && Math.abs(s2 - n2) <= 1e-6 * Math.max(1, Math.abs(s2), Math.abs(n2)) && Math.abs(a2 - o2) <= 1e-6 * Math.max(1, Math.abs(a2), Math.abs(o2));
}
var Y = W;
var X = z;
function Z() {
  var t2 = new g(4);
  return g != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 0), t2;
}
function Q(t2, e2, i2, s2) {
  var a2 = new g(4);
  return a2[0] = t2, a2[1] = e2, a2[2] = i2, a2[3] = s2, a2;
}
function $(t2, e2, i2, s2, a2) {
  return t2[0] = e2, t2[1] = i2, t2[2] = s2, t2[3] = a2, t2;
}
function J() {
  var t2 = new g(4);
  return g != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2[3] = 1, t2;
}
function tt(t2, e2, i2) {
  i2 *= 0.5;
  var s2 = e2[0], a2 = e2[1], r2 = e2[2], n2 = e2[3], o2 = Math.sin(i2), h2 = Math.cos(i2);
  return t2[0] = s2 * h2 + n2 * o2, t2[1] = a2 * h2 + r2 * o2, t2[2] = r2 * h2 - a2 * o2, t2[3] = n2 * h2 - s2 * o2, t2;
}
function et(t2, e2, i2) {
  i2 *= 0.5;
  var s2 = e2[0], a2 = e2[1], r2 = e2[2], n2 = e2[3], o2 = Math.sin(i2), h2 = Math.cos(i2);
  return t2[0] = s2 * h2 - r2 * o2, t2[1] = a2 * h2 + n2 * o2, t2[2] = r2 * h2 + s2 * o2, t2[3] = n2 * h2 - a2 * o2, t2;
}
function it(t2, e2) {
  var i2, s2 = e2[0] + e2[4] + e2[8];
  if (s2 > 0)
    i2 = Math.sqrt(s2 + 1), t2[3] = 0.5 * i2, i2 = 0.5 / i2, t2[0] = (e2[5] - e2[7]) * i2, t2[1] = (e2[6] - e2[2]) * i2, t2[2] = (e2[1] - e2[3]) * i2;
  else {
    var a2 = 0;
    e2[4] > e2[0] && (a2 = 1), e2[8] > e2[3 * a2 + a2] && (a2 = 2);
    var r2 = (a2 + 1) % 3, n2 = (a2 + 2) % 3;
    i2 = Math.sqrt(e2[3 * a2 + a2] - e2[3 * r2 + r2] - e2[3 * n2 + n2] + 1), t2[a2] = 0.5 * i2, i2 = 0.5 / i2, t2[3] = (e2[3 * r2 + n2] - e2[3 * n2 + r2]) * i2, t2[r2] = (e2[3 * r2 + a2] + e2[3 * a2 + r2]) * i2, t2[n2] = (e2[3 * n2 + a2] + e2[3 * a2 + n2]) * i2;
  }
  return t2;
}
O(), Z();
var st = function(t2, e2) {
  return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2;
};
function at() {
  var t2 = new g(2);
  return g != Float32Array && (t2[0] = 0, t2[1] = 0), t2;
}
function rt(t2, e2) {
  var i2 = new g(2);
  return i2[0] = t2, i2[1] = e2, i2;
}
function nt(t2, e2, i2) {
  return t2[0] = e2, t2[1] = i2, t2;
}
O(), A(1, 0, 0), A(0, 1, 0), J(), J(), P();
function ot(t2, e2, i2) {
  return t2 < e2 ? t2 = e2 : t2 > i2 && (t2 = i2), t2;
}
at(), y(Array);
var ht = function() {
  const t2 = P();
  return function(e2) {
    return x(t2, e2), t2;
  };
}();
function ct(t2) {
  let e2, i2, s2;
  const [a2, r2, n2, o2, h2, c2, l2, d2, u2] = t2;
  return e2 = Math.asin(-ot(d2, -1, 1)), Math.abs(d2) < 0.9999999 ? (i2 = Math.atan2(l2, u2), s2 = Math.atan2(r2, h2)) : (i2 = Math.atan2(-n2, a2), s2 = 0), { x: e2, y: i2, z: s2 };
}
var lt = class {
  constructor(t2) {
    __publicField(this, "outputPosition", O());
    __publicField(this, "outputRotation", J());
    __publicField(this, "zoomTarget");
    __publicField(this, "sceneVolume");
    __publicField(this, "camera");
    __publicField(this, "domElement");
    __publicField(this, "mouseButtonsMap", { rotate: 1, pan: 4, orbit: 2, pivot: 2 });
    __publicField(this, "fingersMap", { rotate: 1, pan: 2, orbit: 3, pivot: 3, zoomZ: 0 });
    __publicField(this, "enabled", true);
    __publicField(this, "autoZoomToScene", true);
    __publicField(this, "lastRecordePoistion");
    __publicField(this, "recodedPosition");
    __publicField(this, "lastUpdatedPosition", 0);
    __publicField(this, "lastUpdate", 0);
    __publicField(this, "lastGesture");
    __publicField(this, "needPointerLock", false);
    __publicField(this, "preventDefault", (t2) => {
      t2.preventDefault();
    });
    __publicField(this, "mousedown", async (t2) => {
      this.camera && this.enabled && (this.needPointerLock = true, "ortho" == this.params.kind && (this.needPointerLock = null != this.params.pointerLockOnPan && this.params.pointerLockOnPan), this.lastGesture = "mouse", (t2.buttons & this.mouseButtonsMap.pan || t2.buttons & this.mouseButtonsMap.orbit) && await this.setLastPosition(t2.offsetX, t2.offsetY), t2.preventDefault());
    });
    __publicField(this, "mouseup", (t2) => {
      this.camera && this.enabled && (t2.preventDefault(), "exitPointerLock" in document && document.exitPointerLock(), this.needPointerLock = false);
    });
    __publicField(this, "mousewheel", async (t2) => {
      const { camera: e2, enabled: i2 } = this;
      e2 && i2 && (this.lastGesture = "mouse", await this.setLastPosition(t2.offsetX, t2.offsetY), this.zoom(t2.deltaY, t2.offsetX, t2.offsetY));
    });
    __publicField(this, "mousemove", async (t2) => {
      if (this.camera && this.enabled && !(t2.buttons < 1 || Math.abs(t2.movementX) > 100 || Math.abs(t2.movementY) > 100))
        if (this.needPointerLock && (t2.currentTarget.requestPointerLock(), this.needPointerLock = false), t2.buttons & this.mouseButtonsMap.orbit) {
          const e2 = P();
          x(e2, this.outputRotation), this.orbit(t2.movementX, t2.movementY, e2, true);
        } else if (t2.buttons & this.mouseButtonsMap.pan) {
          const e2 = P();
          x(e2, this.outputRotation), this.pan(t2.movementX, t2.movementY, e2);
        } else
          t2.buttons & this.mouseButtonsMap.rotate && this.rotate(-t2.movementX, -t2.movementY);
    });
    __publicField(this, "pointerTable", []);
    __publicField(this, "_touchMovePrev", at());
    __publicField(this, "prevTouchCenter");
    __publicField(this, "_touchZoomDistancePrev", 0);
    __publicField(this, "touchstart", async (t2) => {
      if (this.camera && this.enabled)
        if (this.lastGesture = "touch", this.pointerTable = Array.from(t2.touches).map((t3) => ({ id: t3.identifier, x: Math.round(t3.clientX), y: Math.round(t3.clientY) })), 1 === this.pointerTable.length)
          nt(this._touchMovePrev, this.pointerTable[0].x, this.pointerTable[0].y);
        else {
          const t3 = this.pointerTable[0].x - this.pointerTable[1].x, e2 = this.pointerTable[0].y - this.pointerTable[1].y;
          this._touchZoomDistancePrev = Math.sqrt(t3 * t3 + e2 * e2);
          const i2 = (this.pointerTable[0].x + this.pointerTable[1].x) / 2, s2 = (this.pointerTable[0].y + this.pointerTable[1].y) / 2;
          nt(this._touchMovePrev, i2, s2), await this.setLastPosition(i2, s2);
        }
    });
    __publicField(this, "touchend", (t2) => {
      if (this.camera && this.enabled)
        switch (this.pointerTable = Array.from(t2.touches).map((t3) => ({ id: t3.identifier, x: Math.round(t3.clientX), y: Math.round(t3.clientY) })), this.pointerTable.length) {
          case 0:
            break;
          case 1:
            nt(this._touchMovePrev, this.pointerTable[0].x, this.pointerTable[0].y);
            break;
          default:
            const t3 = this.pointerTable[0].x - this.pointerTable[1].x, e2 = this.pointerTable[0].y - this.pointerTable[1].y;
            this._touchZoomDistancePrev = Math.sqrt(t3 * t3 + e2 * e2);
            const i2 = (this.pointerTable[0].x + this.pointerTable[1].x) / 2, s2 = (this.pointerTable[0].y + this.pointerTable[1].y) / 2;
            nt(this._touchMovePrev, i2, s2);
        }
    });
    __publicField(this, "touchcancel", (t2) => {
      this.camera && this.enabled && (t2.preventDefault(), this.pointerTable = Array.from(t2.touches).map((t3) => ({ id: t3.identifier, x: Math.round(t3.clientX), y: Math.round(t3.clientY) })));
    });
    __publicField(this, "touchmove", (t2) => {
      if (!this.camera || !this.enabled)
        return;
      t2.cancelable && t2.preventDefault(), this.pointerTable = Array.from(t2.touches).map((t3) => ({ id: t3.identifier, x: Math.round(t3.clientX), y: Math.round(t3.clientY) }));
      let { x: e2, y: i2 } = this.pointerTable[0];
      if (this.pointerTable.length > 1) {
        const t3 = this.pointerTable[0].x - this.pointerTable[1].x, s2 = this.pointerTable[0].y - this.pointerTable[1].y, a2 = Math.sqrt(t3 * t3 + s2 * s2);
        e2 = (this.pointerTable[0].x + this.pointerTable[1].x) / 2, i2 = (this.pointerTable[0].y + this.pointerTable[1].y) / 2;
        const r2 = rt(e2, i2);
        let n2 = 0;
        this.prevTouchCenter && (n2 = function(t4, e3) {
          var i3 = e3[0] - t4[0], s3 = e3[1] - t4[1];
          return Math.hypot(i3, s3);
        }(this.prevTouchCenter, r2)), this.prevTouchCenter = r2;
        const o2 = this._touchZoomDistancePrev - a2;
        this._touchZoomDistancePrev = a2, this.pointerTable.length == this.fingersMap.zoomZ && "ortho" == this.params.kind ? this.zoomZ(o2 / 20) : 2 === this.pointerTable.length && 2 * n2 < Math.abs(o2) && this.zoom(o2, e2, i2);
      } else
        this.prevTouchCenter = void 0;
      switch (this.pointerTable.length) {
        case this.fingersMap.rotate:
          this.rotate(e2 - this._touchMovePrev[0], i2 - this._touchMovePrev[1]);
          break;
        case this.fingersMap.orbit:
          this.orbit(this._touchMovePrev[0] - e2, this._touchMovePrev[1] - i2, x(P(), this.outputRotation));
          break;
        case this.fingersMap.pan:
          this.pan(e2 - this._touchMovePrev[0], i2 - this._touchMovePrev[1], x(P(), this.outputRotation));
      }
      nt(this._touchMovePrev, e2, i2);
    });
    __publicField(this, "zoomTo", (t2) => {
      this.zoomTarget = t2;
    });
    __publicField(this, "moveTo", (t2, e2) => {
    });
    this.domElement = t2;
  }
  async setLastPosition(t2, e2) {
    var _a2;
    const { camera: i2, enabled: s2 } = this;
    if (i2 && s2 && "flight" == this.params.kind && this.params.proportionalCameraSpeed) {
      if (this.lastUpdate - this.lastUpdatedPosition < this.params.proportionalCameraSpeed.pickDelay)
        return;
      const s3 = i2.view, a2 = await ((_a2 = s3.lastRenderOutput) == null ? void 0 : _a2.pick(t2, e2));
      a2 ? (this.recodedPosition = a2.position, this.lastRecordePoistion = a2.position, this.lastUpdatedPosition = performance.now()) : s3._validPickBuffers && (this.recodedPosition = void 0, this.lastUpdatedPosition = performance.now());
    }
  }
  connect() {
    this.domElement && (this.domElement.addEventListener("click", this.preventDefault, false), this.domElement.addEventListener("contextmenu", this.preventDefault, false), this.domElement.addEventListener("mousedown", this.mousedown, false), this.domElement.addEventListener("mouseup", this.mouseup, false), this.domElement.addEventListener("mousemove", this.mousemove, false), this.domElement.addEventListener("wheel", this.mousewheel, false), this.domElement.addEventListener("touchstart", this.touchstart, false), this.domElement.addEventListener("touchmove", this.touchmove, false), this.domElement.addEventListener("touchend", this.touchend, false), this.domElement.addEventListener("touchcancel", this.touchcancel, false), this.domElement.focus());
  }
  disconnect() {
    this.domElement && (this.domElement.removeEventListener("click", this.preventDefault, false), this.domElement.removeEventListener("contextmenu", this.preventDefault, false), this.domElement.removeEventListener("mousedown", this.mousedown, false), this.domElement.removeEventListener("mouseup", this.mouseup, false), this.domElement.removeEventListener("mousemove", this.mousemove, false), this.domElement.removeEventListener("wheel", this.mousewheel, false), this.domElement.removeEventListener("touchstart", this.touchstart, false), this.domElement.removeEventListener("touchmove", this.touchmove, false), this.domElement.removeEventListener("touchend", this.touchend, false), this.domElement.removeEventListener("touchcancel", this.touchcancel, false));
  }
  update(t2, e2, i2) {
    this.lastUpdate = performance.now(), this.enabled && (t2 != this.camera && (this.camera = t2, t2 && this.newCamera(t2)), t2 && (this.sceneVolume !== e2 && (this.sceneVolume = e2, e2 && (this.newScene(e2, t2), !this.zoomTarget && this.autoZoomToScene && (this.zoomTarget = e2))), this.zoomTarget && (this.bringIntoView(this.zoomTarget, t2), this.zoomTarget = void 0)), this.animate(i2), this.output(this.outputPosition, this.outputRotation), t2 && (B(t2.position, this.outputPosition), st(t2.rotation, this.outputRotation)));
  }
  newScene(t2, e2) {
    e2.near = t2.radius / 5e3, e2.far = 10 * t2.radius;
  }
  newCamera(t2) {
  }
  animate(t2) {
  }
  rotate(t2, e2) {
  }
  pan(t2, e2, i2) {
  }
  orbit(t2, e2, i2, s2) {
  }
  zoom(t2, e2, i2) {
  }
  zoomZ(t2) {
  }
};
var _dt = class _dt extends lt {
  constructor(t2) {
    super();
    __publicField(this, "inputParams");
    __publicField(this, "params");
    this.inputParams = t2, this.params = { ..._dt.defaultParams, ...t2 };
  }
  reset() {
    Object.assign(this.params, _dt.defaultParams, this.inputParams), this.sceneVolume = void 0;
  }
  bringIntoView(t2, e2) {
    let i2;
    switch (B(this.params.target, t2.center), e2.kind) {
      case "pinhole":
        i2 = t2.radius / Math.tan(M(e2.fieldOfView) / 2);
        break;
      case "orthographic":
        i2 = t2.radius, e2.fieldOfView = 2 * t2.radius;
    }
    if (i2) {
      const t3 = O();
      W(t3, this.params.target, this.params.position);
      const e3 = 1e-6;
      H(t3, t3) > e3 ? N(t3, t3) : D(t3, 0, 0, 1), I(t3, t3, i2), j(this.params.position, this.params.target, t3);
    }
  }
  output(t2, e2) {
    const i2 = _(), s2 = P();
    var a2, r2;
    !function(t3, e3, i3, s3) {
      var a3 = e3[0], r3 = e3[1], n2 = e3[2], o2 = s3[0], h2 = s3[1], c2 = s3[2], l2 = a3 - i3[0], d2 = r3 - i3[1], u2 = n2 - i3[2], m2 = l2 * l2 + d2 * d2 + u2 * u2;
      m2 > 0 && (l2 *= m2 = 1 / Math.sqrt(m2), d2 *= m2, u2 *= m2);
      var p2 = h2 * u2 - c2 * d2, f2 = c2 * l2 - o2 * u2, w2 = o2 * d2 - h2 * l2;
      (m2 = p2 * p2 + f2 * f2 + w2 * w2) > 0 && (p2 *= m2 = 1 / Math.sqrt(m2), f2 *= m2, w2 *= m2), t3[0] = p2, t3[1] = f2, t3[2] = w2, t3[3] = 0, t3[4] = d2 * w2 - u2 * f2, t3[5] = u2 * p2 - l2 * w2, t3[6] = l2 * f2 - d2 * p2, t3[7] = 0, t3[8] = l2, t3[9] = d2, t3[10] = u2, t3[11] = 0, t3[12] = a3, t3[13] = r3, t3[14] = n2, t3[15] = 1;
    }(i2, this.params.position, this.params.target, this.params.up), r2 = i2, (a2 = s2)[0] = r2[0], a2[1] = r2[1], a2[2] = r2[2], a2[3] = r2[4], a2[4] = r2[5], a2[5] = r2[6], a2[6] = r2[8], a2[7] = r2[9], a2[8] = r2[10], it(e2, s2), B(t2, this.params.position);
  }
};
__publicField(_dt, "defaultParams", { kind: "static", position: A(0, 0, 1), target: A(0, 0, 0), up: A(0, 1, 0) });
var dt = _dt;
var _ut = class _ut extends lt {
  constructor(t2) {
    super();
    __publicField(this, "inputParams");
    __publicField(this, "params");
    this.inputParams = t2, this.params = { ..._ut.defaultParams, ...t2 };
  }
  reset() {
    Object.assign(this.params, _ut.defaultParams, this.inputParams), this.sceneVolume = void 0;
  }
  bringIntoView(t2, e2) {
    switch (this.params.pivotPoint = t2.center, e2.kind) {
      case "pinhole":
        this.params.distance = t2.radius / Math.tan(M(e2.fieldOfView) / 2);
        break;
      case "orthographic":
        this.params.distance = t2.radius, e2.fieldOfView = 2 * t2.radius;
    }
  }
  animate(t2) {
    for (this.params.rotation += this.params.rotationalVelocity * t2; this.params.rotation >= 360; )
      this.params.rotation -= 360;
    for (; this.params.rotation < 0; )
      this.params.rotation += 360;
  }
  output(t2, e2) {
    const i2 = M(this.params.rotation), s2 = Math.atan2(this.params.elevation, this.params.distance), a2 = J();
    var r2, n2, o2;
    et(a2, a2, i2), tt(e2, a2, -s2);
    const h2 = A(0, 0, (n2 = (r2 = rt(this.params.elevation, this.params.distance))[0], o2 = r2[1], Math.hypot(n2, o2)));
    F(h2, h2, e2), j(t2, this.params.pivotPoint, h2);
  }
};
__publicField(_ut, "defaultParams", { kind: "turntable", pivotPoint: A(0, 0, 0), distance: 20, elevation: 0.5, rotation: 0, rotationalVelocity: 30 });
var ut = _ut;
var _mt = class _mt extends lt {
  constructor(t2, e2) {
    super(e2);
    __publicField(this, "mouseButtonsMap", { rotate: 1, pan: 2, orbit: 0, pivot: 0 });
    __publicField(this, "inputParams");
    __publicField(this, "params");
    this.inputParams = t2, this.params = { ..._mt.defaultParams, ...t2 };
  }
  reset() {
    Object.assign(this.params, _mt.defaultParams, this.inputParams), this.sceneVolume = void 0;
  }
  newCamera(t2) {
    const e2 = ht(t2.rotation), { x: i2, y: s2 } = ct(e2);
    this.params.yaw = s2 * Math.PI / 180, this.params.pitch = i2 * Math.PI / 180, this.wrapYaw(), this.clampPitch();
  }
  wrapYaw() {
    for (; this.params.yaw >= 360; )
      this.params.yaw -= 360;
    for (; this.params.yaw < 0; )
      this.params.yaw += 360;
  }
  clampPitch() {
    this.params.pitch = ot(this.params.pitch, -89, 89);
  }
  clampDistance() {
    this.params.distance = ot(this.params.distance, 0, this.params.maxDistance);
  }
  bringIntoView(t2, e2) {
    switch (this.params.pivotPoint = t2.center, e2.kind) {
      case "pinhole":
        this.params.distance = t2.radius / Math.tan(M(e2.fieldOfView) / 2);
        break;
      case "orthographic":
        this.params.distance = t2.radius, e2.fieldOfView = 2 * t2.radius;
    }
  }
  newScene(t2, e2) {
    super.newScene(t2, e2), this.params.linearVelocity = t2.radius / 1e3, this.params.maxDistance = 50 * t2.radius;
  }
  output(t2, e2) {
    const i2 = M(this.params.yaw), s2 = M(this.params.pitch), a2 = J();
    et(a2, a2, i2), tt(e2, a2, -s2);
    const r2 = A(0, 0, this.params.distance);
    F(r2, r2, e2), j(t2, this.params.pivotPoint, r2);
  }
  rotate(t2, e2) {
    this.params.yaw += -t2 * this.params.rotationalVelocity, this.params.pitch += e2 * this.params.rotationalVelocity, this.wrapYaw(), this.clampPitch();
  }
  pan(t2, e2, i2) {
    const s2 = A(-t2 * this.params.linearVelocity, 0, 0), a2 = A(0, e2 * this.params.linearVelocity, 0), r2 = O();
    G(s2, s2, i2), G(a2, a2, i2), j(r2, s2, a2), j(this.params.pivotPoint, this.params.pivotPoint, r2);
  }
  zoom(t2) {
    this.params.distance += t2 * this.params.linearVelocity, this.clampDistance();
  }
};
__publicField(_mt, "defaultParams", { kind: "orbit", pivotPoint: O(), distance: 0, pitch: 30, yaw: 0, maxDistance: 1e3, rotationalVelocity: 0.2, linearVelocity: 0.01 });
var mt = _mt;
var _pt = class _pt extends lt {
  constructor(t2, e2) {
    super(e2);
    __publicField(this, "inputParams");
    __publicField(this, "state");
    __publicField(this, "distance");
    __publicField(this, "targetPosition", O());
    __publicField(this, "target_pitch", 0);
    __publicField(this, "target_yaw", 0);
    __publicField(this, "remainTime", -1);
    __publicField(this, "keys", /* @__PURE__ */ new Set());
    __publicField(this, "_touchstart", async (t2) => {
      var _a2, _b;
      const e2 = (_a2 = this.camera) == null ? void 0 : _a2.view;
      if (e2 && this.enabled)
        if (this.pointerTable.length === this.fingersMap.pivot) {
          let t3 = this.pointerTable[0].x, i2 = this.pointerTable[0].y;
          this.pointerTable.length > 1 && (t3 = 0.5 * (this.pointerTable[0].x + this.pointerTable[1].x), i2 = 0.5 * (this.pointerTable[0].y + this.pointerTable[1].y));
          const s2 = await ((_b = e2.lastRenderOutput) == null ? void 0 : _b.pick(t3, i2));
          this.state.pivotPoint = s2 ? s2.position : this.lastRecordePoistion ? this.lastRecordePoistion : void 0, this.state.pivotPoint ? (this.distance = z(this.state.pivotPoint, this.state.position), (this.distance > this.state.far || this.distance > 5e4) && (this.distance = void 0, this.state.pivotPoint = void 0)) : this.distance = void 0;
        } else
          this.state.pivotPoint = void 0;
    });
    __publicField(this, "handleMouseDown", async (t2) => {
      var _a2, _b;
      const e2 = (_a2 = this.camera) == null ? void 0 : _a2.view;
      if (e2 && this.enabled && (this.domElement.focus(), t2.preventDefault(), this.distance = void 0, t2.buttons & this.mouseButtonsMap.pivot)) {
        const i2 = await ((_b = e2.lastRenderOutput) == null ? void 0 : _b.pick(t2.offsetX, t2.offsetY));
        this.state.pivotPoint = i2 ? i2.position : this.lastRecordePoistion ? this.lastRecordePoistion : void 0, this.state.pivotPoint ? (this.distance = z(this.state.pivotPoint, this.state.position), (this.distance > this.state.far || this.distance > 5e4) && (this.distance = void 0, this.state.pivotPoint = void 0)) : this.distance = void 0;
      }
    });
    __publicField(this, "zoomTo", (t2) => {
      if (this.camera && this.enabled)
        if (0 === this.state.flightTime)
          this.bringIntoView(t2, this.camera);
        else {
          const e2 = Math.max(t2.radius / Math.tan(M(this.camera.fieldOfView) / 2), t2.radius + this.state.near);
          this.output(O(), this.outputRotation), j(this.targetPosition, F(this.targetPosition, A(0, 0, e2), this.outputRotation), t2.center), this.target_pitch = this.state.pitch, this.target_yaw = this.state.yaw, this.remainTime = this.state.flightTime, this.state.yaw += 0.05;
        }
    });
    __publicField(this, "moveTo", (t2, e2) => {
      if (!this.enabled)
        return;
      B(this.targetPosition, t2);
      const i2 = ht(e2), { x: s2, y: a2 } = ct(i2);
      this.target_yaw = 180 * a2 / Math.PI, this.target_yaw >= 360 ? this.target_yaw -= 360 : this.target_yaw < 0 && (this.target_yaw += 360), this.target_pitch = ot(180 * s2 / Math.PI, -89, 89), this.remainTime = this.state.flightTime, this.state.yaw += 0.05;
    });
    __publicField(this, "blur", (t2) => {
      "exitPointerLock" in document && document.exitPointerLock(), this.keys.clear();
    });
    __publicField(this, "keydown", (t2) => {
      switch (t2.code) {
        case "KeyW":
        case "KeyS":
        case "KeyA":
        case "KeyD":
        case "KeyQ":
        case "KeyE":
          t2.preventDefault();
      }
      this.keys.add(t2.code);
    });
    __publicField(this, "keyup", (t2) => {
      switch (t2.code) {
        case "KeyW":
        case "KeyS":
        case "KeyA":
        case "KeyD":
        case "KeyQ":
        case "KeyE":
          t2.preventDefault();
      }
      this.keys.delete(t2.code);
    });
    this.inputParams = t2, this.state = { ..._pt.defaultParams, ...t2 }, B(this.outputPosition, this.state.position);
  }
  get params() {
    return this.state;
  }
  reset() {
    Object.assign(this.params, _pt.defaultParams, this.inputParams), this.sceneVolume = void 0, this.distance = void 0, D(this.targetPosition, 0, 0, 0), this.target_pitch = 0, this.target_yaw = 0, this.remainTime = -1, B(this.outputPosition, this.state.position), st(this.outputRotation, J());
  }
  connect() {
    super.connect(), this.state.pivotPoint = void 0, this.domElement.tabIndex = 0, this.domElement.addEventListener("mousedown", this.handleMouseDown, false), this.domElement.addEventListener("blur", this.blur, false), this.domElement.addEventListener("keydown", this.keydown, false), this.domElement.addEventListener("keyup", this.keyup, false), this.domElement.addEventListener("touchstart", this._touchstart, false), this.domElement.addEventListener("touchend", this._touchstart, false);
  }
  disconnect() {
    super.disconnect(), this.domElement.removeEventListener("mousedown", this.handleMouseDown, false), this.domElement.removeEventListener("blur", this.blur, false), this.domElement.removeEventListener("keydown", this.keydown, false), this.domElement.removeEventListener("keyup", this.keyup, false), this.domElement.removeEventListener("touchstart", this._touchstart, false), this.domElement.removeEventListener("touchend", this._touchstart, false);
  }
  animate(t2) {
    var _a2;
    if (this.enabled) {
      if (this.camera && this.state.near > 0 && (this.camera.near = this.state.near), this.camera && this.state.far > 0 && (this.camera.far = this.state.far), this.camera && this.state.fieldOfView > 0 && 0 == this.mouseButtonsMap.pan && (this.camera.fieldOfView = this.state.fieldOfView), (t2 < 0 || t2 > 0.25) && (t2 = 0.01666666), this.remainTime >= 0) {
        if (t2 >= this.remainTime)
          this.state.yaw = this.target_yaw, this.state.pitch = this.target_pitch, B(this.state.position, this.targetPosition);
        else {
          const h2 = t2 / this.remainTime;
          e2 = this.state.position, i2 = this.state.position, s2 = this.targetPosition, a2 = h2, r2 = i2[0], n2 = i2[1], o2 = i2[2], e2[0] = r2 + a2 * (s2[0] - r2), e2[1] = n2 + a2 * (s2[1] - n2), e2[2] = o2 + a2 * (s2[2] - o2);
          let c2 = this.target_yaw - this.state.yaw;
          c2 < -180 ? c2 += 360 : c2 > 180 && (c2 -= 360), this.state.yaw += c2 * h2, this.state.pitch += (this.target_pitch - this.state.pitch) * h2, this.wrapYaw(), this.clampPitch();
        }
        this.remainTime -= t2;
      }
      var e2, i2, s2, a2, r2, n2, o2;
      if (this.keys.size) {
        let e3 = 1;
        this.keys.has("ShiftLeft") && (e3 *= 2), this.keys.has("ShiftRight") && (e3 *= 2), this.keys.has("ControlLeft") && (e3 *= 5), this.keys.has("ControlRight") && (e3 *= 5), this.keys.has("AltLeft") && (e3 *= 0.2), this.keys.has("AltRight") && (e3 *= 0.2);
        let i3 = 0, s3 = 0, a3 = 0, r3 = this.state.linearVelocity * t2 * 100 * e3;
        if ("pinhole" == ((_a2 = this.camera) == null ? void 0 : _a2.kind) && this.mouseButtonsMap.pan > 0 ? (this.keys.has("KeyW") && (a3 -= r3), this.keys.has("KeyS") && (a3 += r3)) : this.camera && (this.keys.has("KeyW") && (this.state.fieldOfView *= 0.995, this.state.fieldOfView = this.state.fieldOfView < 0.1 ? 0.1 : this.state.fieldOfView), this.keys.has("KeyS") && (this.state.fieldOfView *= 1.005, this.state.fieldOfView = this.state.fieldOfView > 60 ? 60 : this.state.fieldOfView)), this.mouseButtonsMap.pan > 0 && (this.keys.has("KeyA") && (i3 -= r3), this.keys.has("KeyD") && (i3 += r3), this.keys.has("KeyQ") && (s3 -= r3), this.keys.has("KeyE") && (s3 += r3), 0 != i3 || 0 != s3 || 0 != a3)) {
          const t3 = A(i3, s3, a3);
          F(t3, t3, this.outputRotation), j(this.state.position, this.state.position, t3);
        }
        let n3 = 0, o3 = 0, h2 = 60 * t2;
        this.keys.has("ArrowUp") && (n3 -= h2), this.keys.has("ArrowDown") && (n3 += h2), this.keys.has("ArrowLeft") && (o3 += h2), this.keys.has("ArrowRight") && (o3 -= h2), 0 == n3 && 0 == o3 || (this.state.yaw += o3, this.state.pitch += n3, this.wrapYaw(), this.clampPitch());
      }
      this.camera && (this.camera.kind = "pinhole");
    }
  }
  newCamera(t2) {
  }
  wrapYaw() {
    for (; this.state.yaw >= 360; )
      this.state.yaw -= 360;
    for (; this.state.yaw < 0; )
      this.state.yaw += 360;
  }
  clampPitch() {
    this.state.pitch = ot(this.state.pitch, -89, 89);
  }
  bringIntoView(t2, e2) {
    switch (e2.kind) {
      case "pinhole": {
        const i2 = t2.radius / Math.tan(M(e2.fieldOfView) / 2);
        this.output(O(), this.outputRotation), j(this.state.position, F(this.state.position, A(0, 0, i2), this.outputRotation), t2.center);
        break;
      }
      case "orthographic":
        e2.fieldOfView = 2 * t2.radius;
    }
  }
  newScene(t2, e2) {
    super.newScene(t2, e2), this.state.near > 0 && (e2.near = this.state.near), this.state.far > 0 && (e2.far = this.state.far), 0 === this.state.linearVelocity && (this.state.linearVelocity = 0.03);
  }
  output(t2, e2) {
    const i2 = M(this.state.yaw), s2 = M(this.state.pitch), a2 = J();
    et(a2, a2, i2), tt(e2, a2, s2), B(t2, this.state.position);
  }
  rotate(t2, e2) {
    const i2 = this.domElement.clientHeight;
    this.state.yaw += t2 * this.camera.fieldOfView / i2, this.state.pitch += e2 * this.camera.fieldOfView / i2, this.wrapYaw(), this.clampPitch();
  }
  pan(t2, e2, i2) {
    const { camera: s2, recodedPosition: a2, params: r2, lastGesture: n2 } = this, { proportionalCameraSpeed: o2 } = r2;
    let h2 = "linearVelocity" in this.params ? this.params.linearVelocity : 1;
    o2 && a2 && s2 && (h2 = "mouse" == n2 ? ot(h2 * (X(a2, s2.position) / 150), o2.min / 5e3, o2.max / 600) : ot(h2 * (X(a2, s2.position) / 30), o2.min / 1e3, o2.max / 100));
    const c2 = A(-t2 * h2, 0, 0), l2 = A(0, e2 * h2, 0), d2 = O();
    G(c2, c2, i2), G(l2, l2, i2), j(d2, c2, l2), j(this.state.position, this.state.position, d2);
  }
  orbit(t2, e2, i2, s2) {
    if (this.state.pivotPoint) {
      const i3 = this.state.pitch, f2 = this.state.yaw;
      s2 ? (e2 *= -5, t2 *= -5) : (e2 *= 5, t2 *= 5);
      const w2 = O();
      Y(w2, this.state.position, this.state.pivotPoint);
      const v2 = A(1, 0, 0);
      F(v2, v2, this.outputRotation), this.rotate(t2, e2), e2 = this.state.pitch - i3, t2 = this.state.yaw - f2;
      const g2 = J(), y2 = J();
      (function(t3, e3, i4) {
        i4 *= 0.5;
        var s3 = Math.sin(i4);
        t3[0] = s3 * e3[0], t3[1] = s3 * e3[1], t3[2] = s3 * e3[2], t3[3] = Math.cos(i4);
      })(g2, v2, M(e2)), et(y2, y2, M(t2));
      const b2 = J();
      a2 = b2, n2 = g2, o2 = (r2 = y2)[0], h2 = r2[1], c2 = r2[2], l2 = r2[3], d2 = n2[0], u2 = n2[1], m2 = n2[2], p2 = n2[3], a2[0] = o2 * p2 + l2 * d2 + h2 * m2 - c2 * u2, a2[1] = h2 * p2 + l2 * u2 + c2 * d2 - o2 * m2, a2[2] = c2 * p2 + l2 * m2 + o2 * u2 - h2 * d2, a2[3] = l2 * p2 - o2 * d2 - h2 * u2 - c2 * m2;
      const k2 = x(P(), b2);
      j(this.state.position, G(w2, w2, k2), this.state.pivotPoint);
    } else
      this.pan(t2, e2, i2);
    var a2, r2, n2, o2, h2, c2, l2, d2, u2, m2, p2;
  }
  zoom(t2, e2, i2) {
    var _a2, _b;
    if (0 == t2 || this.keys.has("ShiftLeft") || this.keys.has("ShiftRight"))
      return;
    const { recodedPosition: s2, camera: a2, lastGesture: r2, params: n2 } = this, { proportionalCameraSpeed: o2 } = n2;
    if (0 != this.mouseButtonsMap.pan && o2 && s2 && a2 && r2) {
      const e3 = t2 < 0 ? -1 : 1;
      t2 = "mouse" == r2 ? ot(Math.abs(t2 * ((X(s2, a2.position) - a2.near) / 90)), o2.min, o2.max) * e3 : ot(Math.abs(t2 * ((X(s2, a2.position) - a2.near) / 30)), o2.min / 6, o2.max / 2) * e3;
    }
    const h2 = this.domElement.clientWidth, c2 = this.domElement.clientHeight;
    if ("pinhole" == ((_a2 = this.camera) == null ? void 0 : _a2.kind)) {
      const s3 = _();
      R(s3, M(this.camera.fieldOfView), h2 / c2, this.camera.near, this.camera.far);
      const a3 = A(2 * e2 / h2 - 1, 1 - 2 * i2 / c2, 0);
      V(s3, s3), K(a3, a3, s3);
      const r3 = P();
      if (x(r3, this.outputRotation), G(a3, a3, r3), N(a3, a3), this.mouseButtonsMap.pan < 1) {
        const s4 = 1e-3 * t2, a4 = Math.max(Math.min(60, this.camera.fieldOfView * (1 + s4)), 0.1), r4 = a4 - this.camera.fieldOfView;
        if (0 === r4)
          return;
        this.state.fieldOfView = a4;
        const n4 = r4 * (e2 - 0.5 * h2) / c2, o3 = r4 * (i2 / c2 - 0.5);
        return this.state.yaw += n4, this.state.pitch += o3, this.wrapYaw(), void this.clampPitch();
      }
      let n3 = this.state.autoZoomSpeed && this.distance ? this.distance * Math.tan(M(this.camera.fieldOfView)) / c2 : this.state.linearVelocity;
      this.keys.size && (this.keys.has("ShiftLeft") && (n3 *= 2), this.keys.has("ShiftRight") && (n3 *= 2), this.keys.has("ControlLeft") && (n3 *= 5), this.keys.has("ControlRight") && (n3 *= 5), this.keys.has("AltLeft") && (n3 *= 0.2), this.keys.has("AltRight") && (n3 *= 0.2)), I(a3, a3, -t2 * n3), j(this.state.position, this.state.position, a3);
    } else if ("orthographic" == ((_b = this.camera) == null ? void 0 : _b.kind)) {
      const s3 = t2 / 500;
      if (this.state.fieldOfView *= 1 + s3, t2 < 0) {
        const t3 = i2 / c2 - 0.5, s4 = A((e2 / h2 - 0.5) * this.state.fieldOfView, t3 * this.state.fieldOfView * -1, 0);
        j(this.state.position, this.state.position, F(s4, s4, this.outputRotation));
      }
    }
  }
};
__publicField(_pt, "defaultParams", { kind: "flight", position: O(), pivotPoint: void 0, pitch: -30, yaw: 30, linearVelocity: 0.03, autoZoomSpeed: false, near: 0.1, far: 5e3, flightTime: 1, fieldOfView: 60, proportionalCameraSpeed: { min: 5, max: 300, pickDelay: 1e3 } });
var pt = _pt;
var _ft = class _ft extends lt {
  constructor(t2, e2) {
    super(e2);
    __publicField(this, "inputParams");
    __publicField(this, "params");
    __publicField(this, "keys", /* @__PURE__ */ new Set());
    __publicField(this, "_touchstart", async (t2) => {
      var _a2;
      (_a2 = this.camera) == null ? void 0 : _a2.view;
    });
    __publicField(this, "handleMouseDown", async (t2) => {
      var _a2;
      const e2 = (_a2 = this.camera) == null ? void 0 : _a2.view;
      e2 && (this.domElement.focus(), t2.preventDefault(), t2.buttons, this.mouseButtonsMap.pivot);
    });
    __publicField(this, "zoomTo", (t2) => {
      this.camera && this.bringIntoView(t2, this.camera);
    });
    __publicField(this, "moveTo", (t2, e2) => {
      if (!this.camera)
        return;
      const i2 = T(_(), e2, t2);
      this.params.referenceCoordSys = i2, D(this.params.position, 0, 0, 1);
    });
    __publicField(this, "blur", (t2) => {
      "exitPointerLock" in document && document.exitPointerLock(), this.keys.clear();
    });
    __publicField(this, "keydown", (t2) => {
      switch (t2.code) {
        case "KeyW":
        case "KeyS":
        case "KeyA":
        case "KeyD":
        case "KeyQ":
        case "KeyE":
          t2.preventDefault();
      }
      this.keys.add(t2.code);
    });
    __publicField(this, "keyup", (t2) => {
      switch (t2.code) {
        case "KeyW":
        case "KeyS":
        case "KeyA":
        case "KeyD":
        case "KeyQ":
        case "KeyE":
          t2.preventDefault();
      }
      this.keys.delete(t2.code);
    });
    this.inputParams = t2, this.params = { ..._ft.defaultParams, ...t2 };
  }
  reset() {
    Object.assign(this.params, _ft.defaultParams, this.inputParams), this.sceneVolume = void 0;
  }
  update(t2, e2, i2) {
    super.update(t2, e2, i2);
    const { params: s2 } = this;
    t2 && (t2.far = s2.far, t2.near = s2.near);
  }
  connect() {
    super.connect(), this.domElement.tabIndex = 0, this.domElement.addEventListener("mousedown", this.handleMouseDown, false), this.domElement.addEventListener("blur", this.blur, false), this.domElement.addEventListener("keydown", this.keydown, false), this.domElement.addEventListener("keyup", this.keyup, false), this.domElement.addEventListener("touchstart", this._touchstart, false), this.domElement.addEventListener("touchend", this._touchstart, false), this.domElement.focus();
  }
  disconnect() {
    super.disconnect(), this.domElement.removeEventListener("mousedown", this.handleMouseDown, false), this.domElement.removeEventListener("blur", this.blur, false), this.domElement.removeEventListener("keydown", this.keydown, false), this.domElement.removeEventListener("keyup", this.keyup, false), this.domElement.removeEventListener("touchstart", this._touchstart, false), this.domElement.removeEventListener("touchend", this._touchstart, false);
  }
  animate(t2) {
    if (this.camera && this.params.near > 0 && (this.camera.near = this.params.near), this.camera && this.params.far > 0 && (this.camera.far = this.params.far), this.camera && this.params.fieldOfView > 0 && (this.camera.fieldOfView = this.params.fieldOfView), this.keys.size) {
      let e2 = 1;
      this.keys.has("ShiftLeft") && (e2 *= 2), this.keys.has("ShiftRight") && (e2 *= 2), this.keys.has("ControlLeft") && (e2 *= 5), this.keys.has("ControlRight") && (e2 *= 5), this.keys.has("AltLeft") && (e2 *= 0.2), this.keys.has("AltRight") && (e2 *= 0.2);
      let i2 = 0, s2 = 0, a2 = this.params.linearVelocity * t2 * 100 * e2;
      if (this.camera && (this.keys.has("KeyQ") && (this.params.fieldOfView *= 0.99), this.keys.has("KeyE") && (this.params.fieldOfView *= 1.01)), this.keys.has("KeyA") && (i2 -= a2 * this.params.fieldOfView), this.keys.has("KeyD") && (i2 += a2 * this.params.fieldOfView), this.keys.has("KeyW") && (s2 += a2 * this.params.fieldOfView), this.keys.has("KeyS") && (s2 -= a2 * this.params.fieldOfView), this.keys.has("ArrowLeft") && (this.params.referenceCoordSys = E(_(), this.params.referenceCoordSys, Math.PI / 256 * e2)), this.keys.has("ArrowRight") && (this.params.referenceCoordSys = E(_(), this.params.referenceCoordSys, -Math.PI / 256 * e2)), 0 != i2 || 0 != s2) {
        const t3 = A(i2, s2, 0);
        j(this.params.position, this.params.position, t3);
      }
    }
    this.camera && (this.camera.kind = "orthographic");
  }
  newCamera(t2) {
  }
  bringIntoView(t2, e2) {
    e2.fieldOfView = 2 * t2.radius;
  }
  newScene(t2, e2) {
    super.newScene(t2, e2), this.params.near > 0 && (e2.near = this.params.near), this.params.far > 0 && (e2.far = this.params.far), 0 === this.params.linearVelocity && (this.params.linearVelocity = t2.radius / 1e3);
  }
  output(t2, e2) {
    const { position: i2, referenceCoordSys: s2 } = this.params;
    C(e2, s2), K(t2, i2, s2);
  }
  pan(t2, e2) {
    const i2 = this.params.fieldOfView / this.domElement.clientHeight;
    j(this.params.position, this.params.position, A(-t2 * i2, e2 * i2, 0));
  }
  zoom(t2, e2, i2) {
    if (this.keys.has("ShiftLeft") || this.keys.has("ShiftRight"))
      return void this.zoomZ(t2 / 100);
    const { camera: s2, domElement: a2 } = this;
    if (0 != t2 && s2) {
      const s3 = a2.clientHeight, r2 = 1 + t2 / s3, n2 = -(e2 - a2.clientWidth / 2) / s3 * 2 * t2 / 2, o2 = (i2 - s3 / 2) / s3 * 2 * t2 / 2;
      this.params.fieldOfView *= r2;
      const h2 = this.params.fieldOfView / s3, c2 = C(J(), this.params.referenceCoordSys), l2 = F(O(), A(n2 * h2, o2 * h2, 0), c2);
      this.params.referenceCoordSys[12] += l2[0], this.params.referenceCoordSys[13] += l2[1], this.params.referenceCoordSys[14] += l2[2];
    }
  }
  zoomZ(t2) {
    const e2 = C(J(), this.params.referenceCoordSys), i2 = F(O(), A(0, 0, t2), e2);
    this.params.referenceCoordSys[12] += i2[0], this.params.referenceCoordSys[13] += i2[1], this.params.referenceCoordSys[14] += i2[2];
  }
  init(t2, e2, i2) {
    const { params: s2 } = this;
    if (e2) {
      const n2 = (a2 = e2, (r2 = new g(3))[0] = a2[0], r2[1] = a2[1], r2[2] = a2[2], r2), o2 = A(0, 1, 0);
      F(o2, o2, i2.rotation);
      const h2 = U(O(), o2, n2);
      !function(t3) {
        const [e3, i3, s3] = t3;
        t3[0] = t3[1] = t3[2] = 0;
        const a3 = Math.abs(e3), r3 = Math.abs(i3), n3 = Math.abs(s3);
        a3 > r3 && a3 > n3 ? t3[0] = Math.sign(e3) : r3 > n3 ? t3[1] = Math.sign(i3) : t3[2] = Math.sign(s3);
      }(h2), U(o2, n2, h2), N(o2, o2), U(h2, o2, n2), N(h2, h2);
      const c2 = function(t3, e3, i3, s3, a3, r3, n3, o3, h3) {
        var c3 = new g(9);
        return c3[0] = t3, c3[1] = e3, c3[2] = i3, c3[3] = s3, c3[4] = a3, c3[5] = r3, c3[6] = n3, c3[7] = o3, c3[8] = h3, c3;
      }(h2[0], h2[1], h2[2], o2[0], o2[1], o2[2], n2[0], n2[1], n2[2]), l2 = it(J(), c2), d2 = T(_(), l2, t2);
      s2.referenceCoordSys = d2, D(s2.position, 0, 0, 1);
    } else {
      const t3 = x(P(), i2.rotation), e3 = i2.position;
      s2.referenceCoordSys = function(t4, e4, i3, s3, a3, r3, n2, o2, h2, c2, l2, d2, u2, m2, p2, f2) {
        var w2 = new g(16);
        return w2[0] = t4, w2[1] = e4, w2[2] = i3, w2[3] = 0, w2[4] = a3, w2[5] = r3, w2[6] = n2, w2[7] = 0, w2[8] = h2, w2[9] = c2, w2[10] = l2, w2[11] = 0, w2[12] = u2, w2[13] = m2, w2[14] = p2, w2[15] = 1, w2;
      }(t3[0], t3[1], t3[2], 0, t3[3], t3[4], t3[5], 0, t3[6], t3[7], t3[8], 0, e3[0], e3[1], e3[2]);
    }
    var a2, r2;
    if (D(s2.position, 0, 0, 1), "pinhole" == i2.kind) {
      const e3 = i2.getDistanceFromViewPlane(t2), a3 = Math.max(0.1, e3) * Math.tan(Math.PI / 180 * i2.fieldOfView / 2) * 2;
      s2.fieldOfView = a3;
    }
  }
};
__publicField(_ft, "defaultParams", { kind: "ortho", referenceCoordSys: _(), position: O(), linearVelocity: 0.01, near: 0.1, far: 5e3, fieldOfView: 2, pointerLockOnPan: false });
var ft = _ft;
var wt = class {
  constructor(t2) {
    __publicField(this, "view");
    __publicField(this, "kind", "pinhole");
    __publicField(this, "_controller", new dt({ kind: "static" }));
    __publicField(this, "position", O());
    __publicField(this, "rotation", J());
    __publicField(this, "fieldOfView", 45);
    __publicField(this, "near", 0.1);
    __publicField(this, "far", 1e3);
    __publicField(this, "generation", 0);
    __publicField(this, "previousState", { position: O(), rotation: J(), fieldOfView: 0, near: 0, far: 0, kind: "pinhole" });
    __publicField(this, "viewClipMatrix", _());
    __publicField(this, "viewWorldMatrix", _());
    __publicField(this, "viewFrustum", { left: Z(), right: Z(), top: Z(), bottom: Z(), near: Z(), far: Z(), image: Z() });
    this.view = t2;
  }
  get controller() {
    return this._controller;
  }
  set controller(t2) {
    this._controller != t2 && (this._controller.disconnect(), this._controller = t2, this._controller.connect());
  }
  getDistanceFromViewPlane(t2) {
    const { position: e2, rotation: i2 } = this, s2 = A(0, 0, -1);
    F(s2, s2, i2);
    const a2 = -H(s2, e2);
    return H(t2, s2) + a2;
  }
  update(t2) {
    const { position: e2, rotation: i2, fieldOfView: s2, generation: a2 } = this;
    this.updateState();
    const { viewClipMatrix: r2, viewWorldMatrix: n2, viewFrustum: o2 } = this;
    if ("orthographic" == this.kind) {
      const a3 = s2 / 2, h2 = a3 * t2;
      (function(t3, e3, i3, s3, a4, r3, n3) {
        var o3 = 1 / (e3 - i3), h3 = 1 / (s3 - a4), c3 = 1 / (r3 - n3);
        t3[0] = -2 * o3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = -2 * h3, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 2 * c3, t3[11] = 0, t3[12] = (e3 + i3) * o3, t3[13] = (a4 + s3) * h3, t3[14] = (n3 + r3) * c3, t3[15] = 1;
      })(r2, -h2, h2, -a3, a3, this.near, this.far), T(n2, i2, e2);
      const { left: c2, right: l2, top: d2, bottom: u2, near: m2, far: p2, image: f2 } = o2;
      $(c2, -1, 0, 0, h2), $(l2, 1, 0, 0, h2), $(d2, 0, 1, 0, a3), $(u2, 0, -1, 0, a3), $(m2, 0, 0, 1, -this.near), $(p2, 0, 0, -1, this.far), $(f2, 0, 0, -1, 0);
    } else {
      R(r2, M(s2), t2, this.near, this.far), T(n2, i2, e2);
      const a3 = M(s2 / 2), h2 = Math.atan(Math.tan(a3) * t2), { left: c2, right: l2, top: d2, bottom: u2, near: m2, far: p2, image: f2 } = o2;
      $(c2, -Math.cos(h2), 0, Math.sin(h2), 0), $(l2, Math.cos(h2), 0, Math.sin(h2), 0), $(d2, 0, Math.cos(a3), Math.sin(a3), 0), $(u2, 0, -Math.cos(a3), Math.sin(a3), 0), $(m2, 0, 0, 1, -this.near), $(p2, 0, 0, -1, this.far), $(f2, 0, 0, -1, 0);
    }
    return { generation: a2, viewFrustum: o2, viewClipMatrix: r2, viewWorldMatrix: n2 };
  }
  get hasChanged() {
    const { previousState: t2 } = this;
    return e2 = t2.position, i2 = this.position, !(e2[0] === i2[0] && e2[1] === i2[1] && e2[2] === i2[2] && function(t3, e3) {
      return t3[0] === e3[0] && t3[1] === e3[1] && t3[2] === e3[2] && t3[3] === e3[3];
    }(t2.rotation, this.rotation) && k(t2.fieldOfView, this.fieldOfView) && k(t2.near, this.near) && k(t2.far, this.far) && t2.kind == this.kind);
    var e2, i2;
  }
  updateState() {
    const { hasChanged: t2 } = this;
    if (t2) {
      const { previousState: t3 } = this;
      B(t3.position, this.position), st(t3.rotation, this.rotation), t3.fieldOfView = this.fieldOfView, t3.near = this.near, t3.far = this.far, t3.kind = this.kind, this.generation++;
    }
    return t2;
  }
};
var vt;
function gt(t2, e2) {
  return 4 * t2 + e2;
}
!function(t2) {
  t2[t2.Model = 0] = "Model", t2[t2.World = 1] = "World", t2[t2.View = 2] = "View", t2[t2.Clip = 3] = "Clip";
}(vt || (vt = {}));
var yt = [0, 0, 0];
var bt = [0, 0, 0];
function Mt(t2) {
  return { modelWorldMatrix: t2.getMatrix(vt.Model, vt.World), modelViewMatrix: t2.getMatrix(vt.Model, vt.View), modelClipMatrix: t2.getMatrix(vt.Model, vt.Clip), clipViewMatrix: t2.getMatrix(vt.Clip, vt.View), clipWorldMatrix: t2.getMatrix(vt.Clip, vt.World), clipModelMatrix: t2.getMatrix(vt.Clip, vt.Model), worldViewMatrix: t2.getMatrix(vt.World, vt.View), worldClipMatrix: t2.getMatrix(vt.World, vt.Clip), viewWorldMatrix: t2.getMatrix(vt.View, vt.World), viewModelMatrix: t2.getMatrix(vt.View, vt.Model), viewClipMatrix: t2.getMatrix(vt.View, vt.Clip), worldModelMatrix: t2.getMatrix(vt.World, vt.Model) };
}
function kt(t2) {
  return { modelWorldNormalMatrix: t2.getMatrixNormal(vt.Model, vt.World), modelViewNormalMatrix: t2.getMatrixNormal(vt.Model, vt.View), modelClipNormalMatrix: t2.getMatrixNormal(vt.Model, vt.Clip), clipViewNormalMatrix: t2.getMatrixNormal(vt.Clip, vt.View), clipWorldNormalMatrix: t2.getMatrixNormal(vt.Clip, vt.World), clipModelNormalMatrix: t2.getMatrixNormal(vt.Clip, vt.Model), worldViewNormalMatrix: t2.getMatrixNormal(vt.World, vt.View), worldClipNormalMatrix: t2.getMatrixNormal(vt.World, vt.Clip), viewWorldNormalMatrix: t2.getMatrixNormal(vt.View, vt.World), viewModelNormalMatrix: t2.getMatrixNormal(vt.View, vt.Model), viewClipNormalMatrix: t2.getMatrixNormal(vt.View, vt.Clip), worldModelNormalMatrix: t2.getMatrixNormal(vt.World, vt.Model) };
}
var Pt = class {
  constructor(t2, e2, i2) {
    __publicField(this, "_mtx4", new Array(16));
    __publicField(this, "_mtx3", new Array(16));
    this._mtx4[gt(vt.Model, vt.World)] = t2, this._mtx4[gt(vt.View, vt.World)] = e2, this._mtx4[gt(vt.View, vt.Clip)] = i2;
    const s2 = this._mtx4[gt(vt.World, vt.Model)] = _(), a2 = this._mtx4[gt(vt.World, vt.View)] = _(), r2 = this._mtx4[gt(vt.Clip, vt.View)] = _();
    V(s2, t2), V(a2, e2), V(r2, i2);
  }
  getMatrix(t2, e2) {
    const i2 = gt(t2, e2);
    let s2 = this._mtx4[i2];
    return s2 || (this._mtx4[i2] = s2 = _(), e2 > t2 ? S(s2, this.getMatrix(e2 - 1, e2), this.getMatrix(t2, e2 - 1)) : S(s2, this.getMatrix(t2 - 1, e2), this.getMatrix(t2, t2 - 1))), s2;
  }
  getMatrixNormal(t2, e2) {
    const i2 = gt(t2, e2);
    let s2 = this._mtx3[i2];
    var a2, r2, n2, o2, h2, c2, l2, d2, u2, m2, p2, f2, w2, v2, g2, y2, b2, M2, k2, x2, _2, V2, S2, E2, T2, L2, C2, R2, O2, A2, B2;
    return s2 || (this._mtx3[i2] = s2 = P(), a2 = s2, n2 = (r2 = this.getMatrix(t2, e2))[0], o2 = r2[1], h2 = r2[2], c2 = r2[3], l2 = r2[4], d2 = r2[5], u2 = r2[6], m2 = r2[7], p2 = r2[8], f2 = r2[9], w2 = r2[10], v2 = r2[11], g2 = r2[12], y2 = r2[13], b2 = r2[14], (B2 = (k2 = n2 * d2 - o2 * l2) * (A2 = w2 * (M2 = r2[15]) - v2 * b2) - (x2 = n2 * u2 - h2 * l2) * (O2 = f2 * M2 - v2 * y2) + (_2 = n2 * m2 - c2 * l2) * (R2 = f2 * b2 - w2 * y2) + (V2 = o2 * u2 - h2 * d2) * (C2 = p2 * M2 - v2 * g2) - (S2 = o2 * m2 - c2 * d2) * (L2 = p2 * b2 - w2 * g2) + (E2 = h2 * m2 - c2 * u2) * (T2 = p2 * y2 - f2 * g2)) && (B2 = 1 / B2, a2[0] = (d2 * A2 - u2 * O2 + m2 * R2) * B2, a2[1] = (u2 * C2 - l2 * A2 - m2 * L2) * B2, a2[2] = (l2 * O2 - d2 * C2 + m2 * T2) * B2, a2[3] = (h2 * O2 - o2 * A2 - c2 * R2) * B2, a2[4] = (n2 * A2 - h2 * C2 + c2 * L2) * B2, a2[5] = (o2 * C2 - n2 * O2 - c2 * T2) * B2, a2[6] = (y2 * E2 - b2 * S2 + M2 * V2) * B2, a2[7] = (b2 * _2 - g2 * E2 - M2 * x2) * B2, a2[8] = (g2 * S2 - y2 * _2 + M2 * k2) * B2)), s2;
  }
};
var xt = class {
  constructor() {
    __publicField(this, "itemRefs", []);
  }
  add(t2) {
    const e2 = new WeakRef(t2);
    this.itemRefs.push(e2);
  }
  remove(t2) {
    const e2 = this.itemRefs.findIndex((e3) => e3.deref() == t2);
    this.itemRefs.splice(e2, 1);
  }
  *[Symbol.iterator]() {
    const { itemRefs: t2 } = this, e2 = [];
    for (let i2 = 0; i2 < t2.length; i2++) {
      const s2 = t2[i2].deref();
      s2 ? yield s2 : e2.push(i2);
    }
    e2.reverse();
    for (const i2 of e2)
      t2.splice(i2, 1);
  }
};
function _t(t2) {
  if ("object" != typeof t2)
    return t2;
  let e2;
  const i2 = t2.constructor;
  switch (i2) {
    case RegExp:
      e2 = new RegExp(t2);
      break;
    case Date:
      e2 = new Date(t2.getTime());
      break;
    default:
      e2 = ArrayBuffer.isView(t2) || t2 instanceof ArrayBuffer ? structuredClone(t2) : i2 ? new i2() : /* @__PURE__ */ Object.create(null);
  }
  for (var s2 in t2) {
    const i3 = t2[s2];
    "function" != typeof i3 && (e2[s2] = _t(i3));
  }
  return e2;
}
var Vt = Symbol("scope");
function St(t2, ...e2) {
  for (const i2 of e2)
    if (void 0 !== i2)
      for (const e3 of Reflect.ownKeys(i2))
        void 0 !== t2[e3] && (`#${e3.toString()}` in t2 || t2[e3] !== Object(t2[e3]) ? Reflect.set(t2, e3, i2[e3]) : St(t2[e3], i2[e3]));
}
function Et(t2) {
  return Reflect.defineProperty(t2, Vt, { enumerable: false }), t2;
}
var Tt = class _Tt {
  constructor(t2, e2) {
    __publicField(this, "onChange");
    __publicField(this, "proxy");
    this.onChange = t2, this.proxy = e2 ?? /* @__PURE__ */ Object.create(null);
  }
  wrap(t2) {
    for (let e2 in t2) {
      const i2 = t2[e2];
      i2 && "object" == typeof i2 && Vt in i2 ? this.scope(e2, i2) : this.mutable(e2, i2);
    }
  }
  mutable(t2, e2) {
    const { proxy: i2, onChange: s2 } = this;
    "object" == typeof e2 && (e2 = Array.isArray(e2) ? [...e2] : { ...e2 }, Object.seal(e2));
    const a2 = `#${t2.toString()}`;
    Reflect.defineProperty(i2, a2, { enumerable: false, value: e2, writable: true }), Reflect.defineProperty(i2, t2, { enumerable: true, get: function() {
      return this[a2];
    }, set: function(t3) {
      this[a2] != t3 && (this[a2] = t3, s2());
    } });
  }
  scope(t2, e2) {
    const { proxy: i2, onChange: s2 } = this, a2 = new _Tt(s2);
    a2.wrap(e2), Reflect.defineProperty(i2, t2, { enumerable: true, writable: false, value: a2.proxy });
  }
};
var Lt = { display: Et({ width: 150, height: 100 }), grid: Et({ enabled: false, majorLineCount: 21, minorLineCount: 0, origo: O(), axisX: A(1, 0, 0), axisY: A(0, 1, 0), majorColor: [0.5, 1, 0.5], minorColor: [1, 0.5, 0.5] }), background: Et({ color: [0, 0, 0.25, 1], skyBoxBlur: 0 }), clippingPlanes: Et({ enabled: false, inside: true, showBox: false, bounds: Et({ min: [0, 0, 0], max: [0, 0, 0] }), highlight: 0 }), clippingVolume: Et({ enabled: false, mode: "union", planes: [] }), environment: void 0, exposure: 0, light: Et({ ambient: { brightness: 0.1 }, camera: Et({ brightness: 0, distance: 10 }), sun: Et({ brightness: 1, position: Et({ azimuth: 135, inclination: 45 }) }) }), objectHighlights: [], points: Et({ shape: "disc", size: Et({ pixel: 1, maxPixel: void 0, metric: 0, toleranceFactor: 0 }), deviation: Et({ mode: "mix", index: 0, colors: [{ deviation: -1, color: [1, 0, 0, 1] }, { deviation: -0.5, color: [1, 1, 0, 1] }, { deviation: -0.45, color: [1, 1, 0, 0] }, { deviation: 0.45, color: [1, 1, 0, 0] }, { deviation: 0.5, color: [1, 1, 0, 1] }, { deviation: 1, color: [0, 1, 0, 1] }] }), intensity: Et({ mode: "mix", colors: [{ intensity: 0, color: [1, 0, 0, 0] }, { intensity: 0.5, color: [1, 1, 0, 0.5] }, { intensity: 1, color: [0, 1, 0, 1] }] }) }), ocean: Et({ enabled: false, color: [0.5, 0.5, 1], opacity: 0.5 }), quality: Et({ detail: Et({ value: 1, maxLodGPUBytes: Number.MAX_SAFE_INTEGER }), resolution: Et({ value: 1 }) }), terrain: Et({ elevationColors: [{ elevation: -10, color: [0, 0, 0.5] }, { elevation: 0, color: [0.5, 0.5, 1] }, { elevation: 0, color: [0, 0.5, 0] }, { elevation: 10, color: [0.5, 1, 0.5] }], asBackground: false }), advanced: Et({ doubleSided: Et({ opaque: false, transparent: false }), hideTerrain: false, hidePoints: false, hideTriangles: false, hideLines: false, hideDocuments: false, displayBuffer: 0, renderBufferMask: 255, terrainBiasLimit: 7, documentsBiasLimit: 3.5 }), diagnostics: Et({ maxQueueSize: 8, holdDynamic: false, showBoundingBoxes: false }), outline: Et({ enable: false, color: void 0 }), pickBuffer: Et({ includeTransparent: false }) };
var Ct = class {
  constructor(t2, e2, i2, s2, a2, r2, n2) {
    __publicField(this, "view");
    __publicField(this, "deviceProfile");
    __publicField(this, "cameraValues");
    __publicField(this, "renderSettings");
    __publicField(this, "viewSceneGeneration");
    __publicField(this, "idleframe");
    __publicField(this, "detailAdjustment");
    __publicField(this, "statistics");
    __publicField(this, "workerView");
    __publicField(this, "_scene");
    __publicField(this, "_sceneGen");
    __publicField(this, "_validPickBuffers", false);
    __publicField(this, "imagesRequested", 0);
    var _a2;
    this.view = t2, this.deviceProfile = e2, this.cameraValues = i2, this.renderSettings = s2, this.viewSceneGeneration = a2, this.idleframe = r2, this.detailAdjustment = n2, this.workerView = t2.workerView, this.statistics = _t(t2.performanceStatistics), this.cameraValues = i2, this._scene = t2.scene, this._sceneGen = (_a2 = t2.scene) == null ? void 0 : _a2.generation;
  }
  get viewWorldMatrix() {
    var _a2;
    return ((_a2 = this.cameraValues) == null ? void 0 : _a2.viewWorldMatrix) ?? _();
  }
  get worldViewMatrix() {
    var _a2;
    return ((_a2 = this.cameraValues) == null ? void 0 : _a2.worldViewMatrix) ?? _();
  }
  get viewClipMatrix() {
    var _a2;
    return ((_a2 = this.cameraValues) == null ? void 0 : _a2.viewClipMatrix) ?? _();
  }
  get worldClipMatrix() {
    var _a2;
    return ((_a2 = this.cameraValues) == null ? void 0 : _a2.worldClipMatrix) ?? _();
  }
  async ensurePickBuffers() {
    return this.view._validPickBuffers ? (this._validPickBuffers || this.cameraValues && (await this.view.workerView.updatePickBuffers(), this._validPickBuffers = true), this._validPickBuffers) : (this._validPickBuffers = false, false);
  }
  async pick(t2, e2, i2) {
    if (await this.ensurePickBuffers()) {
      const { renderSettings: s2 } = this, a2 = s2.quality.resolution.value;
      return await this.workerView.pick(t2 * a2, e2 * a2, i2);
    }
  }
  async measure(t2, e2) {
    if (await this.ensurePickBuffers()) {
      const { renderSettings: i2 } = this, s2 = i2.quality.resolution.value;
      return await this.workerView.measure(t2 * s2, e2 * s2);
    }
  }
  async applyPostEffect(t2) {
    return await this.workerView.applyPostEffect(t2);
  }
  async getImage() {
    const t2 = await this.workerView.getOutputImage();
    return this.imagesRequested++, this.imagesRequested > 1 && this.view.dropTime(), t2;
  }
  dispose() {
  }
  async hasChanged() {
    const { view: t2, renderSettings: e2, cameraValues: i2, _scene: s2, viewSceneGeneration: a2, _sceneGen: r2, detailAdjustment: n2 } = this, o2 = await t2.currentSceneGeneration(), h2 = ((i2 == null ? void 0 : i2.generation) ?? 0) != t2.camera.generation || t2.camera.hasChanged, c2 = t2.scene !== s2 || (s2 == null ? void 0 : s2.generation) != r2 || a2 != o2, l2 = e2.generation != t2.settings.generation, d2 = !t2._validPickBuffers;
    if (h2 || c2 || l2 || d2 || n2)
      return { camera: h2, scene: c2, settings: l2, misc: d2, detailAdjustment: n2 };
    t2.dropTime();
  }
  isIdleFrame() {
    return this.idleframe;
  }
};
y(Array);
var Rt = class {
  constructor(t2, e2, i2) {
    __publicField(this, "api");
    __publicField(this, "workerView");
    __publicField(this, "_scene");
    __publicField(this, "_sceneViewState");
    __publicField(this, "_renderViewInitialized", Promise.resolve());
    __publicField(this, "_modelWorldMatrix", _());
    __publicField(this, "_validPickBuffers", false);
    __publicField(this, "_lastRenderStartTime", 0);
    __publicField(this, "lastRenderOutput");
    __publicField(this, "disposed", false);
    __publicField(this, "camera");
    __publicField(this, "settings", function() {
      const t2 = /* @__PURE__ */ Object.create(null);
      return t2.generation = 0, new Tt(() => {
        t2.generation++;
      }, t2).wrap(Lt), t2;
    }());
    __publicField(this, "performanceStatistics", { cpuTime: { animation: 0, render: { draw: 0, update: 0, total: 0 }, geometry: { update: 0 } }, gpuTime: void 0, gpuBytes: void 0, frameInterval: void 0, triangles: 0, points: 0, drawCalls: 0, sceneResolved: false, cameraGeneration: 0 });
    __publicField(this, "generation", 0);
    __publicField(this, "throttleFrames", 0);
    __publicField(this, "_lastSceneGeneration", 0);
    __publicField(this, "_prevIdleRenderTime");
    __publicField(this, "_detailBiasLevel", 1);
    __publicField(this, "controllerLastTime", 0);
    __publicField(this, "lastGeneration", 0);
    __publicField(this, "lastQualityAdjustTime", performance.now() + 5e3);
    __publicField(this, "resolutionModifier", 1);
    __publicField(this, "resolutionTier", 2);
    __publicField(this, "frameIntervals", []);
    this.api = t2, this.workerView = e2, i2 && this.applySettings(i2), this.throttleFrames = t2.deviceProfile.throttleFrames, this.camera = new wt(this);
  }
  applySettings(t2) {
    const { settings: e2 } = this, i2 = e2.generation;
    if (St(e2, t2), !Number.isInteger(e2.display.width) || !Number.isInteger(e2.display.height))
      throw new Error("Display size is non-integer!");
    e2.generation != i2 && (e2.generation = i2 + 1);
  }
  async setScene(t2) {
    if (this._scene = t2, t2) {
      const { config: s2 } = t2;
      e2 = this._modelWorldMatrix, i2 = s2.modelWorldMatrix ?? _(), e2[0] = i2[0], e2[1] = i2[1], e2[2] = i2[2], e2[3] = i2[3], e2[4] = i2[4], e2[5] = i2[5], e2[6] = i2[6], e2[7] = i2[7], e2[8] = i2[8], e2[9] = i2[9], e2[10] = i2[10], e2[11] = i2[11], e2[12] = i2[12], e2[13] = i2[13], e2[14] = i2[14], e2[15] = i2[15];
    } else
      !function(t3) {
        t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = 1, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 1, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1;
      }(this._modelWorldMatrix);
    var e2, i2;
    this._sceneViewState && (await this._sceneViewState.dispose(), this._sceneViewState = void 0), t2 && (this._sceneViewState = await t2.createViewState(this.workerView, this.api.deviceProfile), this.performanceStatistics.sceneResolved = false);
  }
  get scene() {
    return this._scene;
  }
  set scene(t2) {
    this._scene != t2 && (this.lastRenderOutput = void 0, this._renderViewInitialized = this.setScene(t2));
  }
  async dispose() {
    this.disposed || (this.disposed = true, this._sceneViewState && await this._sceneViewState.dispose(), this.workerView && (await this.workerView.dispose(), this.workerView[i]()));
  }
  computeCameraValues() {
    const { camera: t2, settings: e2 } = this;
    if (t2) {
      const i2 = e2.quality.resolution.value, { near: s2, far: a2 } = t2;
      let { width: r2, height: n2 } = e2.display;
      r2 *= i2, n2 *= i2;
      const o2 = r2 / n2, { generation: h2, viewFrustum: c2, viewClipMatrix: l2, viewWorldMatrix: d2 } = t2.update(o2);
      return function(t3, e3, i3, s3, a3, r3, n3, o3, h3, c3) {
        const l3 = new Pt(t3, e3, i3);
        return function(t4, e4, i4) {
          var s4, a4;
          (s4 = bt)[0] = (a4 = e4)[12], s4[1] = a4[13], s4[2] = a4[14];
          const { left: r4, right: n4, top: o4, bottom: h4, near: c4, far: l4, image: d3 } = t4, u2 = [r4, n4, o4, h4, c4, l4, d3];
          for (const t5 of u2) {
            const [e5, s5, a5, r5] = t5;
            D(yt, e5, s5, a5), G(yt, yt, i4);
            const n5 = r5 + H(bt, yt);
            $(t5, yt[0], yt[1], yt[2], -n5);
          }
        }(s3, l3.getMatrix(vt.View, vt.Model), l3.getMatrixNormal(vt.View, vt.Model)), { generation: a3, viewFrustum: s3, width: r3, height: n3, near: o3, far: h3, ...Mt(l3), ...kt(l3), projection: c3 };
      }(this._modelWorldMatrix, d2, l2, c2, h2, r2, n2, s2, a2, t2.kind);
    }
  }
  update() {
    var _a2;
    const { camera: t2 } = this;
    if (t2) {
      const { controller: e2 } = t2;
      if (void 0 !== e2) {
        const i2 = performance.now();
        e2.update(t2, (_a2 = this._scene) == null ? void 0 : _a2.boundingSphere, 1e-3 * (i2 - this.controllerLastTime)), this.controllerLastTime = i2;
      }
    }
  }
  dropTime() {
    this._lastRenderStartTime = 0;
  }
  invalidateCamera() {
    this.camera.generation++;
  }
  async currentSceneGeneration() {
    var _a2;
    const t2 = await ((_a2 = this._sceneViewState) == null ? void 0 : _a2.generation());
    return t2 && (this._lastSceneGeneration = t2), t2;
  }
  async render(t2) {
    const { api: e2, performanceStatistics: i2 } = this;
    let s2 = false, a2 = false, r2 = 0;
    for (; ; ) {
      r2 = await e2.waitFrame();
      for (let t3 = 0; t3 < this.throttleFrames; t3++)
        r2 = await e2.waitFrame();
      this.update();
      const i3 = this.lastRenderOutput ? await this.lastRenderOutput.hasChanged() : { camera: false, settings: false, detailAdjustment: false };
      if (i3) {
        a2 = i3.detailAdjustment, s2 = i3.camera || i3.settings, s2 && (this._prevIdleRenderTime = r2);
        break;
      }
      if (this._prevIdleRenderTime && r2 > this._prevIdleRenderTime + 750) {
        this._prevIdleRenderTime = void 0;
        break;
      }
      this._lastRenderStartTime = 0, t2 && t2();
    }
    const n2 = this.computeCameraValues(), { deviceProfile: o2 } = e2, h2 = function(t3) {
      return _t(t3);
    }(this.settings), c2 = h2, { quality: l2 } = c2;
    let d2 = o2.orthoDetailBias && "orthographic" == this.camera.kind ? o2.orthoDetailBias : o2.detailBias;
    s2 || this._prevIdleRenderTime ? (l2.resolution.value *= o2.renderResolution * this.resolutionModifier, this._detailBiasLevel = 1) : (d2 *= d2 * Math.pow(this._detailBiasLevel, 2) * 2, l2.resolution.value *= o2.renderResolutionIdle);
    let u2 = false;
    l2.detail.value *= d2;
    const { holdDynamic: m2 } = h2.diagnostics;
    if (n2 && !m2) {
      const t3 = this._sceneViewState;
      if (t3) {
        const s3 = await t3.update(n2, h2, e2.deviceProfile);
        i2.cpuTime.geometry.update = s3.updateTime, i2.gpuBytes = s3.gpuBytes, !a2 && d2 < 3 && s3.gpuBytes && s3.resolved && s3.gpuBytes < 0.75 * o2.gpuBytesLimit && this._detailBiasLevel < 4 ? (i2.sceneResolved = false, o2.gpuBytesLimit / s3.gpuBytes > 4 ? this._detailBiasLevel += 2 : ++this._detailBiasLevel, u2 = true) : i2.sceneResolved = s3.resolved;
      }
    }
    await this._renderViewInitialized;
    const { workerView: p2 } = this;
    let f2;
    this._lastRenderStartTime ? (this.lastGeneration !== i2.cameraGeneration && (f2 = r2 - this._lastRenderStartTime), this.lastGeneration = i2.cameraGeneration) : this.performanceStatistics.cpuTime.render.total = 0, this._lastRenderStartTime = r2;
    const w2 = s2 ? 1 : this.settings.advanced.renderBufferMask;
    h2.advanced.renderBufferMask = w2, this._validPickBuffers = 1 != w2;
    const v2 = await p2.render(n2, h2, e2.deviceProfile, this.generation++);
    i2.cpuTime.render.draw = v2.drawTime, i2.cpuTime.render.update = v2.updateTime, i2.gpuTime = v2.gpuTime, i2.frameInterval = f2, i2.drawCalls = v2.drawcalls, i2.triangles = v2.triangles, i2.points = v2.points, i2.cameraGeneration = (n2 == null ? void 0 : n2.generation) ?? 0;
    const g2 = new Ct(this, o2, n2, h2, this._lastSceneGeneration, void 0 === this._prevIdleRenderTime, u2);
    return this.lastRenderOutput = g2, g2;
  }
  adjustQuality(t2) {
    const { performanceStatistics: e2, frameIntervals: i2, settings: s2 } = this, a2 = t2 ? t2.lowerBound : 200, r2 = t2 ? t2.upperBound : 33.3, { frameInterval: n2 } = e2;
    if (n2) {
      i2.push(n2);
      const t3 = 9;
      if (i2.length == t3) {
        const e3 = [...i2];
        e3.sort();
        const s3 = e3[Math.floor(t3 / 2)];
        i2.splice(0, 1);
        const n3 = 3e3, o2 = performance.now();
        if (o2 > this.lastQualityAdjustTime + n3) {
          const t4 = [0.66, 0.75, 1];
          s3 > a2 ? (0 != this.resolutionTier && (this.resolutionModifier = t4[--this.resolutionTier]), this.lastQualityAdjustTime = o2) : s3 < r2 && 2 != this.resolutionTier && (this.resolutionModifier = t4[++this.resolutionTier], this.lastQualityAdjustTime = o2);
        }
        return s3;
      }
    }
  }
  async transferToImageBitmap() {
    return await this.workerView.transferToImageBitmap();
  }
  async convertToBlob(t2) {
    return await this.workerView.convertToBlob(t2);
  }
  async updatePickBuffers() {
    this._validPickBuffers && this.computeCameraValues() && await this.workerView.updatePickBuffers();
  }
};
var Ot = { cube: [new class {
  constructor(t2, e2, i2, s2) {
    __publicField(this, "id");
    __publicField(this, "name");
    __publicField(this, "path");
    __publicField(this, "type");
    __publicField(this, "description");
    __publicField(this, "url");
    __publicField(this, "properties", []);
    this.id = t2, this.name = e2, this.path = i2, this.type = s2;
  }
  loadMetaData() {
    return Promise.resolve(this);
  }
  save() {
    return Promise.resolve(false);
  }
}(0, "cube", "cube", 1)] };
var At = { empty: { kind: "empty", id: "empty", version: "", boundingSphere: { center: O(), radius: 1 }, modelWorldMatrix: _(), materials: [], db: "empty" }, cube: { kind: "cube", id: "cube", version: "", count: 1, radius: 0, boundingSphere: { center: O(), radius: 0 + Math.sqrt(3) }, modelWorldMatrix: _(), materials: [{ kind: "basic_z", uniforms: { rgba: Q(1, 0, 0, 1) } }, { kind: "basic_z", uniforms: { rgba: Q(1, 1, 0, 1) } }, { kind: "basic_z", uniforms: { rgba: Q(0, 1, 0, 1) } }, { kind: "basic_z", uniforms: { rgba: Q(0, 1, 1, 1) } }, { kind: "basic_z", uniforms: { rgba: Q(0, 0, 1, 1) } }, { kind: "basic_z", uniforms: { rgba: Q(1, 0, 1, 1) } }], db: "cube" } };
function Bt(t2, e2) {
  const i2 = ("string" == typeof e2 ? [e2] : e2).map((t3) => new RegExp(t3, "i"));
  if (i2.some((e3) => e3.test(t2.name)))
    return true;
  const { path: s2 } = t2, a2 = s2.split("/");
  if (i2.some((t3) => t3.test(a2[a2.length - 1])) || t2.description && i2.some((e3) => e3.test(t2.description)))
    return true;
  const { properties: r2 } = t2;
  if (void 0 !== r2) {
    for (let t3 of r2)
      if (i2.some((e3) => e3.test(t3[0])) || i2.some((e3) => e3.test(t3[1])))
        return true;
  }
  return false;
}
function Dt(t2, e2) {
  if (t2.name === e2)
    return true;
  const { path: i2 } = t2, s2 = i2.split("/");
  if (s2[s2.length - 1] === e2 || t2.description === e2)
    return true;
  const { properties: a2 } = t2;
  if (void 0 !== a2) {
    for (let t3 of a2)
      if (t3[0] === e2 || t3[1] === e2)
        return true;
  }
  return false;
}
async function* jt(t2, e2) {
  let i2 = e2.parentPath ?? "", s2 = 0, a2 = e2.descentDepth ?? 1e5;
  if (i2.length > 0)
    s2 = i2.split("/").length - 1, a2 > 0 ? (i2 += "/", a2 += s2, t2 = t2.filter((t3) => t3.level > s2 && t3.level <= a2 && t3.path.startsWith(i2))) : t2 = t2.filter((t3) => t3.level === s2 && t3.path === i2);
  else {
    if (0 === a2)
      return;
    t2 = t2.filter((t3) => t3.level < a2);
  }
  const { searchPattern: r2 } = e2;
  if (r2)
    if (Array.isArray(r2)) {
      for (const { property: e3, value: i3, exact: s3 } of r2)
        if (void 0 !== i3)
          if (e3)
            if (s3)
              t2 = t2.filter((t3) => {
                for (const s4 of t3.properties)
                  if (s4[0] === e3 && s4[1] === i3)
                    return true;
                return false;
              });
            else {
              const s4 = new RegExp(e3, "i"), a3 = ("string" == typeof i3 ? [i3] : i3).map((t3) => new RegExp(t3, "i"));
              t2 = t2.filter((t3) => {
                for (const e4 of t3.properties)
                  if (s4.test(e4[0]) && a3.some((t4) => t4.test(e4[1])))
                    return true;
                return false;
              });
            }
          else
            t2 = s3 ? t2.filter((t3) => Dt(t3, i3)) : t2.filter((t3) => Bt(t3, i3));
    } else
      t2 = t2.filter((t3) => Bt(t3, r2));
  yield* t2.sort((t3, e3) => (0 === t3.type ? -2 : 0) + (0 === e3.type ? 2 : 0) + (t3.path > e3.path ? 1 : -1));
}
var Wt = class {
  constructor(t2) {
    __publicField(this, "db");
    this.db = t2, t2.forEach((t3, e2) => {
      t3.loadMetaData = this.loadMetaData, t3.save = this.save;
    });
  }
  loadMetaData() {
    return Promise.resolve(this);
  }
  save() {
    return Promise.resolve(false);
  }
  search(t2, e2) {
    return jt(this.db, t2);
  }
  getObjectMetdata(t2) {
    return Promise.resolve(this.db[t2]);
  }
};
async function* It(t2, e2) {
  const i2 = await fetch(t2.toString(), { signal: e2 });
  if (!i2.ok)
    throw new Error(`Failed to retreive scene metadata: ${i2.status} ${i2.statusText}`);
  if (i2.body) {
    const t3 = i2.body.getReader(), e3 = new TextDecoder("utf-8");
    let { value: s2, done: a2 } = await t3.read(), r2 = s2 ? e3.decode(s2) : "", n2 = /\r\n|\n|\r/gm, o2 = 0;
    for (; ; ) {
      let i3 = n2.exec(r2);
      if (i3)
        yield r2.substring(o2, i3.index), o2 = n2.lastIndex;
      else {
        if (a2)
          break;
        let i4 = r2.substr(o2);
        ({ value: s2, done: a2 } = await t3.read()), r2 = i4 + (s2 ? e3.decode(s2) : ""), o2 = n2.lastIndex = 0;
      }
    }
    o2 < r2.length && (yield r2.substr(o2));
  }
}
var zt = class {
  constructor(t2) {
    __publicField(this, "url");
    __publicField(this, "_promise");
    this.url = t2;
  }
  loadMetaData() {
    return Promise.resolve(this);
  }
  save() {
    return Promise.resolve(false);
  }
  async getDB(t2) {
    if (!this._promise) {
      const e2 = new URL(this.url);
      e2.pathname += "metadata", this._promise = async function(t3, e3, i2, s2) {
        let a2 = [];
        const r2 = It(t3, s2);
        for await (const t4 of r2) {
          const s3 = JSON.parse(t4);
          s3.loadMetaData = e3, s3.save = i2, a2.push(s3);
        }
        return a2;
      }(e2, this.loadMetaData, this.save, t2);
    }
    return this._promise;
  }
  search(t2, e2) {
    return async function* (t3, e3) {
      const i2 = await t3;
      for await (const t4 of jt(i2, e3))
        yield t4;
    }(this.getDB(e2), t2);
  }
  async getObjectMetdata(t2) {
    return (await this.getDB())[t2];
  }
};
var Nt = class {
  constructor(t2, e2) {
    __publicField(this, "changedCB");
    __publicField(this, "objectHighlightIndices");
    __publicField(this, "generation", 0);
    this.changedCB = e2, this.objectHighlightIndices = new Uint8Array(t2);
  }
  async commit() {
    var _a2;
    (_a2 = this.changedCB) == null ? void 0 : _a2.call(this), this.generation++;
  }
};
!function(t2) {
  t2.empty = new t2(0);
}(Nt || (Nt = {}));
var Ht = class _Ht {
  constructor(t2, e2, i2, s2, a2) {
    __publicField(this, "assetUrl");
    __publicField(this, "config");
    __publicField(this, "db");
    __publicField(this, "workerAssets");
    __publicField(this, "createWorkerScene");
    __publicField(this, "title", "");
    __publicField(this, "dateCreated", new Date(Date.now()));
    __publicField(this, "dateLastSaved", new Date(Date.now()));
    __publicField(this, "description", "");
    __publicField(this, "location");
    __publicField(this, "timezone");
    __publicField(this, "_highlighter");
    __publicField(this, "instances", []);
    __publicField(this, "boundingSphere");
    __publicField(this, "id");
    __publicField(this, "_generation", 0);
    this.assetUrl = t2, this.config = e2, this.db = i2, this.workerAssets = s2, this.createWorkerScene = a2, this.id = e2.id;
    const { center: r2, radius: n2 } = e2.boundingSphere, o2 = A(1, 1, 1);
    e2.modelWorldMatrix && (L(o2, e2.modelWorldMatrix), K(r2, r2, e2.modelWorldMatrix)), this.boundingSphere = { center: r2, radius: n2 * o2[0] };
  }
  get subtrees() {
    return this.config.subtrees;
  }
  get variants() {
    return this.config.variants;
  }
  get generation() {
    return this._generation;
  }
  async createViewState(t2, i2) {
    const { config: s2, assetUrl: a2 } = this, r2 = await this.createWorkerScene(), n2 = await t2[e](), o2 = await r2.initialize(m(n2, [n2]), i2, s2, a2);
    return o2 && (B(this.boundingSphere.center, o2.center), this.boundingSphere.radius = o2.radius), new _Ht.ViewState(this, r2);
  }
  get dynamicObjects() {
    const { instances: t2 } = this;
    return function* () {
      for (let e2 of t2)
        e2 && (yield e2);
    }();
  }
  getObjectReference(t2) {
    return { id: t2, loadMetaData: () => this.db.getObjectMetdata(t2) };
  }
  search(t2, e2) {
    return this.db.search(t2, e2);
  }
  async descendants(t2, e2) {
    if (!t2.descendants)
      try {
        const i2 = new URL(this.assetUrl);
        i2.pathname += `descendants/${t2.id}`;
        const s2 = [], a2 = It(i2, e2);
        for await (const t3 of a2)
          s2.push(parseInt(t3));
        t2.descendants = s2;
      } catch {
        t2.descendants = [];
      }
    return t2.descendants ?? [];
  }
  computeSunPosition(t2) {
    if (!this.location)
      return { azimuth: 0, inclination: 0 };
    function e2(t3) {
      return Math.sin(t3 * Math.PI / 180);
    }
    function i2(t3) {
      return 180 * Math.asin(t3) / Math.PI;
    }
    function s2(t3) {
      return Math.cos(t3 * Math.PI / 180);
    }
    function a2(t3) {
      return 180 * Math.acos(Math.max(-1, Math.min(1, t3))) / Math.PI;
    }
    const r2 = Math.floor((t2.getTime() - new Date(t2.getFullYear(), 0, 1).getTime()) / 864e5), n2 = t2.getHours() + t2.getMinutes() / 60 + this.location.longitude / 15 - (this.timezone ?? 0), o2 = 15 * n2 - 90, h2 = -i2(0.39779 * s2(0.98565 * (r2 + 10) + 1.914 * e2(0.98565 * (r2 - 2)))), c2 = i2(e2(this.location.latitude) * e2(h2) + e2(o2) * s2(this.location.latitude) * s2(h2));
    let l2;
    return l2 = this.location.latitude < 90 && this.location.latitude > -90 ? a2((e2(h2) - s2(90 - c2) * e2(this.location.latitude)) / (e2(90 - c2) * s2(this.location.latitude))) : a2(s2(15 * n2) * s2(h2) / e2(90 - c2)), { azimuth: n2 > 12 || n2 < 0 ? 360 - l2 : l2, inclination: c2 };
  }
  createDynamicObject(t2) {
    const { instances: e2 } = this, i2 = e2.length, s2 = new Ut(this, t2, () => {
      this._generation++;
    }, () => {
      e2[i2] = void 0;
    });
    return e2[i2] = s2, s2;
  }
  get objectHighlighter() {
    if (!this._highlighter) {
      let e2 = function(t3) {
        return "octree" == t3.kind;
      };
      const { config: t2 } = this;
      if (!e2(t2))
        return Nt.empty;
      {
        const { numObjects: i2 } = t2;
        this._highlighter = new Nt(i2, () => {
          this._generation++;
        });
      }
    }
    return this._highlighter;
  }
};
(Ht || (Ht = {})).ViewState = class {
  constructor(t2, e2) {
    __publicField(this, "scene");
    __publicField(this, "workerScene");
    __publicField(this, "_prevHighlighterGeneration", -1);
    __publicField(this, "_prevObjectHighlights");
    this.scene = t2, this.workerScene = e2, this._prevObjectHighlights = Lt.objectHighlights;
  }
  async dispose() {
    await this.workerScene.dispose(), this.workerScene[i]();
  }
  async generation() {
    return await this.workerScene.generation;
  }
  async update(t2, e2, i2) {
    const s2 = this.scene.instances.map((t3) => {
      if (t3) {
        const { visible: e3, position: i3, rotation: s3, scale: a3, geometry: r3 } = t3;
        return { assetId: r3.id, visible: e3, position: i3, rotation: s3, scale: a3 };
      }
    }), a2 = this.scene._highlighter;
    let r2;
    if (a2 && this._prevHighlighterGeneration != a2.generation && (this._prevHighlighterGeneration = a2.generation, r2 = a2.objectHighlightIndices.buffer), this._prevObjectHighlights != e2.objectHighlights)
      this._prevObjectHighlights = e2.objectHighlights;
    else {
      const { objectHighlights: t3, ...i3 } = e2;
      e2 = i3;
    }
    return await this.workerScene.update(t2, s2, r2, e2, i2);
  }
};
var Ut = class {
  constructor(t2, e2, i2, s2) {
    __publicField(this, "scene");
    __publicField(this, "geometry");
    __publicField(this, "updated");
    __publicField(this, "remove");
    __publicField(this, "_visible", false);
    __publicField(this, "_position", O());
    __publicField(this, "_rotation", J());
    __publicField(this, "_scale", A(1, 1, 1));
    this.scene = t2, this.geometry = e2, this.updated = i2, this.remove = s2;
  }
  get visible() {
    return this._visible;
  }
  get position() {
    return this._position;
  }
  get rotation() {
    return this._rotation;
  }
  get scale() {
    return this._scale;
  }
  set visible(t2) {
    t2 !== this._visible && (this._visible = t2, this.updated());
  }
  set position(t2) {
    q(t2, this._position) || (this._position = t2, this.updated());
  }
  set rotation(t2) {
    (function(t3, e2) {
      var i2 = t3[0], s2 = t3[1], a2 = t3[2], r2 = t3[3], n2 = e2[0], o2 = e2[1], h2 = e2[2], c2 = e2[3];
      return Math.abs(i2 - n2) <= 1e-6 * Math.max(1, Math.abs(i2), Math.abs(n2)) && Math.abs(s2 - o2) <= 1e-6 * Math.max(1, Math.abs(s2), Math.abs(o2)) && Math.abs(a2 - h2) <= 1e-6 * Math.max(1, Math.abs(a2), Math.abs(h2)) && Math.abs(r2 - c2) <= 1e-6 * Math.max(1, Math.abs(r2), Math.abs(c2));
    })(t2, this._rotation) || (this._rotation = t2, this.updated());
  }
  set scale(t2) {
    q(t2, this._scale) || (this._scale = t2, this.updated());
  }
  dispose() {
    this.remove();
  }
};
var _a;
var Kt = ((_a = document.currentScript) == null ? void 0 : _a.src) ?? import.meta.url;
async function Gt(t2) {
  const e2 = await createImageBitmap(t2), i2 = document.createElement("canvas"), { width: s2, height: a2 } = e2;
  i2.width = s2, i2.height = a2;
  const r2 = i2.getContext("2d", { alpha: true, desynchronized: true });
  return r2.drawImage(e2, 0, 0), r2.getImageData(0, 0, s2, a2);
}
function Ft(t2) {
  let e2 = 1, i2 = 0;
  return function(t3) {
    return "object" == typeof t3;
  }(t2) ? (t2.scale && (e2 = t2.scale), t2.offset && (i2 = t2.offset)) : "number" == typeof t2 && (e2 = 0, i2 = t2), [e2, i2];
}
var qt = class {
  constructor(t2, e2, i2, s2) {
    __publicField(this, "url");
    __publicField(this, "id");
    __publicField(this, "boundingSphere");
    __publicField(this, "remove");
    this.url = t2, this.id = e2, this.boundingSphere = i2, this.remove = s2;
  }
  dispose() {
    this.remove();
  }
};
var Yt = class {
  constructor(t2, e2) {
    __publicField(this, "version");
    __publicField(this, "scriptUrl");
    __publicField(this, "run", true);
    __publicField(this, "frameNumber", 0);
    __publicField(this, "animate");
    __publicField(this, "supportsOffscreenCanvas", "OffscreenCanvas" in self);
    __publicField(this, "animHandle");
    __publicField(this, "dynamicAssets", []);
    __publicField(this, "environments", []);
    __publicField(this, "views", new xt());
    __publicField(this, "workerAssets");
    __publicField(this, "_deviceProfile");
    __publicField(this, "workers");
    __publicField(this, "resolves", []);
    __publicField(this, "animateCB", async (t2) => {
      var _a2;
      this.run && ((_a2 = this.animate) == null ? void 0 : _a2.call(this, t2), this.internalUpdate());
      for (const e2 of this.resolves)
        e2(t2);
      this.resolves.length = 0, this.frameNumber++, this.animHandle = requestAnimationFrame(this.animateCB);
    });
    const i2 = new URL(e2 ?? Kt);
    this.scriptUrl = new URL("./", i2).href.slice(0, -1), this.version = "0.4.61", t2 && (this.supportsOffscreenCanvas = false), this._deviceProfile = function() {
      const t3 = document.createElement("CANVAS");
      t3.width = 1, t3.height = 1, document.body.appendChild(t3);
      const e3 = t3.getContext("webgl", { failIfMajorPerformanceCaveat: true });
      t3.remove();
      let i3 = "unknown", s2 = null == e3, a2 = 0.5, r2 = 1, n2 = 0.25, o2 = 0.35, h2 = 5e8, c2 = 5e6, l2 = true;
      const d2 = e3 == null ? void 0 : e3.getExtension("WEBGL_debug_renderer_info"), u2 = d2 ? e3 == null ? void 0 : e3.getParameter(37446) : "???", { userAgent: m2 } = navigator, p2 = /\bMobile\b/.test(m2);
      return /\bWindows\b/.test(m2) ? (i3 = "windows", s2 || (n2 = 1, a2 = screen.height > 1200 ? 0.5 : 1, r2 = devicePixelRatio, h2 = 2e9, c2 = 1e7, o2 = 0.2)) : /\bMacintosh\b/.test(m2) ? p2 ? s2 || (i3 = "ipad", n2 = 0.5, a2 = 0.5, r2 = devicePixelRatio, o2 = 0.35, h2 = 5e8, c2 = 5e6) : (i3 = "mac", s2 || (n2 = 1, a2 = screen.height > 1200 ? 0.5 : 1, r2 = devicePixelRatio, o2 = 0.2, h2 = 2e9, c2 = 1e7, /\bM[1|2]\b/.test(u2) && (a2 = devicePixelRatio, h2 = 4e9, c2 = 2e7, o2 = 1.5, l2 = false))) : /\biPad/.test(m2) ? (i3 = "ipad", s2 || (n2 = 0.5, a2 = 0.5, r2 = devicePixelRatio, o2 = 0.35, h2 = 5e8, c2 = 5e6)) : /\biPhone/.test(m2) ? (i3 = "ios", a2 = 1, r2 = devicePixelRatio) : /\bAndroid\b/.test(m2) && (i3 = "android", p2 || s2 || (n2 = 0.5, a2 = 0.5, o2 = 0.35, h2 = 5e8, c2 = 5e6)), { name: i3, hasMajorPerformanceCaveat: s2, discreteGPU: false, throttleFrames: 0, detailBias: o2, renderResolution: a2, renderResolutionIdle: r2, textureResolution: n2, gpuBytesLimit: h2, triangleLimit: c2, weakDevice: l2 };
    }();
  }
  async createWorkers() {
    const t2 = (t3, e3) => {
      if (this.scriptUrl.startsWith(self.location.origin))
        return new Worker(t3, { type: "classic", name: e3 });
      {
        const i3 = new Blob([`importScripts(${JSON.stringify(t3)});`], { type: "text/javascript" }), s3 = URL.createObjectURL(i3), a3 = new Worker(s3, { type: "classic", name: e3 });
        return URL.revokeObjectURL(s3), a3;
      }
    }, e2 = this.supportsOffscreenCanvas ? t2(`${this.scriptUrl}/render.js`, "Render") : ((t3) => {
      const { port1: e3, port2: i3 } = new MessageChannel();
      return import(t3).then((t4) => {
        const { __initRenderServiceEndPoint__: e4 } = self;
        e4(i3), delete self.__initRenderServiceEndPoint__;
      }, (t4) => {
        throw new t4();
      }), e3;
    })(`${this.scriptUrl}/render.js`), i2 = t2(`${this.scriptUrl}/geometry.js`, "Geometry"), s2 = h(e2), a2 = h(i2);
    this.workers = { render: { worker: e2, service: s2 }, geometry: { worker: i2, service: a2 } };
    const r2 = await s2.materialTypes;
    this.workerAssets = await a2.initialize(r2, this.scriptUrl, p(Gt)), this.animHandle = requestAnimationFrame(this.animateCB);
  }
  async dispose() {
    this.run = false, this.animHandle && (cancelAnimationFrame(this.animHandle), this.animHandle = void 0);
    for (const t3 of this.views)
      await t3.dispose();
    const { workers: t2 } = this;
    if (t2) {
      const { render: e2, geometry: s2 } = t2;
      await s2.service.terminate(), await e2.service.terminate(), s2.service[i](), e2.service[i](), this.workers = void 0;
    }
  }
  get deviceProfile() {
    return this._deviceProfile;
  }
  set deviceProfile(t2) {
    this._deviceProfile = t2;
  }
  waitFrame() {
    return new Promise((t2) => {
      this.resolves.push(t2);
    });
  }
  internalUpdate() {
    const t2 = [];
    for (const e2 of this.views)
      e2.disposed ? t2.push(e2) : e2.update();
    for (const e2 of t2)
      this.views.remove(e2);
  }
  async update() {
    await this.internalUpdate(), await this.waitFrame();
  }
  async loadScene(t2, e2) {
    return this.workers || await this.createWorkers(), "string" != typeof t2 && (t2 = t2.toString()), async function(t3, e3, i2) {
      let s2 = At[e3];
      if (s2)
        e3 = location.origin;
      else {
        const t4 = new URL(e3);
        t4.pathname += "config.json", s2 = await async function(t5) {
          const e4 = await fetch(t5, { mode: "cors" });
          if (!e4.ok)
            throw new Error(e4.statusText);
          return await e4.json();
        }(t4.toString());
      }
      const a2 = Ot[s2.id], r2 = i2 ?? (a2 ? new Wt(a2) : new zt(e3)), { assets: n2, createScene: o2 } = await t3.createAssets(e3);
      return new Ht(e3, s2, r2, n2, o2);
    }(this.workers.geometry.service, t2, e2);
  }
  async loadAsset(t2) {
    this.workers || await this.createWorkers();
    const { dynamicAssets: e2, workerAssets: i2 } = this, s2 = e2.length;
    e2[s2] = void 0;
    const a2 = await i2.loadAsset(s2, t2.toString());
    return e2[s2] = new qt(t2, s2, a2, async () => {
      await i2.disposeAsset(s2), e2[s2] = void 0;
    });
  }
  async loadEnvironment(t2) {
    this.workers || await this.createWorkers();
    const { environments: e2, workerAssets: i2 } = this, s2 = e2.length;
    return e2[s2] = void 0, await i2.loadEnvironment(s2, t2.url), e2[s2] = { id: s2, dispose: async () => {
      await i2.disposeEnvironment(s2), e2[s2] = void 0;
    } };
  }
  async createView(t2, e2) {
    this.workers || await this.createWorkers();
    const i2 = await async function(t3, e3, i3, s2) {
      var _a2, _b, _c;
      const a2 = ((_a2 = i3 == null ? void 0 : i3.quality) == null ? void 0 : _a2.resolution.value) ?? 1, r2 = ((_b = i3 == null ? void 0 : i3.display) == null ? void 0 : _b.width) ?? 300 * a2, n2 = ((_c = i3 == null ? void 0 : i3.display) == null ? void 0 : _c.height) ?? 150 * a2;
      self.__htmlRenderCanvas__ = s2;
      const o2 = await e3.createView(r2, n2);
      return delete self.__htmlRenderCanvas__, new Rt(t3, o2, i3);
    }(this, this.workers.render.service, t2, e2);
    return this.views.add(i2), i2;
  }
  createNeutralHighlight() {
    return { rgbaTransform: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0] };
  }
  createTransparentHighlight(t2) {
    return { rgbaTransform: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, t2, 0] };
  }
  createColorSetHighlight(t2) {
    const [e2, i2, s2, a2] = t2;
    return { rgbaTransform: [0, 0, 0, 0, e2, 0, 0, 0, 0, i2, 0, 0, 0, 0, s2, 0, 0, 0, 0, a2 ?? 1] };
  }
  createRGBATransformHighlight(t2) {
    const e2 = Ft(t2.red), i2 = Ft(t2.green), s2 = Ft(t2.blue), a2 = Ft(t2.opacity);
    return { rgbaTransform: [e2[0], 0, 0, 0, e2[1], 0, i2[0], 0, 0, i2[1], 0, 0, s2[0], 0, s2[1], 0, 0, 0, a2[0], a2[1]] };
  }
  createHSLATransformHighlight(t2) {
    const [e2, i2] = Ft(t2.lightness), [s2, a2] = Ft(t2.opacity);
    function r2(t3, e3, i3) {
      return t3 + (e3 - t3) * i3;
    }
    const n2 = t2.saturation ?? 1, o2 = r2(1 / 3, 1, n2) * e2, h2 = r2(1 / 3, 0, n2) * e2;
    return { rgbaTransform: [o2, h2, h2, 0, i2, h2, o2, h2, 0, i2, h2, h2, o2, 0, i2, 0, 0, 0, s2, a2] };
  }
  createHighlight(t2) {
    switch (t2.kind) {
      case "neutral":
        return this.createNeutralHighlight();
      case "transparent":
        return this.createTransparentHighlight(t2.opacity);
      case "color":
        return this.createColorSetHighlight(t2.color);
      case "rgba":
        return this.createRGBATransformHighlight(t2);
      case "hsla":
        return this.createHSLATransformHighlight(t2);
      default: {
        let e2 = function(t3) {
          throw new Error("Unknown highlight type {$params.kind}!");
        };
        return e2();
      }
    }
  }
  createCameraController(t2, e2) {
    switch (t2.kind) {
      case "static":
        return new dt(t2);
      case "turntable":
        return new ut(t2);
      case "orbit":
        return new mt(t2, e2);
      case "flight":
        return new pt(t2, e2);
      case "ortho":
        return new ft(t2, e2);
      default: {
        let i2 = function(t3) {
          throw new Error("Unknown controller type {$params.kind}!");
        };
        return i2();
      }
    }
  }
  async availableEnvironments(t2) {
    let e2 = [];
    const i2 = new URL(t2 ?? "/assets/env/index.json", Kt), s2 = await fetch(i2.toString());
    return s2.ok && (e2 = (await s2.json()).map((t3) => ({ name: t3, url: new URL(t3, i2).toString(), thumnbnailURL: new URL(`thumbnails/${t3}.png`, i2).toString() }))), e2;
  }
};
function Xt(t2) {
  return new Yt((t2 == null ? void 0 : t2.noOffscreenCanvas) ?? false, t2 == null ? void 0 : t2.scriptBaseUrl);
}
var Zt;
var Qt;
!function(t2) {
  t2.empty = "empty", t2.cube = "cube", t2.condos = "https://api.novorender.com/assets/scenes/condos/";
}(Zt || (Zt = {})), function(t2) {
  t2[t2.Internal = 0] = "Internal", t2[t2.Leaf = 1] = "Leaf";
}(Qt || (Qt = {}));
export {
  Yt as API,
  Qt as NodeType,
  Zt as WellKnownSceneUrls,
  Xt as createAPI
};
//# sourceMappingURL=@novorender_webgl-api.js.map
