import "./chunk-E3EO7R6B.js";

// node_modules/@novorender/data-js-api/index.js
var t = "undefined" != typeof Float32Array ? Float32Array : Array;
function s() {
  var s2 = new t(3);
  return t != Float32Array && (s2[0] = 0, s2[1] = 0, s2[2] = 0), s2;
}
function i(t2, s2) {
  return t2[0] = s2[0], t2[1] = s2[1], t2[2] = s2[2], t2;
}
Math.hypot || (Math.hypot = function() {
  for (var t2 = 0, s2 = arguments.length; s2--; )
    t2 += arguments[s2] * arguments[s2];
  return Math.sqrt(t2);
}), s();
var a = 484813681109536e-20;
var h = Math.PI / 2;
var e = 0.017453292519943295;
var n = 57.29577951308232;
var r = Math.PI / 4;
var o = 2 * Math.PI;
var l = 3.14159265359;
var c = { greenwich: 0, lisbon: -9.131906111111, paris: 2.337229166667, bogota: -74.080916666667, madrid: -3.687938888889, rome: 12.452333333333, bern: 7.439583333333, jakarta: 106.807719444444, ferro: -17.666666666667, brussels: 4.367975, stockholm: 18.058277777778, athens: 23.7163375, oslo: 10.722916666667 };
var u = { ft: { to_meter: 0.3048 }, "us-ft": { to_meter: 1200 / 3937 } };
var M = /[\s_\-\/\(\)]/g;
function d(t2, s2) {
  if (t2[s2])
    return t2[s2];
  for (var i2, a2 = Object.keys(t2), h2 = s2.toLowerCase().replace(M, ""), e2 = -1; ++e2 < a2.length; )
    if ((i2 = a2[e2]).toLowerCase().replace(M, "") === h2)
      return t2[i2];
}
function f(t2) {
  var s2, i2, a2, h2 = {}, n2 = t2.split("+").map(function(t3) {
    return t3.trim();
  }).filter(function(t3) {
    return t3;
  }).reduce(function(t3, s3) {
    var i3 = s3.split("=");
    return i3.push(true), t3[i3[0].toLowerCase()] = i3[1], t3;
  }, {}), r2 = { proj: "projName", datum: "datumCode", rf: function(t3) {
    h2.rf = parseFloat(t3);
  }, lat_0: function(t3) {
    h2.lat0 = t3 * e;
  }, lat_1: function(t3) {
    h2.lat1 = t3 * e;
  }, lat_2: function(t3) {
    h2.lat2 = t3 * e;
  }, lat_ts: function(t3) {
    h2.lat_ts = t3 * e;
  }, lon_0: function(t3) {
    h2.long0 = t3 * e;
  }, lon_1: function(t3) {
    h2.long1 = t3 * e;
  }, lon_2: function(t3) {
    h2.long2 = t3 * e;
  }, alpha: function(t3) {
    h2.alpha = parseFloat(t3) * e;
  }, gamma: function(t3) {
    h2.rectified_grid_angle = parseFloat(t3);
  }, lonc: function(t3) {
    h2.longc = t3 * e;
  }, x_0: function(t3) {
    h2.x0 = parseFloat(t3);
  }, y_0: function(t3) {
    h2.y0 = parseFloat(t3);
  }, k_0: function(t3) {
    h2.k0 = parseFloat(t3);
  }, k: function(t3) {
    h2.k0 = parseFloat(t3);
  }, a: function(t3) {
    h2.a = parseFloat(t3);
  }, b: function(t3) {
    h2.b = parseFloat(t3);
  }, r_a: function() {
    h2.R_A = true;
  }, zone: function(t3) {
    h2.zone = parseInt(t3, 10);
  }, south: function() {
    h2.utmSouth = true;
  }, towgs84: function(t3) {
    h2.datum_params = t3.split(",").map(function(t4) {
      return parseFloat(t4);
    });
  }, to_meter: function(t3) {
    h2.to_meter = parseFloat(t3);
  }, units: function(t3) {
    h2.units = t3;
    var s3 = d(u, t3);
    s3 && (h2.to_meter = s3.to_meter);
  }, from_greenwich: function(t3) {
    h2.from_greenwich = t3 * e;
  }, pm: function(t3) {
    var s3 = d(c, t3);
    h2.from_greenwich = (s3 || parseFloat(t3)) * e;
  }, nadgrids: function(t3) {
    "@null" === t3 ? h2.datumCode = "none" : h2.nadgrids = t3;
  }, axis: function(t3) {
    3 === t3.length && -1 !== "ewnsud".indexOf(t3.substr(0, 1)) && -1 !== "ewnsud".indexOf(t3.substr(1, 1)) && -1 !== "ewnsud".indexOf(t3.substr(2, 1)) && (h2.axis = t3);
  }, approx: function() {
    h2.approx = true;
  } };
  for (s2 in n2)
    i2 = n2[s2], s2 in r2 ? "function" == typeof (a2 = r2[s2]) ? a2(i2) : h2[a2] = i2 : h2[s2] = i2;
  return "string" == typeof h2.datumCode && "WGS84" !== h2.datumCode && (h2.datumCode = h2.datumCode.toLowerCase()), h2;
}
var p = /\s/;
var m = /[A-Za-z]/;
var y = /[A-Za-z84_]/;
var _ = /[,\]]/;
var g = /[\d\.E\-\+]/;
function x(t2) {
  if ("string" != typeof t2)
    throw new Error("not a string");
  this.text = t2.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = 1;
}
function v(t2, s2, i2) {
  Array.isArray(s2) && (i2.unshift(s2), s2 = null);
  var a2 = s2 ? {} : t2, h2 = i2.reduce(function(t3, s3) {
    return b(s3, t3), t3;
  }, a2);
  s2 && (t2[s2] = h2);
}
function b(t2, s2) {
  if (Array.isArray(t2)) {
    var i2 = t2.shift();
    if ("PARAMETER" === i2 && (i2 = t2.shift()), 1 === t2.length)
      return Array.isArray(t2[0]) ? (s2[i2] = {}, void b(t2[0], s2[i2])) : void (s2[i2] = t2[0]);
    if (t2.length)
      if ("TOWGS84" !== i2) {
        if ("AXIS" === i2)
          return i2 in s2 || (s2[i2] = []), void s2[i2].push(t2);
        var a2;
        switch (Array.isArray(i2) || (s2[i2] = {}), i2) {
          case "UNIT":
          case "PRIMEM":
          case "VERT_DATUM":
            return s2[i2] = { name: t2[0].toLowerCase(), convert: t2[1] }, void (3 === t2.length && b(t2[2], s2[i2]));
          case "SPHEROID":
          case "ELLIPSOID":
            return s2[i2] = { name: t2[0], a: t2[1], rf: t2[2] }, void (4 === t2.length && b(t2[3], s2[i2]));
          case "PROJECTEDCRS":
          case "PROJCRS":
          case "GEOGCS":
          case "GEOCCS":
          case "PROJCS":
          case "LOCAL_CS":
          case "GEODCRS":
          case "GEODETICCRS":
          case "GEODETICDATUM":
          case "EDATUM":
          case "ENGINEERINGDATUM":
          case "VERT_CS":
          case "VERTCRS":
          case "VERTICALCRS":
          case "COMPD_CS":
          case "COMPOUNDCRS":
          case "ENGINEERINGCRS":
          case "ENGCRS":
          case "FITTED_CS":
          case "LOCAL_DATUM":
          case "DATUM":
            return t2[0] = ["name", t2[0]], void v(s2, i2, t2);
          default:
            for (a2 = -1; ++a2 < t2.length; )
              if (!Array.isArray(t2[a2]))
                return b(t2, s2[i2]);
            return v(s2, i2, t2);
        }
      } else
        s2[i2] = t2;
    else
      s2[i2] = true;
  } else
    s2[t2] = true;
}
function w(t2) {
  return 0.017453292519943295 * t2;
}
function S(t2) {
  var s2 = new x(t2).output(), i2 = s2.shift(), a2 = s2.shift();
  s2.unshift(["name", a2]), s2.unshift(["type", i2]);
  var h2 = {};
  return b(s2, h2), function(t3) {
    if ("GEOGCS" === t3.type ? t3.projName = "longlat" : "LOCAL_CS" === t3.type ? (t3.projName = "identity", t3.local = true) : "object" == typeof t3.PROJECTION ? t3.projName = Object.keys(t3.PROJECTION)[0] : t3.projName = t3.PROJECTION, t3.AXIS) {
      for (var s3 = "", i3 = 0, a3 = t3.AXIS.length; i3 < a3; ++i3) {
        var h3 = [t3.AXIS[i3][0].toLowerCase(), t3.AXIS[i3][1].toLowerCase()];
        -1 !== h3[0].indexOf("north") || ("y" === h3[0] || "lat" === h3[0]) && "north" === h3[1] ? s3 += "n" : -1 !== h3[0].indexOf("south") || ("y" === h3[0] || "lat" === h3[0]) && "south" === h3[1] ? s3 += "s" : -1 !== h3[0].indexOf("east") || ("x" === h3[0] || "lon" === h3[0]) && "east" === h3[1] ? s3 += "e" : -1 === h3[0].indexOf("west") && ("x" !== h3[0] && "lon" !== h3[0] || "west" !== h3[1]) || (s3 += "w");
      }
      2 === s3.length && (s3 += "u"), 3 === s3.length && (t3.axis = s3);
    }
    t3.UNIT && (t3.units = t3.UNIT.name.toLowerCase(), "metre" === t3.units && (t3.units = "meter"), t3.UNIT.convert && ("GEOGCS" === t3.type ? t3.DATUM && t3.DATUM.SPHEROID && (t3.to_meter = t3.UNIT.convert * t3.DATUM.SPHEROID.a) : t3.to_meter = t3.UNIT.convert));
    var e2 = t3.GEOGCS;
    function n2(s4) {
      return s4 * (t3.to_meter || 1);
    }
    "GEOGCS" === t3.type && (e2 = t3), e2 && (e2.DATUM ? t3.datumCode = e2.DATUM.name.toLowerCase() : t3.datumCode = e2.name.toLowerCase(), "d_" === t3.datumCode.slice(0, 2) && (t3.datumCode = t3.datumCode.slice(2)), "new_zealand_geodetic_datum_1949" !== t3.datumCode && "new_zealand_1949" !== t3.datumCode || (t3.datumCode = "nzgd49"), "wgs_1984" !== t3.datumCode && "world_geodetic_system_1984" !== t3.datumCode || ("Mercator_Auxiliary_Sphere" === t3.PROJECTION && (t3.sphere = true), t3.datumCode = "wgs84"), "_ferro" === t3.datumCode.slice(-6) && (t3.datumCode = t3.datumCode.slice(0, -6)), "_jakarta" === t3.datumCode.slice(-8) && (t3.datumCode = t3.datumCode.slice(0, -8)), ~t3.datumCode.indexOf("belge") && (t3.datumCode = "rnb72"), e2.DATUM && e2.DATUM.SPHEROID && (t3.ellps = e2.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), "international" === t3.ellps.toLowerCase().slice(0, 13) && (t3.ellps = "intl"), t3.a = e2.DATUM.SPHEROID.a, t3.rf = parseFloat(e2.DATUM.SPHEROID.rf, 10)), e2.DATUM && e2.DATUM.TOWGS84 && (t3.datum_params = e2.DATUM.TOWGS84), ~t3.datumCode.indexOf("osgb_1936") && (t3.datumCode = "osgb36"), ~t3.datumCode.indexOf("osni_1952") && (t3.datumCode = "osni52"), (~t3.datumCode.indexOf("tm65") || ~t3.datumCode.indexOf("geodetic_datum_of_1965")) && (t3.datumCode = "ire65"), "ch1903+" === t3.datumCode && (t3.datumCode = "ch1903"), ~t3.datumCode.indexOf("israel") && (t3.datumCode = "isr93")), t3.b && !isFinite(t3.b) && (t3.b = t3.a), [["standard_parallel_1", "Standard_Parallel_1"], ["standard_parallel_1", "Latitude of 1st standard parallel"], ["standard_parallel_2", "Standard_Parallel_2"], ["standard_parallel_2", "Latitude of 2nd standard parallel"], ["false_easting", "False_Easting"], ["false_easting", "False easting"], ["false-easting", "Easting at false origin"], ["false_northing", "False_Northing"], ["false_northing", "False northing"], ["false_northing", "Northing at false origin"], ["central_meridian", "Central_Meridian"], ["central_meridian", "Longitude of natural origin"], ["central_meridian", "Longitude of false origin"], ["latitude_of_origin", "Latitude_Of_Origin"], ["latitude_of_origin", "Central_Parallel"], ["latitude_of_origin", "Latitude of natural origin"], ["latitude_of_origin", "Latitude of false origin"], ["scale_factor", "Scale_Factor"], ["k0", "scale_factor"], ["latitude_of_center", "Latitude_Of_Center"], ["latitude_of_center", "Latitude_of_center"], ["lat0", "latitude_of_center", w], ["longitude_of_center", "Longitude_Of_Center"], ["longitude_of_center", "Longitude_of_center"], ["longc", "longitude_of_center", w], ["x0", "false_easting", n2], ["y0", "false_northing", n2], ["long0", "central_meridian", w], ["lat0", "latitude_of_origin", w], ["lat0", "standard_parallel_1", w], ["lat1", "standard_parallel_1", w], ["lat2", "standard_parallel_2", w], ["azimuth", "Azimuth"], ["alpha", "azimuth", w], ["srsCode", "name"]].forEach(function(s4) {
      return function(t4, s5) {
        var i4 = s5[0], a4 = s5[1];
        !(i4 in t4) && a4 in t4 && (t4[i4] = t4[a4], 3 === s5.length && (t4[i4] = s5[2](t4[i4])));
      }(t3, s4);
    }), t3.long0 || !t3.longc || "Albers_Conic_Equal_Area" !== t3.projName && "Lambert_Azimuthal_Equal_Area" !== t3.projName || (t3.long0 = t3.longc), t3.lat_ts || !t3.lat1 || "Stereographic_South_Pole" !== t3.projName && "Polar Stereographic (variant B)" !== t3.projName || (t3.lat0 = w(t3.lat1 > 0 ? 90 : -90), t3.lat_ts = t3.lat1);
  }(h2), h2;
}
function P(t2) {
  var s2 = this;
  if (2 === arguments.length) {
    var i2 = arguments[1];
    "string" == typeof i2 ? "+" === i2.charAt(0) ? P[t2] = f(arguments[1]) : P[t2] = S(arguments[1]) : P[t2] = i2;
  } else if (1 === arguments.length) {
    if (Array.isArray(t2))
      return t2.map(function(t3) {
        Array.isArray(t3) ? P.apply(s2, t3) : P(t3);
      });
    if ("string" == typeof t2) {
      if (t2 in P)
        return P[t2];
    } else
      "EPSG" in t2 ? P["EPSG:" + t2.EPSG] = t2 : "ESRI" in t2 ? P["ESRI:" + t2.ESRI] = t2 : "IAU2000" in t2 && (P["IAU2000:" + t2.IAU2000] = t2);
    return;
  }
}
x.prototype.readCharicter = function() {
  var t2 = this.text[this.place++];
  if (4 !== this.state)
    for (; p.test(t2); ) {
      if (this.place >= this.text.length)
        return;
      t2 = this.text[this.place++];
    }
  switch (this.state) {
    case 1:
      return this.neutral(t2);
    case 2:
      return this.keyword(t2);
    case 4:
      return this.quoted(t2);
    case 5:
      return this.afterquote(t2);
    case 3:
      return this.number(t2);
    case -1:
      return;
  }
}, x.prototype.afterquote = function(t2) {
  if ('"' === t2)
    return this.word += '"', void (this.state = 4);
  if (_.test(t2))
    return this.word = this.word.trim(), void this.afterItem(t2);
  throw new Error(`havn't handled "` + t2 + '" in afterquote yet, index ' + this.place);
}, x.prototype.afterItem = function(t2) {
  return "," === t2 ? (null !== this.word && this.currentObject.push(this.word), this.word = null, void (this.state = 1)) : "]" === t2 ? (this.level--, null !== this.word && (this.currentObject.push(this.word), this.word = null), this.state = 1, this.currentObject = this.stack.pop(), void (this.currentObject || (this.state = -1))) : void 0;
}, x.prototype.number = function(t2) {
  if (!g.test(t2)) {
    if (_.test(t2))
      return this.word = parseFloat(this.word), void this.afterItem(t2);
    throw new Error(`havn't handled "` + t2 + '" in number yet, index ' + this.place);
  }
  this.word += t2;
}, x.prototype.quoted = function(t2) {
  '"' !== t2 ? this.word += t2 : this.state = 5;
}, x.prototype.keyword = function(t2) {
  if (y.test(t2))
    this.word += t2;
  else {
    if ("[" === t2) {
      var s2 = [];
      return s2.push(this.word), this.level++, null === this.root ? this.root = s2 : this.currentObject.push(s2), this.stack.push(this.currentObject), this.currentObject = s2, void (this.state = 1);
    }
    if (!_.test(t2))
      throw new Error(`havn't handled "` + t2 + '" in keyword yet, index ' + this.place);
    this.afterItem(t2);
  }
}, x.prototype.neutral = function(t2) {
  if (m.test(t2))
    return this.word = t2, void (this.state = 2);
  if ('"' === t2)
    return this.word = "", void (this.state = 4);
  if (g.test(t2))
    return this.word = t2, void (this.state = 3);
  if (!_.test(t2))
    throw new Error(`havn't handled "` + t2 + '" in neutral yet, index ' + this.place);
  this.afterItem(t2);
}, x.prototype.output = function() {
  for (; this.place < this.text.length; )
    this.readCharicter();
  if (-1 === this.state)
    return this.root;
  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
}, function(t2) {
  t2("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), t2("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), t2("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"), t2.WGS84 = t2["EPSG:4326"], t2["EPSG:3785"] = t2["EPSG:3857"], t2.GOOGLE = t2["EPSG:3857"], t2["EPSG:900913"] = t2["EPSG:3857"], t2["EPSG:102113"] = t2["EPSG:3857"];
}(P);
var N = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
var E = ["3857", "900913", "3785", "102113"];
function A(t2) {
  if (!function(t3) {
    return "string" == typeof t3;
  }(t2))
    return t2;
  if (function(t3) {
    return t3 in P;
  }(t2))
    return P[t2];
  if (function(t3) {
    return N.some(function(s3) {
      return t3.indexOf(s3) > -1;
    });
  }(t2)) {
    var s2 = S(t2);
    if (function(t3) {
      var s3 = d(t3, "authority");
      if (s3) {
        var i3 = d(s3, "epsg");
        return i3 && E.indexOf(i3) > -1;
      }
    }(s2))
      return P["EPSG:3857"];
    var i2 = function(t3) {
      var s3 = d(t3, "extension");
      if (s3)
        return d(s3, "proj4");
    }(s2);
    return i2 ? f(i2) : s2;
  }
  return function(t3) {
    return "+" === t3[0];
  }(t2) ? f(t2) : void 0;
}
function C(t2, s2) {
  var i2, a2;
  if (t2 = t2 || {}, !s2)
    return t2;
  for (a2 in s2)
    void 0 !== (i2 = s2[a2]) && (t2[a2] = i2);
  return t2;
}
function k(t2, s2, i2) {
  var a2 = t2 * s2;
  return i2 / Math.sqrt(1 - a2 * a2);
}
function I(t2) {
  return t2 < 0 ? -1 : 1;
}
function O(t2) {
  return Math.abs(t2) <= l ? t2 : t2 - I(t2) * o;
}
function T(t2, s2, i2) {
  var a2 = t2 * i2, e2 = 0.5 * t2;
  return a2 = Math.pow((1 - a2) / (1 + a2), e2), Math.tan(0.5 * (h - s2)) / a2;
}
function R(t2, s2) {
  for (var i2, a2, e2 = 0.5 * t2, n2 = h - 2 * Math.atan(s2), r2 = 0; r2 <= 15; r2++)
    if (i2 = t2 * Math.sin(n2), n2 += a2 = h - 2 * Math.atan(s2 * Math.pow((1 - i2) / (1 + i2), e2)) - n2, Math.abs(a2) <= 1e-10)
      return n2;
  return -9999;
}
function G(t2) {
  return t2;
}
var q = [{ init: function() {
  var t2 = this.b / this.a;
  this.es = 1 - t2 * t2, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = k(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
}, forward: function(t2) {
  var s2, i2, a2 = t2.x, e2 = t2.y;
  if (e2 * n > 90 && e2 * n < -90 && a2 * n > 180 && a2 * n < -180)
    return null;
  if (Math.abs(Math.abs(e2) - h) <= 1e-10)
    return null;
  if (this.sphere)
    s2 = this.x0 + this.a * this.k0 * O(a2 - this.long0), i2 = this.y0 + this.a * this.k0 * Math.log(Math.tan(r + 0.5 * e2));
  else {
    var o2 = Math.sin(e2), l2 = T(this.e, e2, o2);
    s2 = this.x0 + this.a * this.k0 * O(a2 - this.long0), i2 = this.y0 - this.a * this.k0 * Math.log(l2);
  }
  return t2.x = s2, t2.y = i2, t2;
}, inverse: function(t2) {
  var s2, i2, a2 = t2.x - this.x0, e2 = t2.y - this.y0;
  if (this.sphere)
    i2 = h - 2 * Math.atan(Math.exp(-e2 / (this.a * this.k0)));
  else {
    var n2 = Math.exp(-e2 / (this.a * this.k0));
    if (-9999 === (i2 = R(this.e, n2)))
      return null;
  }
  return s2 = O(this.long0 + a2 / (this.a * this.k0)), t2.x = s2, t2.y = i2, t2;
}, names: ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"] }, { init: function() {
}, forward: G, inverse: G, names: ["longlat", "identity"] }];
var j = {};
var U = [];
function L(t2, s2) {
  var i2 = U.length;
  return !t2.names || (U[i2] = t2, t2.names.forEach(function(t3) {
    j[t3.toLowerCase()] = i2;
  }), this);
}
var z = { start: function() {
  q.forEach(L);
}, add: L, get: function(t2) {
  if (!t2)
    return false;
  var s2 = t2.toLowerCase();
  return void 0 !== j[s2] && U[j[s2]] ? U[j[s2]] : void 0;
} };
var B = { MERIT: { a: 6378137, rf: 298.257, ellipseName: "MERIT 1983" }, SGS85: { a: 6378136, rf: 298.257, ellipseName: "Soviet Geodetic System 85" }, GRS80: { a: 6378137, rf: 298.257222101, ellipseName: "GRS 1980(IUGG, 1980)" }, IAU76: { a: 6378140, rf: 298.257, ellipseName: "IAU 1976" }, airy: { a: 6377563396e-3, b: 635625691e-2, ellipseName: "Airy 1830" }, APL4: { a: 6378137, rf: 298.25, ellipseName: "Appl. Physics. 1965" }, NWL9D: { a: 6378145, rf: 298.25, ellipseName: "Naval Weapons Lab., 1965" }, mod_airy: { a: 6377340189e-3, b: 6356034446e-3, ellipseName: "Modified Airy" }, andrae: { a: 637710443e-2, rf: 300, ellipseName: "Andrae 1876 (Den., Iclnd.)" }, aust_SA: { a: 6378160, rf: 298.25, ellipseName: "Australian Natl & S. Amer. 1969" }, GRS67: { a: 6378160, rf: 298.247167427, ellipseName: "GRS 67(IUGG 1967)" }, bessel: { a: 6377397155e-3, rf: 299.1528128, ellipseName: "Bessel 1841" }, bess_nam: { a: 6377483865e-3, rf: 299.1528128, ellipseName: "Bessel 1841 (Namibia)" }, clrk66: { a: 63782064e-1, b: 63565838e-1, ellipseName: "Clarke 1866" }, clrk80: { a: 6378249145e-3, rf: 293.4663, ellipseName: "Clarke 1880 mod." }, clrk58: { a: 6378293645208759e-9, rf: 294.2606763692654, ellipseName: "Clarke 1858" }, CPM: { a: 63757387e-1, rf: 334.29, ellipseName: "Comm. des Poids et Mesures 1799" }, delmbr: { a: 6376428, rf: 311.5, ellipseName: "Delambre 1810 (Belgium)" }, engelis: { a: 637813605e-2, rf: 298.2566, ellipseName: "Engelis 1985" }, evrst30: { a: 6377276345e-3, rf: 300.8017, ellipseName: "Everest 1830" }, evrst48: { a: 6377304063e-3, rf: 300.8017, ellipseName: "Everest 1948" }, evrst56: { a: 6377301243e-3, rf: 300.8017, ellipseName: "Everest 1956" }, evrst69: { a: 6377295664e-3, rf: 300.8017, ellipseName: "Everest 1969" }, evrstSS: { a: 6377298556e-3, rf: 300.8017, ellipseName: "Everest (Sabah & Sarawak)" }, fschr60: { a: 6378166, rf: 298.3, ellipseName: "Fischer (Mercury Datum) 1960" }, fschr60m: { a: 6378155, rf: 298.3, ellipseName: "Fischer 1960" }, fschr68: { a: 6378150, rf: 298.3, ellipseName: "Fischer 1968" }, helmert: { a: 6378200, rf: 298.3, ellipseName: "Helmert 1906" }, hough: { a: 6378270, rf: 297, ellipseName: "Hough" }, intl: { a: 6378388, rf: 297, ellipseName: "International 1909 (Hayford)" }, kaula: { a: 6378163, rf: 298.24, ellipseName: "Kaula 1961" }, lerch: { a: 6378139, rf: 298.257, ellipseName: "Lerch 1979" }, mprts: { a: 6397300, rf: 191, ellipseName: "Maupertius 1738" }, new_intl: { a: 63781575e-1, b: 63567722e-1, ellipseName: "New International 1967" }, plessis: { a: 6376523, rf: 6355863, ellipseName: "Plessis 1817 (France)" }, krass: { a: 6378245, rf: 298.3, ellipseName: "Krassovsky, 1942" }, SEasia: { a: 6378155, b: 63567733205e-4, ellipseName: "Southeast Asia" }, walbeck: { a: 6376896, b: 63558348467e-4, ellipseName: "Walbeck" }, WGS60: { a: 6378165, rf: 298.3, ellipseName: "WGS 60" }, WGS66: { a: 6378145, rf: 298.25, ellipseName: "WGS 66" }, WGS7: { a: 6378135, rf: 298.26, ellipseName: "WGS 72" } };
var D = B.WGS84 = { a: 6378137, rf: 298.257223563, ellipseName: "WGS 84" };
B.sphere = { a: 6370997, b: 6370997, ellipseName: "Normal Sphere (r=6370997)" };
var F = { wgs84: { towgs84: "0,0,0", ellipse: "WGS84", datumName: "WGS84" }, ch1903: { towgs84: "674.374,15.056,405.346", ellipse: "bessel", datumName: "swiss" }, ggrs87: { towgs84: "-199.87,74.79,246.62", ellipse: "GRS80", datumName: "Greek_Geodetic_Reference_System_1987" }, nad83: { towgs84: "0,0,0", ellipse: "GRS80", datumName: "North_American_Datum_1983" }, nad27: { nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat", ellipse: "clrk66", datumName: "North_American_Datum_1927" }, potsdam: { towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7", ellipse: "bessel", datumName: "Potsdam Rauenberg 1950 DHDN" }, carthage: { towgs84: "-263.0,6.0,431.0", ellipse: "clark80", datumName: "Carthage 1934 Tunisia" }, hermannskogel: { towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232", ellipse: "bessel", datumName: "Hermannskogel" }, osni52: { towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15", ellipse: "airy", datumName: "Irish National" }, ire65: { towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15", ellipse: "mod_airy", datumName: "Ireland 1965" }, rassadiran: { towgs84: "-133.63,-157.5,-158.62", ellipse: "intl", datumName: "Rassadiran" }, nzgd49: { towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993", ellipse: "intl", datumName: "New Zealand Geodetic Datum 1949" }, osgb36: { towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894", ellipse: "airy", datumName: "Airy 1830" }, s_jtsk: { towgs84: "589,76,480", ellipse: "bessel", datumName: "S-JTSK (Ferro)" }, beduaram: { towgs84: "-106,-87,188", ellipse: "clrk80", datumName: "Beduaram" }, gunung_segara: { towgs84: "-403,684,41", ellipse: "bessel", datumName: "Gunung Segara Jakarta" }, rnb72: { towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1", ellipse: "intl", datumName: "Reseau National Belge 1972" } };
var $ = {};
function H(t2) {
  if (0 === t2.length)
    return null;
  var s2 = "@" === t2[0];
  return s2 && (t2 = t2.slice(1)), "null" === t2 ? { name: "null", mandatory: !s2, grid: null, isNull: true } : { name: t2, mandatory: !s2, grid: $[t2] || null, isNull: false };
}
function W(t2) {
  return t2 / 3600 * Math.PI / 180;
}
function Q(t2, s2, i2) {
  return String.fromCharCode.apply(null, new Uint8Array(t2.buffer.slice(s2, i2)));
}
function J(t2) {
  return t2.map(function(t3) {
    return [W(t3.longitudeShift), W(t3.latitudeShift)];
  });
}
function X(t2, s2, i2) {
  return { name: Q(t2, s2 + 8, s2 + 16).trim(), parent: Q(t2, s2 + 24, s2 + 24 + 8).trim(), lowerLatitude: t2.getFloat64(s2 + 72, i2), upperLatitude: t2.getFloat64(s2 + 88, i2), lowerLongitude: t2.getFloat64(s2 + 104, i2), upperLongitude: t2.getFloat64(s2 + 120, i2), latitudeInterval: t2.getFloat64(s2 + 136, i2), longitudeInterval: t2.getFloat64(s2 + 152, i2), gridNodeCount: t2.getInt32(s2 + 168, i2) };
}
function Y(t2, s2, i2, a2) {
  for (var h2 = s2 + 176, e2 = [], n2 = 0; n2 < i2.gridNodeCount; n2++) {
    var r2 = { latitudeShift: t2.getFloat32(h2 + 16 * n2, a2), longitudeShift: t2.getFloat32(h2 + 16 * n2 + 4, a2), latitudeAccuracy: t2.getFloat32(h2 + 16 * n2 + 8, a2), longitudeAccuracy: t2.getFloat32(h2 + 16 * n2 + 12, a2) };
    e2.push(r2);
  }
  return e2;
}
function K(t2, s2) {
  if (!(this instanceof K))
    return new K(t2);
  s2 = s2 || function(t3) {
    if (t3)
      throw t3;
  };
  var i2 = A(t2);
  if ("object" == typeof i2) {
    var h2 = K.projections.get(i2.projName);
    if (h2) {
      if (i2.datumCode && "none" !== i2.datumCode) {
        var e2 = d(F, i2.datumCode);
        e2 && (i2.datum_params = i2.datum_params || (e2.towgs84 ? e2.towgs84.split(",") : null), i2.ellps = e2.ellipse, i2.datumName = e2.datumName ? e2.datumName : i2.datumCode);
      }
      i2.k0 = i2.k0 || 1, i2.axis = i2.axis || "enu", i2.ellps = i2.ellps || "wgs84", i2.lat1 = i2.lat1 || i2.lat0;
      var n2, r2, o2, l2, c2, u2, M2 = function(t3, s3, i3, a2, h3) {
        if (!t3) {
          var e3 = d(B, a2);
          e3 || (e3 = D), t3 = e3.a, s3 = e3.b, i3 = e3.rf;
        }
        return i3 && !s3 && (s3 = (1 - 1 / i3) * t3), (0 === i3 || Math.abs(t3 - s3) < 1e-10) && (h3 = true, s3 = t3), { a: t3, b: s3, rf: i3, sphere: h3 };
      }(i2.a, i2.b, i2.rf, i2.ellps, i2.sphere), f2 = (n2 = M2.a, r2 = M2.b, M2.rf, c2 = ((o2 = n2 * n2) - (l2 = r2 * r2)) / o2, u2 = 0, i2.R_A ? (o2 = (n2 *= 1 - c2 * (0.16666666666666666 + c2 * (0.04722222222222222 + 0.022156084656084655 * c2))) * n2, c2 = 0) : u2 = Math.sqrt(c2), { es: c2, e: u2, ep2: (o2 - l2) / l2 }), p2 = function(t3) {
        return void 0 === t3 ? null : t3.split(",").map(H);
      }(i2.nadgrids), m2 = i2.datum || function(t3, s3, i3, h3, e3, n3, r3) {
        var o3 = {};
        return o3.datum_type = void 0 === t3 || "none" === t3 ? 5 : 4, s3 && (o3.datum_params = s3.map(parseFloat), 0 === o3.datum_params[0] && 0 === o3.datum_params[1] && 0 === o3.datum_params[2] || (o3.datum_type = 1), o3.datum_params.length > 3 && (0 === o3.datum_params[3] && 0 === o3.datum_params[4] && 0 === o3.datum_params[5] && 0 === o3.datum_params[6] || (o3.datum_type = 2, o3.datum_params[3] *= a, o3.datum_params[4] *= a, o3.datum_params[5] *= a, o3.datum_params[6] = o3.datum_params[6] / 1e6 + 1))), r3 && (o3.datum_type = 3, o3.grids = r3), o3.a = i3, o3.b = h3, o3.es = e3, o3.ep2 = n3, o3;
      }(i2.datumCode, i2.datum_params, M2.a, M2.b, f2.es, f2.ep2, p2);
      C(this, i2), C(this, h2), this.a = M2.a, this.b = M2.b, this.rf = M2.rf, this.sphere = M2.sphere, this.es = f2.es, this.e = f2.e, this.ep2 = f2.ep2, this.datum = m2, this.init(), s2(null, this);
    } else
      s2(t2);
  } else
    s2(t2);
}
function V(t2, s2, i2) {
  var a2, e2, n2, r2, o2 = t2.x, l2 = t2.y, c2 = t2.z ? t2.z : 0;
  if (l2 < -h && l2 > -1.001 * h)
    l2 = -h;
  else if (l2 > h && l2 < 1.001 * h)
    l2 = h;
  else {
    if (l2 < -h)
      return { x: -1 / 0, y: -1 / 0, z: t2.z };
    if (l2 > h)
      return { x: 1 / 0, y: 1 / 0, z: t2.z };
  }
  return o2 > Math.PI && (o2 -= 2 * Math.PI), e2 = Math.sin(l2), r2 = Math.cos(l2), n2 = e2 * e2, { x: ((a2 = i2 / Math.sqrt(1 - s2 * n2)) + c2) * r2 * Math.cos(o2), y: (a2 + c2) * r2 * Math.sin(o2), z: (a2 * (1 - s2) + c2) * e2 };
}
function Z(t2, s2, i2, a2) {
  var h2, e2, n2, r2, o2, l2, c2, u2, M2, d2, f2, p2, m2, y2, _2, g2 = t2.x, x2 = t2.y, v2 = t2.z ? t2.z : 0;
  if (h2 = Math.sqrt(g2 * g2 + x2 * x2), e2 = Math.sqrt(g2 * g2 + x2 * x2 + v2 * v2), h2 / i2 < 1e-12) {
    if (y2 = 0, e2 / i2 < 1e-12)
      return _2 = -a2, { x: t2.x, y: t2.y, z: t2.z };
  } else
    y2 = Math.atan2(x2, g2);
  n2 = v2 / e2, u2 = (r2 = h2 / e2) * (1 - s2) * (o2 = 1 / Math.sqrt(1 - s2 * (2 - s2) * r2 * r2)), M2 = n2 * o2, m2 = 0;
  do {
    m2++, l2 = s2 * (c2 = i2 / Math.sqrt(1 - s2 * M2 * M2)) / (c2 + (_2 = h2 * u2 + v2 * M2 - c2 * (1 - s2 * M2 * M2))), p2 = (f2 = n2 * (o2 = 1 / Math.sqrt(1 - l2 * (2 - l2) * r2 * r2))) * u2 - (d2 = r2 * (1 - l2) * o2) * M2, u2 = d2, M2 = f2;
  } while (p2 * p2 > 1e-24 && m2 < 30);
  return { x: y2, y: Math.atan(f2 / Math.abs(d2)), z: _2 };
}
function tt(t2) {
  return 1 === t2 || 2 === t2;
}
function st(t2, s2, i2) {
  if (null === t2.grids || 0 === t2.grids.length)
    return -1;
  for (var a2 = { x: -i2.x, y: i2.y }, h2 = { x: Number.NaN, y: Number.NaN }, e2 = [], n2 = 0; n2 < t2.grids.length; n2++) {
    var r2 = t2.grids[n2];
    if (e2.push(r2.name), r2.isNull) {
      h2 = a2;
      break;
    }
    if (r2.mandatory, null !== r2.grid) {
      var o2 = r2.grid.subgrids[0], l2 = (Math.abs(o2.del[1]) + Math.abs(o2.del[0])) / 1e4, c2 = o2.ll[0] - l2, u2 = o2.ll[1] - l2, M2 = o2.ll[0] + (o2.lim[0] - 1) * o2.del[0] + l2, d2 = o2.ll[1] + (o2.lim[1] - 1) * o2.del[1] + l2;
      if (!(u2 > a2.y || c2 > a2.x || d2 < a2.y || M2 < a2.x || (h2 = it(a2, s2, o2), isNaN(h2.x))))
        break;
    } else if (r2.mandatory)
      return -1;
  }
  return isNaN(h2.x) ? -1 : (i2.x = -h2.x, i2.y = h2.y, 0);
}
function it(t2, s2, i2) {
  var a2 = { x: Number.NaN, y: Number.NaN };
  if (isNaN(t2.x))
    return a2;
  var h2 = { x: t2.x, y: t2.y };
  h2.x -= i2.ll[0], h2.y -= i2.ll[1], h2.x = O(h2.x - Math.PI) + Math.PI;
  var e2 = at(h2, i2);
  if (s2) {
    if (isNaN(e2.x))
      return a2;
    e2.x = h2.x - e2.x, e2.y = h2.y - e2.y;
    var n2, r2, o2 = 9;
    do {
      if (r2 = at(e2, i2), isNaN(r2.x))
        break;
      n2 = { x: h2.x - (r2.x + e2.x), y: h2.y - (r2.y + e2.y) }, e2.x += n2.x, e2.y += n2.y;
    } while (o2-- && Math.abs(n2.x) > 1e-12 && Math.abs(n2.y) > 1e-12);
    if (o2 < 0)
      return a2;
    a2.x = O(e2.x + i2.ll[0]), a2.y = e2.y + i2.ll[1];
  } else
    isNaN(e2.x) || (a2.x = t2.x + e2.x, a2.y = t2.y + e2.y);
  return a2;
}
function at(t2, s2) {
  var i2, a2 = { x: t2.x / s2.del[0], y: t2.y / s2.del[1] }, h2 = Math.floor(a2.x), e2 = Math.floor(a2.y), n2 = a2.x - 1 * h2, r2 = a2.y - 1 * e2, o2 = { x: Number.NaN, y: Number.NaN };
  if (h2 < 0 || h2 >= s2.lim[0])
    return o2;
  if (e2 < 0 || e2 >= s2.lim[1])
    return o2;
  i2 = e2 * s2.lim[0] + h2;
  var l2 = s2.cvs[i2][0], c2 = s2.cvs[i2][1];
  i2++;
  var u2 = s2.cvs[i2][0], M2 = s2.cvs[i2][1];
  i2 += s2.lim[0];
  var d2 = s2.cvs[i2][0], f2 = s2.cvs[i2][1];
  i2--;
  var p2 = s2.cvs[i2][0], m2 = s2.cvs[i2][1], y2 = n2 * r2, _2 = n2 * (1 - r2), g2 = (1 - n2) * (1 - r2), x2 = (1 - n2) * r2;
  return o2.x = g2 * l2 + _2 * u2 + x2 * p2 + y2 * d2, o2.y = g2 * c2 + _2 * M2 + x2 * m2 + y2 * f2, o2;
}
function ht(t2, s2, i2) {
  var a2, h2, e2, n2 = i2.x, r2 = i2.y, o2 = i2.z || 0, l2 = {};
  for (e2 = 0; e2 < 3; e2++)
    if (!s2 || 2 !== e2 || void 0 !== i2.z)
      switch (0 === e2 ? (a2 = n2, h2 = -1 !== "ew".indexOf(t2.axis[e2]) ? "x" : "y") : 1 === e2 ? (a2 = r2, h2 = -1 !== "ns".indexOf(t2.axis[e2]) ? "y" : "x") : (a2 = o2, h2 = "z"), t2.axis[e2]) {
        case "e":
          l2[h2] = a2;
          break;
        case "w":
          l2[h2] = -a2;
          break;
        case "n":
          l2[h2] = a2;
          break;
        case "s":
          l2[h2] = -a2;
          break;
        case "u":
          void 0 !== i2[h2] && (l2.z = a2);
          break;
        case "d":
          void 0 !== i2[h2] && (l2.z = -a2);
          break;
        default:
          return null;
      }
  return l2;
}
function et(t2) {
  var s2 = { x: t2[0], y: t2[1] };
  return t2.length > 2 && (s2.z = t2[2]), t2.length > 3 && (s2.m = t2[3]), s2;
}
function nt(t2) {
  if ("function" == typeof Number.isFinite) {
    if (Number.isFinite(t2))
      return;
    throw new TypeError("coordinates must be finite numbers");
  }
  if ("number" != typeof t2 || t2 != t2 || !isFinite(t2))
    throw new TypeError("coordinates must be finite numbers");
}
function rt(t2, s2, i2, a2) {
  var h2;
  if (Array.isArray(i2) && (i2 = et(i2)), function(t3) {
    nt(t3.x), nt(t3.y);
  }(i2), t2.datum && s2.datum && function(t3, s3) {
    return (1 === t3.datum.datum_type || 2 === t3.datum.datum_type) && "WGS84" !== s3.datumCode || (1 === s3.datum.datum_type || 2 === s3.datum.datum_type) && "WGS84" !== t3.datumCode;
  }(t2, s2) && (i2 = rt(t2, h2 = new K("WGS84"), i2, a2), t2 = h2), a2 && "enu" !== t2.axis && (i2 = ht(t2, false, i2)), "longlat" === t2.projName)
    i2 = { x: i2.x * e, y: i2.y * e, z: i2.z || 0 };
  else if (t2.to_meter && (i2 = { x: i2.x * t2.to_meter, y: i2.y * t2.to_meter, z: i2.z || 0 }), !(i2 = t2.inverse(i2)))
    return;
  if (t2.from_greenwich && (i2.x += t2.from_greenwich), i2 = function(t3, s3, i3) {
    if (function(t4, s4) {
      return t4.datum_type === s4.datum_type && !(t4.a !== s4.a || Math.abs(t4.es - s4.es) > 5e-11) && (1 === t4.datum_type ? t4.datum_params[0] === s4.datum_params[0] && t4.datum_params[1] === s4.datum_params[1] && t4.datum_params[2] === s4.datum_params[2] : 2 !== t4.datum_type || t4.datum_params[0] === s4.datum_params[0] && t4.datum_params[1] === s4.datum_params[1] && t4.datum_params[2] === s4.datum_params[2] && t4.datum_params[3] === s4.datum_params[3] && t4.datum_params[4] === s4.datum_params[4] && t4.datum_params[5] === s4.datum_params[5] && t4.datum_params[6] === s4.datum_params[6]);
    }(t3, s3))
      return i3;
    if (5 === t3.datum_type || 5 === s3.datum_type)
      return i3;
    var a3 = t3.a, h3 = t3.es;
    if (3 === t3.datum_type) {
      if (0 !== st(t3, false, i3))
        return;
      a3 = 6378137, h3 = 0.0066943799901413165;
    }
    var e2 = s3.a, n2 = s3.b, r2 = s3.es;
    return 3 === s3.datum_type && (e2 = 6378137, n2 = 6356752314e-3, r2 = 0.0066943799901413165), h3 !== r2 || a3 !== e2 || tt(t3.datum_type) || tt(s3.datum_type) ? (i3 = V(i3, h3, a3), tt(t3.datum_type) && (i3 = function(t4, s4, i4) {
      if (1 === s4)
        return { x: t4.x + i4[0], y: t4.y + i4[1], z: t4.z + i4[2] };
      if (2 === s4) {
        var a4 = i4[0], h4 = i4[1], e3 = i4[2], n3 = i4[3], r3 = i4[4], o2 = i4[5], l2 = i4[6];
        return { x: l2 * (t4.x - o2 * t4.y + r3 * t4.z) + a4, y: l2 * (o2 * t4.x + t4.y - n3 * t4.z) + h4, z: l2 * (-r3 * t4.x + n3 * t4.y + t4.z) + e3 };
      }
    }(i3, t3.datum_type, t3.datum_params)), tt(s3.datum_type) && (i3 = function(t4, s4, i4) {
      if (1 === s4)
        return { x: t4.x - i4[0], y: t4.y - i4[1], z: t4.z - i4[2] };
      if (2 === s4) {
        var a4 = i4[0], h4 = i4[1], e3 = i4[2], n3 = i4[3], r3 = i4[4], o2 = i4[5], l2 = i4[6], c2 = (t4.x - a4) / l2, u2 = (t4.y - h4) / l2, M2 = (t4.z - e3) / l2;
        return { x: c2 + o2 * u2 - r3 * M2, y: -o2 * c2 + u2 + n3 * M2, z: r3 * c2 - n3 * u2 + M2 };
      }
    }(i3, s3.datum_type, s3.datum_params)), i3 = Z(i3, r2, e2, n2), 3 !== s3.datum_type || 0 === st(s3, true, i3) ? i3 : void 0) : i3;
  }(t2.datum, s2.datum, i2))
    return s2.from_greenwich && (i2 = { x: i2.x - s2.from_greenwich, y: i2.y, z: i2.z || 0 }), "longlat" === s2.projName ? i2 = { x: i2.x * n, y: i2.y * n, z: i2.z || 0 } : (i2 = s2.forward(i2), s2.to_meter && (i2 = { x: i2.x / s2.to_meter, y: i2.y / s2.to_meter, z: i2.z || 0 })), a2 && "enu" !== s2.axis ? ht(s2, true, i2) : i2;
}
K.projections = z, K.projections.start();
var ot = K("WGS84");
function lt(t2, s2, i2, a2) {
  var h2, e2, n2;
  return Array.isArray(i2) ? (h2 = rt(t2, s2, i2, a2) || { x: NaN, y: NaN }, i2.length > 2 ? void 0 !== t2.name && "geocent" === t2.name || void 0 !== s2.name && "geocent" === s2.name ? "number" == typeof h2.z ? [h2.x, h2.y, h2.z].concat(i2.splice(3)) : [h2.x, h2.y, i2[2]].concat(i2.splice(3)) : [h2.x, h2.y].concat(i2.splice(2)) : [h2.x, h2.y]) : (e2 = rt(t2, s2, i2, a2), 2 === (n2 = Object.keys(i2)).length || n2.forEach(function(a3) {
    if (void 0 !== t2.name && "geocent" === t2.name || void 0 !== s2.name && "geocent" === s2.name) {
      if ("x" === a3 || "y" === a3 || "z" === a3)
        return;
    } else if ("x" === a3 || "y" === a3)
      return;
    e2[a3] = i2[a3];
  }), e2);
}
function ct(t2) {
  return t2 instanceof K ? t2 : t2.oProj ? t2.oProj : K(t2);
}
function ut(t2, s2, i2) {
  t2 = ct(t2);
  var a2, h2 = false;
  return void 0 === s2 ? (s2 = t2, t2 = ot, h2 = true) : (void 0 !== s2.x || Array.isArray(s2)) && (i2 = s2, s2 = t2, t2 = ot, h2 = true), s2 = ct(s2), i2 ? lt(t2, s2, i2) : (a2 = { forward: function(i3, a3) {
    return lt(t2, s2, i3, a3);
  }, inverse: function(i3, a3) {
    return lt(s2, t2, i3, a3);
  } }, h2 && (a2.oProj = s2), a2);
}
var Mt = { forward: dt, inverse: function(t2) {
  var s2 = yt(xt(t2.toUpperCase()));
  return s2.lat && s2.lon ? [s2.lon, s2.lat, s2.lon, s2.lat] : [s2.left, s2.bottom, s2.right, s2.top];
}, toPoint: ft };
function dt(t2, s2) {
  return s2 = s2 || 5, function(t3, s3) {
    var i2, a2, h2, e2, n2, r2, o2, l2, c2, u2, M2, d2 = "00000" + t3.easting, f2 = "00000" + t3.northing;
    return t3.zoneNumber + t3.zoneLetter + (c2 = t3.easting, u2 = t3.northing, M2 = gt(t3.zoneNumber), i2 = Math.floor(c2 / 1e5), a2 = Math.floor(u2 / 1e5) % 20, l2 = false, (r2 = (e2 = "AJSAJS".charCodeAt(h2 = M2 - 1)) + i2 - 1) > 90 && (r2 = r2 - 90 + 65 - 1, l2 = true), (73 === r2 || e2 < 73 && r2 > 73 || (r2 > 73 || e2 < 73) && l2) && r2++, (79 === r2 || e2 < 79 && r2 > 79 || (r2 > 79 || e2 < 79) && l2) && 73 == ++r2 && r2++, r2 > 90 && (r2 = r2 - 90 + 65 - 1), (o2 = (n2 = "AFAFAF".charCodeAt(h2)) + a2) > 86 ? (o2 = o2 - 86 + 65 - 1, l2 = true) : l2 = false, (73 === o2 || n2 < 73 && o2 > 73 || (o2 > 73 || n2 < 73) && l2) && o2++, (79 === o2 || n2 < 79 && o2 > 79 || (o2 > 79 || n2 < 79) && l2) && 73 == ++o2 && o2++, o2 > 86 && (o2 = o2 - 86 + 65 - 1), String.fromCharCode(r2) + String.fromCharCode(o2)) + d2.substr(d2.length - 5, s3) + f2.substr(f2.length - 5, s3);
  }(function(t3) {
    var s3, i2, a2, h2, e2, n2, r2 = t3.lat, o2 = t3.lon, l2 = 6378137, c2 = pt(r2), u2 = pt(o2);
    n2 = Math.floor((o2 + 180) / 6) + 1, 180 === o2 && (n2 = 60), r2 >= 56 && r2 < 64 && o2 >= 3 && o2 < 12 && (n2 = 32), r2 >= 72 && r2 < 84 && (o2 >= 0 && o2 < 9 ? n2 = 31 : o2 >= 9 && o2 < 21 ? n2 = 33 : o2 >= 21 && o2 < 33 ? n2 = 35 : o2 >= 33 && o2 < 42 && (n2 = 37)), e2 = pt(6 * (n2 - 1) - 180 + 3), s3 = l2 / Math.sqrt(1 - 669438e-8 * Math.sin(c2) * Math.sin(c2)), i2 = Math.tan(c2) * Math.tan(c2), a2 = 0.006739496752268451 * Math.cos(c2) * Math.cos(c2);
    var M2 = 0.9996 * s3 * ((h2 = Math.cos(c2) * (u2 - e2)) + (1 - i2 + a2) * h2 * h2 * h2 / 6 + (5 - 18 * i2 + i2 * i2 + 72 * a2 - 0.39089081163157013) * h2 * h2 * h2 * h2 * h2 / 120) + 5e5, d2 = 0.9996 * (l2 * (0.9983242984503243 * c2 - 0.002514607064228144 * Math.sin(2 * c2) + 2639046602129982e-21 * Math.sin(4 * c2) - 3418046101696858e-24 * Math.sin(6 * c2)) + s3 * Math.tan(c2) * (h2 * h2 / 2 + (5 - i2 + 9 * a2 + 4 * a2 * a2) * h2 * h2 * h2 * h2 / 24 + (61 - 58 * i2 + i2 * i2 + 600 * a2 - 2.2240339282485886) * h2 * h2 * h2 * h2 * h2 * h2 / 720));
    return r2 < 0 && (d2 += 1e7), { northing: Math.round(d2), easting: Math.round(M2), zoneNumber: n2, zoneLetter: _t(r2) };
  }({ lat: t2[1], lon: t2[0] }), s2);
}
function ft(t2) {
  var s2 = yt(xt(t2.toUpperCase()));
  return s2.lat && s2.lon ? [s2.lon, s2.lat] : [(s2.left + s2.right) / 2, (s2.top + s2.bottom) / 2];
}
function pt(t2) {
  return t2 * (Math.PI / 180);
}
function mt(t2) {
  return t2 / Math.PI * 180;
}
function yt(t2) {
  var s2 = t2.northing, i2 = t2.easting, a2 = t2.zoneLetter, h2 = t2.zoneNumber;
  if (h2 < 0 || h2 > 60)
    return null;
  var e2, n2, r2, o2, l2, c2, u2, M2, d2 = 6378137, f2 = (1 - Math.sqrt(0.99330562)) / (1 + Math.sqrt(0.99330562)), p2 = i2 - 5e5, m2 = s2;
  a2 < "N" && (m2 -= 1e7), c2 = 6 * (h2 - 1) - 180 + 3, M2 = (u2 = m2 / 0.9996 / 6367449145945056e-9) + (3 * f2 / 2 - 27 * f2 * f2 * f2 / 32) * Math.sin(2 * u2) + (21 * f2 * f2 / 16 - 55 * f2 * f2 * f2 * f2 / 32) * Math.sin(4 * u2) + 151 * f2 * f2 * f2 / 96 * Math.sin(6 * u2), e2 = d2 / Math.sqrt(1 - 669438e-8 * Math.sin(M2) * Math.sin(M2)), n2 = Math.tan(M2) * Math.tan(M2), r2 = 0.006739496752268451 * Math.cos(M2) * Math.cos(M2), o2 = 0.99330562 * d2 / Math.pow(1 - 669438e-8 * Math.sin(M2) * Math.sin(M2), 1.5), l2 = p2 / (0.9996 * e2);
  var y2 = M2 - e2 * Math.tan(M2) / o2 * (l2 * l2 / 2 - (5 + 3 * n2 + 10 * r2 - 4 * r2 * r2 - 0.06065547077041606) * l2 * l2 * l2 * l2 / 24 + (61 + 90 * n2 + 298 * r2 + 45 * n2 * n2 - 1.6983531815716497 - 3 * r2 * r2) * l2 * l2 * l2 * l2 * l2 * l2 / 720);
  y2 = mt(y2);
  var _2, g2 = (l2 - (1 + 2 * n2 + r2) * l2 * l2 * l2 / 6 + (5 - 2 * r2 + 28 * n2 - 3 * r2 * r2 + 0.05391597401814761 + 24 * n2 * n2) * l2 * l2 * l2 * l2 * l2 / 120) / Math.cos(M2);
  if (g2 = c2 + mt(g2), t2.accuracy) {
    var x2 = yt({ northing: t2.northing + t2.accuracy, easting: t2.easting + t2.accuracy, zoneLetter: t2.zoneLetter, zoneNumber: t2.zoneNumber });
    _2 = { top: x2.lat, right: x2.lon, bottom: y2, left: g2 };
  } else
    _2 = { lat: y2, lon: g2 };
  return _2;
}
function _t(t2) {
  var s2 = "Z";
  return 84 >= t2 && t2 >= 72 ? s2 = "X" : 72 > t2 && t2 >= 64 ? s2 = "W" : 64 > t2 && t2 >= 56 ? s2 = "V" : 56 > t2 && t2 >= 48 ? s2 = "U" : 48 > t2 && t2 >= 40 ? s2 = "T" : 40 > t2 && t2 >= 32 ? s2 = "S" : 32 > t2 && t2 >= 24 ? s2 = "R" : 24 > t2 && t2 >= 16 ? s2 = "Q" : 16 > t2 && t2 >= 8 ? s2 = "P" : 8 > t2 && t2 >= 0 ? s2 = "N" : 0 > t2 && t2 >= -8 ? s2 = "M" : -8 > t2 && t2 >= -16 ? s2 = "L" : -16 > t2 && t2 >= -24 ? s2 = "K" : -24 > t2 && t2 >= -32 ? s2 = "J" : -32 > t2 && t2 >= -40 ? s2 = "H" : -40 > t2 && t2 >= -48 ? s2 = "G" : -48 > t2 && t2 >= -56 ? s2 = "F" : -56 > t2 && t2 >= -64 ? s2 = "E" : -64 > t2 && t2 >= -72 ? s2 = "D" : -72 > t2 && t2 >= -80 && (s2 = "C"), s2;
}
function gt(t2) {
  var s2 = t2 % 6;
  return 0 === s2 && (s2 = 6), s2;
}
function xt(t2) {
  if (t2 && 0 === t2.length)
    throw "MGRSPoint coverting from nothing";
  for (var s2, i2 = t2.length, a2 = null, h2 = "", e2 = 0; !/[A-Z]/.test(s2 = t2.charAt(e2)); ) {
    if (e2 >= 2)
      throw "MGRSPoint bad conversion from: " + t2;
    h2 += s2, e2++;
  }
  var n2 = parseInt(h2, 10);
  if (0 === e2 || e2 + 3 > i2)
    throw "MGRSPoint bad conversion from: " + t2;
  var r2 = t2.charAt(e2++);
  if (r2 <= "A" || "B" === r2 || "Y" === r2 || r2 >= "Z" || "I" === r2 || "O" === r2)
    throw "MGRSPoint zone letter " + r2 + " not handled: " + t2;
  a2 = t2.substring(e2, e2 += 2);
  for (var o2 = gt(n2), l2 = function(t3, s3) {
    for (var i3 = "AJSAJS".charCodeAt(s3 - 1), a3 = 1e5, h3 = false; i3 !== t3.charCodeAt(0); ) {
      if (73 == ++i3 && i3++, 79 === i3 && i3++, i3 > 90) {
        if (h3)
          throw "Bad character: " + t3;
        i3 = 65, h3 = true;
      }
      a3 += 1e5;
    }
    return a3;
  }(a2.charAt(0), o2), c2 = function(t3, s3) {
    if (t3 > "V")
      throw "MGRSPoint given invalid Northing " + t3;
    for (var i3 = "AFAFAF".charCodeAt(s3 - 1), a3 = 0, h3 = false; i3 !== t3.charCodeAt(0); ) {
      if (73 == ++i3 && i3++, 79 === i3 && i3++, i3 > 86) {
        if (h3)
          throw "Bad character: " + t3;
        i3 = 65, h3 = true;
      }
      a3 += 1e5;
    }
    return a3;
  }(a2.charAt(1), o2); c2 < vt(r2); )
    c2 += 2e6;
  var u2 = i2 - e2;
  if (u2 % 2 != 0)
    throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + t2;
  var M2, d2, f2, p2 = u2 / 2, m2 = 0, y2 = 0;
  return p2 > 0 && (M2 = 1e5 / Math.pow(10, p2), d2 = t2.substring(e2, e2 + p2), m2 = parseFloat(d2) * M2, f2 = t2.substring(e2 + p2), y2 = parseFloat(f2) * M2), { easting: m2 + l2, northing: y2 + c2, zoneLetter: r2, zoneNumber: n2, accuracy: M2 };
}
function vt(t2) {
  var s2;
  switch (t2) {
    case "C":
      s2 = 11e5;
      break;
    case "D":
      s2 = 2e6;
      break;
    case "E":
      s2 = 28e5;
      break;
    case "F":
      s2 = 37e5;
      break;
    case "G":
      s2 = 46e5;
      break;
    case "H":
      s2 = 55e5;
      break;
    case "J":
      s2 = 64e5;
      break;
    case "K":
      s2 = 73e5;
      break;
    case "L":
      s2 = 82e5;
      break;
    case "M":
      s2 = 91e5;
      break;
    case "N":
      s2 = 0;
      break;
    case "P":
      s2 = 8e5;
      break;
    case "Q":
      s2 = 17e5;
      break;
    case "R":
      s2 = 26e5;
      break;
    case "S":
      s2 = 35e5;
      break;
    case "T":
      s2 = 44e5;
      break;
    case "U":
      s2 = 53e5;
      break;
    case "V":
      s2 = 62e5;
      break;
    case "W":
      s2 = 7e6;
      break;
    case "X":
      s2 = 79e5;
      break;
    default:
      s2 = -1;
  }
  if (s2 >= 0)
    return s2;
  throw "Invalid zone letter: " + t2;
}
function bt(t2, s2, i2) {
  if (!(this instanceof bt))
    return new bt(t2, s2, i2);
  if (Array.isArray(t2))
    this.x = t2[0], this.y = t2[1], this.z = t2[2] || 0;
  else if ("object" == typeof t2)
    this.x = t2.x, this.y = t2.y, this.z = t2.z || 0;
  else if ("string" == typeof t2 && void 0 === s2) {
    var a2 = t2.split(",");
    this.x = parseFloat(a2[0], 10), this.y = parseFloat(a2[1], 10), this.z = parseFloat(a2[2], 10) || 0;
  } else
    this.x = t2, this.y = s2, this.z = i2 || 0;
}
bt.fromMGRS = function(t2) {
  return new bt(ft(t2));
}, bt.prototype.toMGRS = function(t2) {
  return dt([this.x, this.y], t2);
};
var wt = 0.01068115234375;
function St(t2) {
  var s2 = [];
  s2[0] = 1 - t2 * (0.25 + t2 * (0.046875 + t2 * (0.01953125 + t2 * wt))), s2[1] = t2 * (0.75 - t2 * (0.046875 + t2 * (0.01953125 + t2 * wt)));
  var i2 = t2 * t2;
  return s2[2] = i2 * (0.46875 - t2 * (0.013020833333333334 + 0.007120768229166667 * t2)), i2 *= t2, s2[3] = i2 * (0.3645833333333333 - 0.005696614583333333 * t2), s2[4] = i2 * t2 * 0.3076171875, s2;
}
function Pt(t2, s2, i2, a2) {
  return i2 *= s2, s2 *= s2, a2[0] * t2 - i2 * (a2[1] + s2 * (a2[2] + s2 * (a2[3] + s2 * a2[4])));
}
function Nt(t2, s2, i2) {
  for (var a2 = 1 / (1 - s2), h2 = t2, e2 = 20; e2; --e2) {
    var n2 = Math.sin(h2), r2 = 1 - s2 * n2 * n2;
    if (h2 -= r2 = (Pt(h2, n2, Math.cos(h2), i2) - t2) * (r2 * Math.sqrt(r2)) * a2, Math.abs(r2) < 1e-10)
      return h2;
  }
  return h2;
}
var Et = { init: function() {
  this.x0 = void 0 !== this.x0 ? this.x0 : 0, this.y0 = void 0 !== this.y0 ? this.y0 : 0, this.long0 = void 0 !== this.long0 ? this.long0 : 0, this.lat0 = void 0 !== this.lat0 ? this.lat0 : 0, this.es && (this.en = St(this.es), this.ml0 = Pt(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en));
}, forward: function(t2) {
  var s2, i2, a2, h2 = t2.x, e2 = t2.y, n2 = O(h2 - this.long0), r2 = Math.sin(e2), o2 = Math.cos(e2);
  if (this.es) {
    var l2 = o2 * n2, c2 = Math.pow(l2, 2), u2 = this.ep2 * Math.pow(o2, 2), M2 = Math.pow(u2, 2), d2 = Math.abs(o2) > 1e-10 ? Math.tan(e2) : 0, f2 = Math.pow(d2, 2), p2 = Math.pow(f2, 2);
    s2 = 1 - this.es * Math.pow(r2, 2), l2 /= Math.sqrt(s2);
    var m2 = Pt(e2, r2, o2, this.en);
    i2 = this.a * (this.k0 * l2 * (1 + c2 / 6 * (1 - f2 + u2 + c2 / 20 * (5 - 18 * f2 + p2 + 14 * u2 - 58 * f2 * u2 + c2 / 42 * (61 + 179 * p2 - p2 * f2 - 479 * f2))))) + this.x0, a2 = this.a * (this.k0 * (m2 - this.ml0 + r2 * n2 * l2 / 2 * (1 + c2 / 12 * (5 - f2 + 9 * u2 + 4 * M2 + c2 / 30 * (61 + p2 - 58 * f2 + 270 * u2 - 330 * f2 * u2 + c2 / 56 * (1385 + 543 * p2 - p2 * f2 - 3111 * f2)))))) + this.y0;
  } else {
    var y2 = o2 * Math.sin(n2);
    if (Math.abs(Math.abs(y2) - 1) < 1e-10)
      return 93;
    if (i2 = 0.5 * this.a * this.k0 * Math.log((1 + y2) / (1 - y2)) + this.x0, a2 = o2 * Math.cos(n2) / Math.sqrt(1 - Math.pow(y2, 2)), (y2 = Math.abs(a2)) >= 1) {
      if (y2 - 1 > 1e-10)
        return 93;
      a2 = 0;
    } else
      a2 = Math.acos(a2);
    e2 < 0 && (a2 = -a2), a2 = this.a * this.k0 * (a2 - this.lat0) + this.y0;
  }
  return t2.x = i2, t2.y = a2, t2;
}, inverse: function(t2) {
  var s2, i2, a2, e2, n2 = (t2.x - this.x0) * (1 / this.a), r2 = (t2.y - this.y0) * (1 / this.a);
  if (this.es)
    if (i2 = Nt(s2 = this.ml0 + r2 / this.k0, this.es, this.en), Math.abs(i2) < h) {
      var o2 = Math.sin(i2), l2 = Math.cos(i2), c2 = Math.abs(l2) > 1e-10 ? Math.tan(i2) : 0, u2 = this.ep2 * Math.pow(l2, 2), M2 = Math.pow(u2, 2), d2 = Math.pow(c2, 2), f2 = Math.pow(d2, 2);
      s2 = 1 - this.es * Math.pow(o2, 2);
      var p2 = n2 * Math.sqrt(s2) / this.k0, m2 = Math.pow(p2, 2);
      a2 = i2 - (s2 *= c2) * m2 / (1 - this.es) * 0.5 * (1 - m2 / 12 * (5 + 3 * d2 - 9 * u2 * d2 + u2 - 4 * M2 - m2 / 30 * (61 + 90 * d2 - 252 * u2 * d2 + 45 * f2 + 46 * u2 - m2 / 56 * (1385 + 3633 * d2 + 4095 * f2 + 1574 * f2 * d2)))), e2 = O(this.long0 + p2 * (1 - m2 / 6 * (1 + 2 * d2 + u2 - m2 / 20 * (5 + 28 * d2 + 24 * f2 + 8 * u2 * d2 + 6 * u2 - m2 / 42 * (61 + 662 * d2 + 1320 * f2 + 720 * f2 * d2)))) / l2);
    } else
      a2 = h * I(r2), e2 = 0;
  else {
    var y2 = Math.exp(n2 / this.k0), _2 = 0.5 * (y2 - 1 / y2), g2 = this.lat0 + r2 / this.k0, x2 = Math.cos(g2);
    s2 = Math.sqrt((1 - Math.pow(x2, 2)) / (1 + Math.pow(_2, 2))), a2 = Math.asin(s2), r2 < 0 && (a2 = -a2), e2 = 0 === _2 && 0 === x2 ? 0 : O(Math.atan2(_2, x2) + this.long0);
  }
  return t2.x = e2, t2.y = a2, t2;
}, names: ["Fast_Transverse_Mercator", "Fast Transverse Mercator"] };
function At(t2) {
  var s2 = Math.exp(t2);
  return (s2 - 1 / s2) / 2;
}
function Ct(t2, s2) {
  t2 = Math.abs(t2), s2 = Math.abs(s2);
  var i2 = Math.max(t2, s2), a2 = Math.min(t2, s2) / (i2 || 1);
  return i2 * Math.sqrt(1 + Math.pow(a2, 2));
}
function kt(t2, s2) {
  for (var i2, a2 = 2 * Math.cos(2 * s2), h2 = t2.length - 1, e2 = t2[h2], n2 = 0; --h2 >= 0; )
    i2 = a2 * e2 - n2 + t2[h2], n2 = e2, e2 = i2;
  return s2 + i2 * Math.sin(2 * s2);
}
function It(t2, s2, i2) {
  for (var a2, h2, e2 = Math.sin(s2), n2 = Math.cos(s2), r2 = At(i2), o2 = function(t3) {
    var s3 = Math.exp(t3);
    return (s3 + 1 / s3) / 2;
  }(i2), l2 = 2 * n2 * o2, c2 = -2 * e2 * r2, u2 = t2.length - 1, M2 = t2[u2], d2 = 0, f2 = 0, p2 = 0; --u2 >= 0; )
    a2 = f2, h2 = d2, M2 = l2 * (f2 = M2) - a2 - c2 * (d2 = p2) + t2[u2], p2 = c2 * f2 - h2 + l2 * d2;
  return [(l2 = e2 * o2) * M2 - (c2 = n2 * r2) * p2, l2 * p2 + c2 * M2];
}
var Ot = { init: function() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0))
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  this.approx && (Et.init.apply(this), this.forward = Et.forward, this.inverse = Et.inverse), this.x0 = void 0 !== this.x0 ? this.x0 : 0, this.y0 = void 0 !== this.y0 ? this.y0 : 0, this.long0 = void 0 !== this.long0 ? this.long0 : 0, this.lat0 = void 0 !== this.lat0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
  var t2 = this.es / (1 + Math.sqrt(1 - this.es)), s2 = t2 / (2 - t2), i2 = s2;
  this.cgb[0] = s2 * (2 + s2 * (-2 / 3 + s2 * (s2 * (116 / 45 + s2 * (26 / 45 + s2 * (-2854 / 675))) - 2))), this.cbg[0] = s2 * (s2 * (2 / 3 + s2 * (4 / 3 + s2 * (-82 / 45 + s2 * (32 / 45 + s2 * (4642 / 4725))))) - 2), i2 *= s2, this.cgb[1] = i2 * (7 / 3 + s2 * (s2 * (-227 / 45 + s2 * (2704 / 315 + s2 * (2323 / 945))) - 1.6)), this.cbg[1] = i2 * (5 / 3 + s2 * (-16 / 15 + s2 * (-13 / 9 + s2 * (904 / 315 + s2 * (-1522 / 945))))), i2 *= s2, this.cgb[2] = i2 * (56 / 15 + s2 * (-136 / 35 + s2 * (-1262 / 105 + s2 * (73814 / 2835)))), this.cbg[2] = i2 * (-26 / 15 + s2 * (34 / 21 + s2 * (1.6 + s2 * (-12686 / 2835)))), i2 *= s2, this.cgb[3] = i2 * (4279 / 630 + s2 * (-332 / 35 + s2 * (-399572 / 14175))), this.cbg[3] = i2 * (1237 / 630 + s2 * (s2 * (-24832 / 14175) - 2.4)), i2 *= s2, this.cgb[4] = i2 * (4174 / 315 + s2 * (-144838 / 6237)), this.cbg[4] = i2 * (-734 / 315 + s2 * (109598 / 31185)), i2 *= s2, this.cgb[5] = i2 * (601676 / 22275), this.cbg[5] = i2 * (444337 / 155925), i2 = Math.pow(s2, 2), this.Qn = this.k0 / (1 + s2) * (1 + i2 * (1 / 4 + i2 * (1 / 64 + i2 / 256))), this.utg[0] = s2 * (s2 * (2 / 3 + s2 * (-37 / 96 + s2 * (1 / 360 + s2 * (81 / 512 + s2 * (-96199 / 604800))))) - 0.5), this.gtu[0] = s2 * (0.5 + s2 * (-2 / 3 + s2 * (5 / 16 + s2 * (41 / 180 + s2 * (-127 / 288 + s2 * (7891 / 37800)))))), this.utg[1] = i2 * (-1 / 48 + s2 * (-1 / 15 + s2 * (437 / 1440 + s2 * (-46 / 105 + s2 * (1118711 / 3870720))))), this.gtu[1] = i2 * (13 / 48 + s2 * (s2 * (557 / 1440 + s2 * (281 / 630 + s2 * (-1983433 / 1935360))) - 0.6)), i2 *= s2, this.utg[2] = i2 * (-17 / 480 + s2 * (37 / 840 + s2 * (209 / 4480 + s2 * (-5569 / 90720)))), this.gtu[2] = i2 * (61 / 240 + s2 * (-103 / 140 + s2 * (15061 / 26880 + s2 * (167603 / 181440)))), i2 *= s2, this.utg[3] = i2 * (-4397 / 161280 + s2 * (11 / 504 + s2 * (830251 / 7257600))), this.gtu[3] = i2 * (49561 / 161280 + s2 * (-179 / 168 + s2 * (6601661 / 7257600))), i2 *= s2, this.utg[4] = i2 * (-4583 / 161280 + s2 * (108847 / 3991680)), this.gtu[4] = i2 * (34729 / 80640 + s2 * (-3418889 / 1995840)), i2 *= s2, this.utg[5] = i2 * (-20648693 / 638668800), this.gtu[5] = 0.6650675310896665 * i2;
  var a2 = kt(this.cbg, this.lat0);
  this.Zb = -this.Qn * (a2 + function(t3, s3) {
    for (var i3, a3 = 2 * Math.cos(s3), h2 = t3.length - 1, e2 = t3[h2], n2 = 0; --h2 >= 0; )
      i3 = a3 * e2 - n2 + t3[h2], n2 = e2, e2 = i3;
    return Math.sin(s3) * i3;
  }(this.gtu, 2 * a2));
}, forward: function(t2) {
  var s2 = O(t2.x - this.long0), i2 = t2.y;
  i2 = kt(this.cbg, i2);
  var a2 = Math.sin(i2), h2 = Math.cos(i2), e2 = Math.sin(s2), n2 = Math.cos(s2);
  i2 = Math.atan2(a2, n2 * h2), s2 = Math.atan2(e2 * h2, Ct(a2, h2 * n2)), s2 = function(t3) {
    var s3 = Math.abs(t3);
    return s3 = function(t4) {
      var s4 = 1 + t4, i3 = s4 - 1;
      return 0 === i3 ? t4 : t4 * Math.log(s4) / i3;
    }(s3 * (1 + s3 / (Ct(1, s3) + 1))), t3 < 0 ? -s3 : s3;
  }(Math.tan(s2));
  var r2, o2, l2 = It(this.gtu, 2 * i2, 2 * s2);
  return i2 += l2[0], s2 += l2[1], Math.abs(s2) <= 2.623395162778 ? (r2 = this.a * (this.Qn * s2) + this.x0, o2 = this.a * (this.Qn * i2 + this.Zb) + this.y0) : (r2 = 1 / 0, o2 = 1 / 0), t2.x = r2, t2.y = o2, t2;
}, inverse: function(t2) {
  var s2, i2, a2 = (t2.x - this.x0) * (1 / this.a), h2 = (t2.y - this.y0) * (1 / this.a);
  if (h2 = (h2 - this.Zb) / this.Qn, a2 /= this.Qn, Math.abs(a2) <= 2.623395162778) {
    var e2 = It(this.utg, 2 * h2, 2 * a2);
    h2 += e2[0], a2 += e2[1], a2 = Math.atan(At(a2));
    var n2 = Math.sin(h2), r2 = Math.cos(h2), o2 = Math.sin(a2), l2 = Math.cos(a2);
    h2 = Math.atan2(n2 * l2, Ct(o2, l2 * r2)), s2 = O((a2 = Math.atan2(o2, l2 * r2)) + this.long0), i2 = kt(this.cgb, h2);
  } else
    s2 = 1 / 0, i2 = 1 / 0;
  return t2.x = s2, t2.y = i2, t2;
}, names: ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"] };
var Tt = { init: function() {
  var t2 = function(t3, s2) {
    if (void 0 === t3) {
      if ((t3 = Math.floor(30 * (O(s2) + Math.PI) / Math.PI) + 1) < 0)
        return 0;
      if (t3 > 60)
        return 60;
    }
    return t3;
  }(this.zone, this.long0);
  if (void 0 === t2)
    throw new Error("unknown utm zone");
  this.lat0 = 0, this.long0 = (6 * Math.abs(t2) - 183) * e, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = 0.9996, Ot.init.apply(this), this.forward = Ot.forward, this.inverse = Ot.inverse;
}, names: ["Universal Transverse Mercator System", "utm"], dependsOn: "etmerc" };
function Rt(t2, s2) {
  return Math.pow((1 - t2) / (1 + t2), s2);
}
var Gt = { init: function() {
  var t2 = Math.sin(this.lat0), s2 = Math.cos(this.lat0);
  s2 *= s2, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * t2 * t2), this.C = Math.sqrt(1 + this.es * s2 * s2 / (1 - this.es)), this.phic0 = Math.asin(t2 / this.C), this.ratexp = 0.5 * this.C * this.e, this.K = Math.tan(0.5 * this.phic0 + r) / (Math.pow(Math.tan(0.5 * this.lat0 + r), this.C) * Rt(this.e * t2, this.ratexp));
}, forward: function(t2) {
  var s2 = t2.x, i2 = t2.y;
  return t2.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * i2 + r), this.C) * Rt(this.e * Math.sin(i2), this.ratexp)) - h, t2.x = this.C * s2, t2;
}, inverse: function(t2) {
  for (var s2 = t2.x / this.C, i2 = t2.y, a2 = Math.pow(Math.tan(0.5 * i2 + r) / this.K, 1 / this.C), e2 = 20; e2 > 0 && (i2 = 2 * Math.atan(a2 * Rt(this.e * Math.sin(t2.y), -0.5 * this.e)) - h, !(Math.abs(i2 - t2.y) < 1e-14)); --e2)
    t2.y = i2;
  return e2 ? (t2.x = s2, t2.y = i2, t2) : null;
}, names: ["gauss"] };
var qt = { init: function() {
  Gt.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
}, forward: function(t2) {
  var s2, i2, a2, h2;
  return t2.x = O(t2.x - this.long0), Gt.forward.apply(this, [t2]), s2 = Math.sin(t2.y), i2 = Math.cos(t2.y), a2 = Math.cos(t2.x), h2 = this.k0 * this.R2 / (1 + this.sinc0 * s2 + this.cosc0 * i2 * a2), t2.x = h2 * i2 * Math.sin(t2.x), t2.y = h2 * (this.cosc0 * s2 - this.sinc0 * i2 * a2), t2.x = this.a * t2.x + this.x0, t2.y = this.a * t2.y + this.y0, t2;
}, inverse: function(t2) {
  var s2, i2, a2, h2, e2;
  if (t2.x = (t2.x - this.x0) / this.a, t2.y = (t2.y - this.y0) / this.a, t2.x /= this.k0, t2.y /= this.k0, e2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y)) {
    var n2 = 2 * Math.atan2(e2, this.R2);
    s2 = Math.sin(n2), i2 = Math.cos(n2), h2 = Math.asin(i2 * this.sinc0 + t2.y * s2 * this.cosc0 / e2), a2 = Math.atan2(t2.x * s2, e2 * this.cosc0 * i2 - t2.y * this.sinc0 * s2);
  } else
    h2 = this.phic0, a2 = 0;
  return t2.x = a2, t2.y = h2, Gt.inverse.apply(this, [t2]), t2.x = O(t2.x + this.long0), t2;
}, names: ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"] };
var jt = { init: function() {
  this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? 1 === this.k0 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= 1e-10 && (this.k0 = 0.5 * (1 + I(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= 1e-10 && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), 1 === this.k0 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= 1e-10 && (this.k0 = 0.5 * this.cons * k(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / T(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = k(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - h, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
}, forward: function(t2) {
  var s2, i2, a2, e2, n2, r2, o2 = t2.x, l2 = t2.y, c2 = Math.sin(l2), u2 = Math.cos(l2), M2 = O(o2 - this.long0);
  return Math.abs(Math.abs(o2 - this.long0) - Math.PI) <= 1e-10 && Math.abs(l2 + this.lat0) <= 1e-10 ? (t2.x = NaN, t2.y = NaN, t2) : this.sphere ? (s2 = 2 * this.k0 / (1 + this.sinlat0 * c2 + this.coslat0 * u2 * Math.cos(M2)), t2.x = this.a * s2 * u2 * Math.sin(M2) + this.x0, t2.y = this.a * s2 * (this.coslat0 * c2 - this.sinlat0 * u2 * Math.cos(M2)) + this.y0, t2) : (i2 = 2 * Math.atan(this.ssfn_(l2, c2, this.e)) - h, e2 = Math.cos(i2), a2 = Math.sin(i2), Math.abs(this.coslat0) <= 1e-10 ? (n2 = T(this.e, l2 * this.con, this.con * c2), r2 = 2 * this.a * this.k0 * n2 / this.cons, t2.x = this.x0 + r2 * Math.sin(o2 - this.long0), t2.y = this.y0 - this.con * r2 * Math.cos(o2 - this.long0), t2) : (Math.abs(this.sinlat0) < 1e-10 ? (s2 = 2 * this.a * this.k0 / (1 + e2 * Math.cos(M2)), t2.y = s2 * a2) : (s2 = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * a2 + this.cosX0 * e2 * Math.cos(M2))), t2.y = s2 * (this.cosX0 * a2 - this.sinX0 * e2 * Math.cos(M2)) + this.y0), t2.x = s2 * e2 * Math.sin(M2) + this.x0, t2));
}, inverse: function(t2) {
  var s2, i2, a2, e2, n2;
  t2.x -= this.x0, t2.y -= this.y0;
  var r2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y);
  if (this.sphere) {
    var o2 = 2 * Math.atan(r2 / (2 * this.a * this.k0));
    return s2 = this.long0, i2 = this.lat0, r2 <= 1e-10 ? (t2.x = s2, t2.y = i2, t2) : (i2 = Math.asin(Math.cos(o2) * this.sinlat0 + t2.y * Math.sin(o2) * this.coslat0 / r2), s2 = Math.abs(this.coslat0) < 1e-10 ? this.lat0 > 0 ? O(this.long0 + Math.atan2(t2.x, -1 * t2.y)) : O(this.long0 + Math.atan2(t2.x, t2.y)) : O(this.long0 + Math.atan2(t2.x * Math.sin(o2), r2 * this.coslat0 * Math.cos(o2) - t2.y * this.sinlat0 * Math.sin(o2))), t2.x = s2, t2.y = i2, t2);
  }
  if (Math.abs(this.coslat0) <= 1e-10) {
    if (r2 <= 1e-10)
      return i2 = this.lat0, s2 = this.long0, t2.x = s2, t2.y = i2, t2;
    t2.x *= this.con, t2.y *= this.con, a2 = r2 * this.cons / (2 * this.a * this.k0), i2 = this.con * R(this.e, a2), s2 = this.con * O(this.con * this.long0 + Math.atan2(t2.x, -1 * t2.y));
  } else
    e2 = 2 * Math.atan(r2 * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), s2 = this.long0, r2 <= 1e-10 ? n2 = this.X0 : (n2 = Math.asin(Math.cos(e2) * this.sinX0 + t2.y * Math.sin(e2) * this.cosX0 / r2), s2 = O(this.long0 + Math.atan2(t2.x * Math.sin(e2), r2 * this.cosX0 * Math.cos(e2) - t2.y * this.sinX0 * Math.sin(e2)))), i2 = -1 * R(this.e, Math.tan(0.5 * (h + n2)));
  return t2.x = s2, t2.y = i2, t2;
}, names: ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"], ssfn_: function(t2, s2, i2) {
  return s2 *= i2, Math.tan(0.5 * (h + t2)) * Math.pow((1 - s2) / (1 + s2), 0.5 * i2);
} };
var Ut = { init: function() {
  var t2 = this.lat0;
  this.lambda0 = this.long0;
  var s2 = Math.sin(t2), i2 = this.a, a2 = 1 / this.rf, h2 = 2 * a2 - Math.pow(a2, 2), e2 = this.e = Math.sqrt(h2);
  this.R = this.k0 * i2 * Math.sqrt(1 - h2) / (1 - h2 * Math.pow(s2, 2)), this.alpha = Math.sqrt(1 + h2 / (1 - h2) * Math.pow(Math.cos(t2), 4)), this.b0 = Math.asin(s2 / this.alpha);
  var n2 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), r2 = Math.log(Math.tan(Math.PI / 4 + t2 / 2)), o2 = Math.log((1 + e2 * s2) / (1 - e2 * s2));
  this.K = n2 - this.alpha * r2 + this.alpha * e2 / 2 * o2;
}, forward: function(t2) {
  var s2 = Math.log(Math.tan(Math.PI / 4 - t2.y / 2)), i2 = this.e / 2 * Math.log((1 + this.e * Math.sin(t2.y)) / (1 - this.e * Math.sin(t2.y))), a2 = -this.alpha * (s2 + i2) + this.K, h2 = 2 * (Math.atan(Math.exp(a2)) - Math.PI / 4), e2 = this.alpha * (t2.x - this.lambda0), n2 = Math.atan(Math.sin(e2) / (Math.sin(this.b0) * Math.tan(h2) + Math.cos(this.b0) * Math.cos(e2))), r2 = Math.asin(Math.cos(this.b0) * Math.sin(h2) - Math.sin(this.b0) * Math.cos(h2) * Math.cos(e2));
  return t2.y = this.R / 2 * Math.log((1 + Math.sin(r2)) / (1 - Math.sin(r2))) + this.y0, t2.x = this.R * n2 + this.x0, t2;
}, inverse: function(t2) {
  for (var s2 = t2.x - this.x0, i2 = t2.y - this.y0, a2 = s2 / this.R, h2 = 2 * (Math.atan(Math.exp(i2 / this.R)) - Math.PI / 4), e2 = Math.asin(Math.cos(this.b0) * Math.sin(h2) + Math.sin(this.b0) * Math.cos(h2) * Math.cos(a2)), n2 = Math.atan(Math.sin(a2) / (Math.cos(this.b0) * Math.cos(a2) - Math.sin(this.b0) * Math.tan(h2))), r2 = this.lambda0 + n2 / this.alpha, o2 = 0, l2 = e2, c2 = -1e3, u2 = 0; Math.abs(l2 - c2) > 1e-7; ) {
    if (++u2 > 20)
      return;
    o2 = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + e2 / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(l2)) / 2)), c2 = l2, l2 = 2 * Math.atan(Math.exp(o2)) - Math.PI / 2;
  }
  return t2.x = r2, t2.y = l2, t2;
}, names: ["somerc"] };
var Lt = { init: function() {
  var t2, s2, i2, a2, n2, l2, c2, u2, M2, d2, f2, p2, m2, y2 = 0, _2 = 0, g2 = 0, x2 = 0, v2 = 0, b2 = 0, w2 = 0;
  this.no_off = (m2 = "object" == typeof (p2 = this).PROJECTION ? Object.keys(p2.PROJECTION)[0] : p2.PROJECTION, "no_uoff" in p2 || "no_off" in p2 || -1 !== ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"].indexOf(m2)), this.no_rot = "no_rot" in this;
  var S2 = false;
  "alpha" in this && (S2 = true);
  var P2 = false;
  if ("rectified_grid_angle" in this && (P2 = true), S2 && (w2 = this.alpha), P2 && (y2 = this.rectified_grid_angle * e), S2 || P2)
    _2 = this.longc;
  else if (g2 = this.long1, v2 = this.lat1, x2 = this.long2, b2 = this.lat2, Math.abs(v2 - b2) <= 1e-7 || (t2 = Math.abs(v2)) <= 1e-7 || Math.abs(t2 - h) <= 1e-7 || Math.abs(Math.abs(this.lat0) - h) <= 1e-7 || Math.abs(Math.abs(b2) - h) <= 1e-7)
    throw new Error();
  var N2 = 1 - this.es;
  s2 = Math.sqrt(N2), Math.abs(this.lat0) > 1e-10 ? (u2 = Math.sin(this.lat0), i2 = Math.cos(this.lat0), t2 = 1 - this.es * u2 * u2, this.B = i2 * i2, this.B = Math.sqrt(1 + this.es * this.B * this.B / N2), this.A = this.B * this.k0 * s2 / t2, (n2 = (a2 = this.B * s2 / (i2 * Math.sqrt(t2))) * a2 - 1) <= 0 ? n2 = 0 : (n2 = Math.sqrt(n2), this.lat0 < 0 && (n2 = -n2)), this.E = n2 += a2, this.E *= Math.pow(T(this.e, this.lat0, u2), this.B)) : (this.B = 1 / s2, this.A = this.k0, this.E = a2 = n2 = 1), S2 || P2 ? (S2 ? (f2 = Math.asin(Math.sin(w2) / a2), P2 || (y2 = w2)) : (f2 = y2, w2 = Math.asin(a2 * Math.sin(f2))), this.lam0 = _2 - Math.asin(0.5 * (n2 - 1 / n2) * Math.tan(f2)) / this.B) : (l2 = Math.pow(T(this.e, v2, Math.sin(v2)), this.B), c2 = Math.pow(T(this.e, b2, Math.sin(b2)), this.B), n2 = this.E / l2, M2 = (c2 - l2) / (c2 + l2), d2 = ((d2 = this.E * this.E) - c2 * l2) / (d2 + c2 * l2), (t2 = g2 - x2) < -Math.pi ? x2 -= o : t2 > Math.pi && (x2 += o), this.lam0 = O(0.5 * (g2 + x2) - Math.atan(d2 * Math.tan(0.5 * this.B * (g2 - x2)) / M2) / this.B), f2 = Math.atan(2 * Math.sin(this.B * O(g2 - this.lam0)) / (n2 - 1 / n2)), y2 = w2 = Math.asin(a2 * Math.sin(f2))), this.singam = Math.sin(f2), this.cosgam = Math.cos(f2), this.sinrot = Math.sin(y2), this.cosrot = Math.cos(y2), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.A, this.B, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(a2 * a2 - 1) / Math.cos(w2))), this.lat0 < 0 && (this.u_0 = -this.u_0)), n2 = 0.5 * f2, this.v_pole_n = this.ArB * Math.log(Math.tan(r - n2)), this.v_pole_s = this.ArB * Math.log(Math.tan(r + n2));
}, forward: function(t2) {
  var s2, i2, a2, e2, n2, r2, o2, l2, c2 = {};
  if (t2.x = t2.x - this.lam0, Math.abs(Math.abs(t2.y) - h) > 1e-10) {
    if (s2 = 0.5 * ((n2 = this.E / Math.pow(T(this.e, t2.y, Math.sin(t2.y)), this.B)) - (r2 = 1 / n2)), i2 = 0.5 * (n2 + r2), e2 = Math.sin(this.B * t2.x), a2 = (s2 * this.singam - e2 * this.cosgam) / i2, Math.abs(Math.abs(a2) - 1) < 1e-10)
      throw new Error();
    l2 = 0.5 * this.ArB * Math.log((1 - a2) / (1 + a2)), r2 = Math.cos(this.B * t2.x), o2 = Math.abs(r2) < 1e-7 ? this.A * t2.x : this.ArB * Math.atan2(s2 * this.cosgam + e2 * this.singam, r2);
  } else
    l2 = t2.y > 0 ? this.v_pole_n : this.v_pole_s, o2 = this.ArB * t2.y;
  return this.no_rot ? (c2.x = o2, c2.y = l2) : (o2 -= this.u_0, c2.x = l2 * this.cosrot + o2 * this.sinrot, c2.y = o2 * this.cosrot - l2 * this.sinrot), c2.x = this.a * c2.x + this.x0, c2.y = this.a * c2.y + this.y0, c2;
}, inverse: function(t2) {
  var s2, i2, a2, e2, n2, r2, o2, l2 = {};
  if (t2.x = (t2.x - this.x0) * (1 / this.a), t2.y = (t2.y - this.y0) * (1 / this.a), this.no_rot ? (i2 = t2.y, s2 = t2.x) : (i2 = t2.x * this.cosrot - t2.y * this.sinrot, s2 = t2.y * this.cosrot + t2.x * this.sinrot + this.u_0), e2 = 0.5 * ((a2 = Math.exp(-this.BrA * i2)) - 1 / a2), n2 = 0.5 * (a2 + 1 / a2), o2 = ((r2 = Math.sin(this.BrA * s2)) * this.cosgam + e2 * this.singam) / n2, Math.abs(Math.abs(o2) - 1) < 1e-10)
    l2.x = 0, l2.y = o2 < 0 ? -h : h;
  else {
    if (l2.y = this.E / Math.sqrt((1 + o2) / (1 - o2)), l2.y = R(this.e, Math.pow(l2.y, 1 / this.B)), l2.y === 1 / 0)
      throw new Error();
    l2.x = -this.rB * Math.atan2(e2 * this.cosgam - r2 * this.singam, Math.cos(this.BrA * s2));
  }
  return l2.x += this.lam0, l2;
}, names: ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"] };
var zt = { init: function() {
  if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < 1e-10)) {
    var t2 = this.b / this.a;
    this.e = Math.sqrt(1 - t2 * t2);
    var s2 = Math.sin(this.lat1), i2 = Math.cos(this.lat1), a2 = k(this.e, s2, i2), h2 = T(this.e, this.lat1, s2), e2 = Math.sin(this.lat2), n2 = Math.cos(this.lat2), r2 = k(this.e, e2, n2), o2 = T(this.e, this.lat2, e2), l2 = T(this.e, this.lat0, Math.sin(this.lat0));
    Math.abs(this.lat1 - this.lat2) > 1e-10 ? this.ns = Math.log(a2 / r2) / Math.log(h2 / o2) : this.ns = s2, isNaN(this.ns) && (this.ns = s2), this.f0 = a2 / (this.ns * Math.pow(h2, this.ns)), this.rh = this.a * this.f0 * Math.pow(l2, this.ns), this.title || (this.title = "Lambert Conformal Conic");
  }
}, forward: function(t2) {
  var s2 = t2.x, i2 = t2.y;
  Math.abs(2 * Math.abs(i2) - Math.PI) <= 1e-10 && (i2 = I(i2) * (h - 2e-10));
  var a2, e2, n2 = Math.abs(Math.abs(i2) - h);
  if (n2 > 1e-10)
    a2 = T(this.e, i2, Math.sin(i2)), e2 = this.a * this.f0 * Math.pow(a2, this.ns);
  else {
    if ((n2 = i2 * this.ns) <= 0)
      return null;
    e2 = 0;
  }
  var r2 = this.ns * O(s2 - this.long0);
  return t2.x = this.k0 * (e2 * Math.sin(r2)) + this.x0, t2.y = this.k0 * (this.rh - e2 * Math.cos(r2)) + this.y0, t2;
}, inverse: function(t2) {
  var s2, i2, a2, e2, n2, r2 = (t2.x - this.x0) / this.k0, o2 = this.rh - (t2.y - this.y0) / this.k0;
  this.ns > 0 ? (s2 = Math.sqrt(r2 * r2 + o2 * o2), i2 = 1) : (s2 = -Math.sqrt(r2 * r2 + o2 * o2), i2 = -1);
  var l2 = 0;
  if (0 !== s2 && (l2 = Math.atan2(i2 * r2, i2 * o2)), 0 !== s2 || this.ns > 0) {
    if (i2 = 1 / this.ns, a2 = Math.pow(s2 / (this.a * this.f0), i2), -9999 === (e2 = R(this.e, a2)))
      return null;
  } else
    e2 = -h;
  return n2 = O(l2 / this.ns + this.long0), t2.x = n2, t2.y = e2, t2;
}, names: ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_1SP", "Lambert_Conformal_Conic_2SP", "lcc", "Lambert Conic Conformal (1SP)", "Lambert Conic Conformal (2SP)"] };
var Bt = { init: function() {
  this.a = 6377397155e-3, this.es = 0.006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = 0.863937979737193), this.long0 || (this.long0 = 0.4334234309119251), this.k0 || (this.k0 = 0.9999), this.s45 = 0.785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq;
}, forward: function(t2) {
  var s2, i2, a2, h2, e2, n2, r2, o2 = t2.x, l2 = t2.y, c2 = O(o2 - this.long0);
  return s2 = Math.pow((1 + this.e * Math.sin(l2)) / (1 - this.e * Math.sin(l2)), this.alfa * this.e / 2), i2 = 2 * (Math.atan(this.k * Math.pow(Math.tan(l2 / 2 + this.s45), this.alfa) / s2) - this.s45), a2 = -c2 * this.alfa, h2 = Math.asin(Math.cos(this.ad) * Math.sin(i2) + Math.sin(this.ad) * Math.cos(i2) * Math.cos(a2)), e2 = Math.asin(Math.cos(i2) * Math.sin(a2) / Math.cos(h2)), n2 = this.n * e2, r2 = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(h2 / 2 + this.s45), this.n), t2.y = r2 * Math.cos(n2) / 1, t2.x = r2 * Math.sin(n2) / 1, this.czech || (t2.y *= -1, t2.x *= -1), t2;
}, inverse: function(t2) {
  var s2, i2, a2, h2, e2, n2, r2, o2 = t2.x;
  t2.x = t2.y, t2.y = o2, this.czech || (t2.y *= -1, t2.x *= -1), e2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y), h2 = Math.atan2(t2.y, t2.x) / Math.sin(this.s0), a2 = 2 * (Math.atan(Math.pow(this.ro0 / e2, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), s2 = Math.asin(Math.cos(this.ad) * Math.sin(a2) - Math.sin(this.ad) * Math.cos(a2) * Math.cos(h2)), i2 = Math.asin(Math.cos(a2) * Math.sin(h2) / Math.cos(s2)), t2.x = this.long0 - i2 / this.alfa, n2 = s2, r2 = 0;
  var l2 = 0;
  do {
    t2.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(s2 / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(n2)) / (1 - this.e * Math.sin(n2)), this.e / 2)) - this.s45), Math.abs(n2 - t2.y) < 1e-10 && (r2 = 1), n2 = t2.y, l2 += 1;
  } while (0 === r2 && l2 < 15);
  return l2 >= 15 ? null : t2;
}, names: ["Krovak", "krovak"] };
function Dt(t2, s2, i2, a2, h2) {
  return t2 * h2 - s2 * Math.sin(2 * h2) + i2 * Math.sin(4 * h2) - a2 * Math.sin(6 * h2);
}
function Ft(t2) {
  return 1 - 0.25 * t2 * (1 + t2 / 16 * (3 + 1.25 * t2));
}
function $t(t2) {
  return 0.375 * t2 * (1 + 0.25 * t2 * (1 + 0.46875 * t2));
}
function Ht(t2) {
  return 0.05859375 * t2 * t2 * (1 + 0.75 * t2);
}
function Wt(t2) {
  return t2 * t2 * t2 * (35 / 3072);
}
function Qt(t2, s2, i2) {
  var a2 = s2 * i2;
  return t2 / Math.sqrt(1 - a2 * a2);
}
function Jt(t2) {
  return Math.abs(t2) < h ? t2 : t2 - I(t2) * Math.PI;
}
function Xt(t2, s2, i2, a2, h2) {
  var e2, n2;
  e2 = t2 / s2;
  for (var r2 = 0; r2 < 15; r2++)
    if (e2 += n2 = (t2 - (s2 * e2 - i2 * Math.sin(2 * e2) + a2 * Math.sin(4 * e2) - h2 * Math.sin(6 * e2))) / (s2 - 2 * i2 * Math.cos(2 * e2) + 4 * a2 * Math.cos(4 * e2) - 6 * h2 * Math.cos(6 * e2)), Math.abs(n2) <= 1e-10)
      return e2;
  return NaN;
}
var Yt = { init: function() {
  this.sphere || (this.e0 = Ft(this.es), this.e1 = $t(this.es), this.e2 = Ht(this.es), this.e3 = Wt(this.es), this.ml0 = this.a * Dt(this.e0, this.e1, this.e2, this.e3, this.lat0));
}, forward: function(t2) {
  var s2, i2, a2 = t2.x, h2 = t2.y;
  if (a2 = O(a2 - this.long0), this.sphere)
    s2 = this.a * Math.asin(Math.cos(h2) * Math.sin(a2)), i2 = this.a * (Math.atan2(Math.tan(h2), Math.cos(a2)) - this.lat0);
  else {
    var e2 = Math.sin(h2), n2 = Math.cos(h2), r2 = Qt(this.a, this.e, e2), o2 = Math.tan(h2) * Math.tan(h2), l2 = a2 * Math.cos(h2), c2 = l2 * l2, u2 = this.es * n2 * n2 / (1 - this.es);
    s2 = r2 * l2 * (1 - c2 * o2 * (1 / 6 - (8 - o2 + 8 * u2) * c2 / 120)), i2 = this.a * Dt(this.e0, this.e1, this.e2, this.e3, h2) - this.ml0 + r2 * e2 / n2 * c2 * (0.5 + (5 - o2 + 6 * u2) * c2 / 24);
  }
  return t2.x = s2 + this.x0, t2.y = i2 + this.y0, t2;
}, inverse: function(t2) {
  t2.x -= this.x0, t2.y -= this.y0;
  var s2, i2, a2 = t2.x / this.a, e2 = t2.y / this.a;
  if (this.sphere) {
    var n2 = e2 + this.lat0;
    s2 = Math.asin(Math.sin(n2) * Math.cos(a2)), i2 = Math.atan2(Math.tan(a2), Math.cos(n2));
  } else {
    var r2 = Xt(this.ml0 / this.a + e2, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(r2) - h) <= 1e-10)
      return t2.x = this.long0, t2.y = h, e2 < 0 && (t2.y *= -1), t2;
    var o2 = Qt(this.a, this.e, Math.sin(r2)), l2 = o2 * o2 * o2 / this.a / this.a * (1 - this.es), c2 = Math.pow(Math.tan(r2), 2), u2 = a2 * this.a / o2, M2 = u2 * u2;
    s2 = r2 - o2 * Math.tan(r2) / l2 * u2 * u2 * (0.5 - (1 + 3 * c2) * u2 * u2 / 24), i2 = u2 * (1 - M2 * (c2 / 3 + (1 + 3 * c2) * c2 * M2 / 15)) / Math.cos(r2);
  }
  return t2.x = O(i2 + this.long0), t2.y = Jt(s2), t2;
}, names: ["Cassini", "Cassini_Soldner", "cass"] };
function Kt(t2, s2) {
  var i2;
  return t2 > 1e-7 ? (1 - t2 * t2) * (s2 / (1 - (i2 = t2 * s2) * i2) - 0.5 / t2 * Math.log((1 - i2) / (1 + i2))) : 2 * s2;
}
var Vt = { init: function() {
  var t2, s2 = Math.abs(this.lat0);
  if (Math.abs(s2 - h) < 1e-10 ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(s2) < 1e-10 ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0)
    switch (this.qp = Kt(this.e, 1), this.mmf = 0.5 / (1 - this.es), this.apa = function(t3) {
      var s3, i2 = [];
      return i2[0] = 0.3333333333333333 * t3, s3 = t3 * t3, i2[0] += 0.17222222222222222 * s3, i2[1] = 0.06388888888888888 * s3, s3 *= t3, i2[0] += 0.10257936507936508 * s3, i2[1] += 0.0664021164021164 * s3, i2[2] = 0.016415012942191543 * s3, i2;
    }(this.es), this.mode) {
      case this.N_POLE:
      case this.S_POLE:
        this.dd = 1;
        break;
      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = 0.5 * this.qp;
        break;
      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp), t2 = Math.sin(this.lat0), this.sinb1 = Kt(this.e, t2) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * t2 * t2) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
    }
  else
    this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0));
}, forward: function(t2) {
  var s2, i2, a2, e2, n2, o2, l2, c2, u2, M2, d2 = t2.x, f2 = t2.y;
  if (d2 = O(d2 - this.long0), this.sphere) {
    if (n2 = Math.sin(f2), M2 = Math.cos(f2), a2 = Math.cos(d2), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if ((i2 = this.mode === this.EQUIT ? 1 + M2 * a2 : 1 + this.sinph0 * n2 + this.cosph0 * M2 * a2) <= 1e-10)
        return null;
      s2 = (i2 = Math.sqrt(2 / i2)) * M2 * Math.sin(d2), i2 *= this.mode === this.EQUIT ? n2 : this.cosph0 * n2 - this.sinph0 * M2 * a2;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (a2 = -a2), Math.abs(f2 + this.lat0) < 1e-10)
        return null;
      i2 = r - 0.5 * f2, s2 = (i2 = 2 * (this.mode === this.S_POLE ? Math.cos(i2) : Math.sin(i2))) * Math.sin(d2), i2 *= a2;
    }
  } else {
    switch (l2 = 0, c2 = 0, u2 = 0, a2 = Math.cos(d2), e2 = Math.sin(d2), n2 = Math.sin(f2), o2 = Kt(this.e, n2), this.mode !== this.OBLIQ && this.mode !== this.EQUIT || (l2 = o2 / this.qp, c2 = Math.sqrt(1 - l2 * l2)), this.mode) {
      case this.OBLIQ:
        u2 = 1 + this.sinb1 * l2 + this.cosb1 * c2 * a2;
        break;
      case this.EQUIT:
        u2 = 1 + c2 * a2;
        break;
      case this.N_POLE:
        u2 = h + f2, o2 = this.qp - o2;
        break;
      case this.S_POLE:
        u2 = f2 - h, o2 = this.qp + o2;
    }
    if (Math.abs(u2) < 1e-10)
      return null;
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        u2 = Math.sqrt(2 / u2), i2 = this.mode === this.OBLIQ ? this.ymf * u2 * (this.cosb1 * l2 - this.sinb1 * c2 * a2) : (u2 = Math.sqrt(2 / (1 + c2 * a2))) * l2 * this.ymf, s2 = this.xmf * u2 * c2 * e2;
        break;
      case this.N_POLE:
      case this.S_POLE:
        o2 >= 0 ? (s2 = (u2 = Math.sqrt(o2)) * e2, i2 = a2 * (this.mode === this.S_POLE ? u2 : -u2)) : s2 = i2 = 0;
    }
  }
  return t2.x = this.a * s2 + this.x0, t2.y = this.a * i2 + this.y0, t2;
}, inverse: function(t2) {
  t2.x -= this.x0, t2.y -= this.y0;
  var s2, i2, a2, e2, n2, r2, o2, l2, c2, u2, M2 = t2.x / this.a, d2 = t2.y / this.a;
  if (this.sphere) {
    var f2, p2 = 0, m2 = 0;
    if ((i2 = 0.5 * (f2 = Math.sqrt(M2 * M2 + d2 * d2))) > 1)
      return null;
    switch (i2 = 2 * Math.asin(i2), this.mode !== this.OBLIQ && this.mode !== this.EQUIT || (m2 = Math.sin(i2), p2 = Math.cos(i2)), this.mode) {
      case this.EQUIT:
        i2 = Math.abs(f2) <= 1e-10 ? 0 : Math.asin(d2 * m2 / f2), M2 *= m2, d2 = p2 * f2;
        break;
      case this.OBLIQ:
        i2 = Math.abs(f2) <= 1e-10 ? this.lat0 : Math.asin(p2 * this.sinph0 + d2 * m2 * this.cosph0 / f2), M2 *= m2 * this.cosph0, d2 = (p2 - Math.sin(i2) * this.sinph0) * f2;
        break;
      case this.N_POLE:
        d2 = -d2, i2 = h - i2;
        break;
      case this.S_POLE:
        i2 -= h;
    }
    s2 = 0 !== d2 || this.mode !== this.EQUIT && this.mode !== this.OBLIQ ? Math.atan2(M2, d2) : 0;
  } else {
    if (o2 = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (M2 /= this.dd, d2 *= this.dd, (r2 = Math.sqrt(M2 * M2 + d2 * d2)) < 1e-10)
        return t2.x = this.long0, t2.y = this.lat0, t2;
      e2 = 2 * Math.asin(0.5 * r2 / this.rq), a2 = Math.cos(e2), M2 *= e2 = Math.sin(e2), this.mode === this.OBLIQ ? (o2 = a2 * this.sinb1 + d2 * e2 * this.cosb1 / r2, n2 = this.qp * o2, d2 = r2 * this.cosb1 * a2 - d2 * this.sinb1 * e2) : (o2 = d2 * e2 / r2, n2 = this.qp * o2, d2 = r2 * a2);
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (d2 = -d2), !(n2 = M2 * M2 + d2 * d2))
        return t2.x = this.long0, t2.y = this.lat0, t2;
      o2 = 1 - n2 / this.qp, this.mode === this.S_POLE && (o2 = -o2);
    }
    s2 = Math.atan2(M2, d2), u2 = (l2 = Math.asin(o2)) + l2, i2 = l2 + (c2 = this.apa)[0] * Math.sin(u2) + c2[1] * Math.sin(u2 + u2) + c2[2] * Math.sin(u2 + u2 + u2);
  }
  return t2.x = O(this.long0 + s2), t2.y = i2, t2;
}, names: ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"], S_POLE: 1, N_POLE: 2, EQUIT: 3, OBLIQ: 4 };
function Zt(t2) {
  return Math.abs(t2) > 1 && (t2 = t2 > 1 ? 1 : -1), Math.asin(t2);
}
var ts = { init: function() {
  Math.abs(this.lat1 + this.lat2) < 1e-10 || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = k(this.e3, this.sin_po, this.cos_po), this.qs1 = Kt(this.e3, this.sin_po, this.cos_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = k(this.e3, this.sin_po, this.cos_po), this.qs2 = Kt(this.e3, this.sin_po, this.cos_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = Kt(this.e3, this.sin_po, this.cos_po), Math.abs(this.lat1 - this.lat2) > 1e-10 ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
}, forward: function(t2) {
  var s2 = t2.x, i2 = t2.y;
  this.sin_phi = Math.sin(i2), this.cos_phi = Math.cos(i2);
  var a2 = Kt(this.e3, this.sin_phi, this.cos_phi), h2 = this.a * Math.sqrt(this.c - this.ns0 * a2) / this.ns0, e2 = this.ns0 * O(s2 - this.long0), n2 = h2 * Math.sin(e2) + this.x0, r2 = this.rh - h2 * Math.cos(e2) + this.y0;
  return t2.x = n2, t2.y = r2, t2;
}, inverse: function(t2) {
  var s2, i2, a2, h2, e2, n2;
  return t2.x -= this.x0, t2.y = this.rh - t2.y + this.y0, this.ns0 >= 0 ? (s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y), a2 = 1) : (s2 = -Math.sqrt(t2.x * t2.x + t2.y * t2.y), a2 = -1), h2 = 0, 0 !== s2 && (h2 = Math.atan2(a2 * t2.x, a2 * t2.y)), a2 = s2 * this.ns0 / this.a, this.sphere ? n2 = Math.asin((this.c - a2 * a2) / (2 * this.ns0)) : (i2 = (this.c - a2 * a2) / this.ns0, n2 = this.phi1z(this.e3, i2)), e2 = O(h2 / this.ns0 + this.long0), t2.x = e2, t2.y = n2, t2;
}, names: ["Albers_Conic_Equal_Area", "Albers", "aea"], phi1z: function(t2, s2) {
  var i2, a2, h2, e2, n2 = Zt(0.5 * s2);
  if (t2 < 1e-10)
    return n2;
  for (var r2 = t2 * t2, o2 = 1; o2 <= 25; o2++)
    if (n2 += e2 = 0.5 * (h2 = 1 - (a2 = t2 * (i2 = Math.sin(n2))) * a2) * h2 / Math.cos(n2) * (s2 / (1 - r2) - i2 / h2 + 0.5 / t2 * Math.log((1 - a2) / (1 + a2))), Math.abs(e2) <= 1e-7)
      return n2;
  return null;
} };
var ss = { init: function() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1;
}, forward: function(t2) {
  var s2, i2, a2, h2, e2, n2, r2, o2 = t2.x, l2 = t2.y;
  return a2 = O(o2 - this.long0), s2 = Math.sin(l2), i2 = Math.cos(l2), h2 = Math.cos(a2), (e2 = this.sin_p14 * s2 + this.cos_p14 * i2 * h2) > 0 || Math.abs(e2) <= 1e-10 ? (n2 = this.x0 + 1 * this.a * i2 * Math.sin(a2) / e2, r2 = this.y0 + 1 * this.a * (this.cos_p14 * s2 - this.sin_p14 * i2 * h2) / e2) : (n2 = this.x0 + this.infinity_dist * i2 * Math.sin(a2), r2 = this.y0 + this.infinity_dist * (this.cos_p14 * s2 - this.sin_p14 * i2 * h2)), t2.x = n2, t2.y = r2, t2;
}, inverse: function(t2) {
  var s2, i2, a2, h2, e2, n2;
  return t2.x = (t2.x - this.x0) / this.a, t2.y = (t2.y - this.y0) / this.a, t2.x /= this.k0, t2.y /= this.k0, (s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y)) ? (h2 = Math.atan2(s2, this.rc), i2 = Math.sin(h2), n2 = Zt((a2 = Math.cos(h2)) * this.sin_p14 + t2.y * i2 * this.cos_p14 / s2), e2 = Math.atan2(t2.x * i2, s2 * this.cos_p14 * a2 - t2.y * this.sin_p14 * i2), e2 = O(this.long0 + e2)) : (n2 = this.phic0, e2 = 0), t2.x = e2, t2.y = n2, t2;
}, names: ["gnom"] };
var is = { init: function() {
  this.sphere || (this.k0 = k(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
}, forward: function(t2) {
  var s2, i2, a2 = t2.x, h2 = t2.y, e2 = O(a2 - this.long0);
  if (this.sphere)
    s2 = this.x0 + this.a * e2 * Math.cos(this.lat_ts), i2 = this.y0 + this.a * Math.sin(h2) / Math.cos(this.lat_ts);
  else {
    var n2 = Kt(this.e, Math.sin(h2));
    s2 = this.x0 + this.a * this.k0 * e2, i2 = this.y0 + this.a * n2 * 0.5 / this.k0;
  }
  return t2.x = s2, t2.y = i2, t2;
}, inverse: function(t2) {
  var s2, i2;
  return t2.x -= this.x0, t2.y -= this.y0, this.sphere ? (s2 = O(this.long0 + t2.x / this.a / Math.cos(this.lat_ts)), i2 = Math.asin(t2.y / this.a * Math.cos(this.lat_ts))) : (i2 = function(t3, s3) {
    var i3 = 1 - (1 - t3 * t3) / (2 * t3) * Math.log((1 - t3) / (1 + t3));
    if (Math.abs(Math.abs(s3) - i3) < 1e-6)
      return s3 < 0 ? -1 * h : h;
    for (var a2, e2, n2, r2, o2 = Math.asin(0.5 * s3), l2 = 0; l2 < 30; l2++)
      if (e2 = Math.sin(o2), n2 = Math.cos(o2), r2 = t3 * e2, o2 += a2 = Math.pow(1 - r2 * r2, 2) / (2 * n2) * (s3 / (1 - t3 * t3) - e2 / (1 - r2 * r2) + 0.5 / t3 * Math.log((1 - r2) / (1 + r2))), Math.abs(a2) <= 1e-10)
        return o2;
    return NaN;
  }(this.e, 2 * t2.y * this.k0 / this.a), s2 = O(this.long0 + t2.x / (this.a * this.k0))), t2.x = s2, t2.y = i2, t2;
}, names: ["cea"] };
var as = { init: function() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts);
}, forward: function(t2) {
  var s2 = t2.x, i2 = t2.y, a2 = O(s2 - this.long0), h2 = Jt(i2 - this.lat0);
  return t2.x = this.x0 + this.a * a2 * this.rc, t2.y = this.y0 + this.a * h2, t2;
}, inverse: function(t2) {
  var s2 = t2.x, i2 = t2.y;
  return t2.x = O(this.long0 + (s2 - this.x0) / (this.a * this.rc)), t2.y = Jt(this.lat0 + (i2 - this.y0) / this.a), t2;
}, names: ["Equirectangular", "Equidistant_Cylindrical", "eqc"] };
var hs = { init: function() {
  this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Ft(this.es), this.e1 = $t(this.es), this.e2 = Ht(this.es), this.e3 = Wt(this.es), this.ml0 = this.a * Dt(this.e0, this.e1, this.e2, this.e3, this.lat0);
}, forward: function(t2) {
  var s2, i2, a2, h2 = t2.x, e2 = t2.y, n2 = O(h2 - this.long0);
  if (a2 = n2 * Math.sin(e2), this.sphere)
    Math.abs(e2) <= 1e-10 ? (s2 = this.a * n2, i2 = -1 * this.a * this.lat0) : (s2 = this.a * Math.sin(a2) / Math.tan(e2), i2 = this.a * (Jt(e2 - this.lat0) + (1 - Math.cos(a2)) / Math.tan(e2)));
  else if (Math.abs(e2) <= 1e-10)
    s2 = this.a * n2, i2 = -1 * this.ml0;
  else {
    var r2 = Qt(this.a, this.e, Math.sin(e2)) / Math.tan(e2);
    s2 = r2 * Math.sin(a2), i2 = this.a * Dt(this.e0, this.e1, this.e2, this.e3, e2) - this.ml0 + r2 * (1 - Math.cos(a2));
  }
  return t2.x = s2 + this.x0, t2.y = i2 + this.y0, t2;
}, inverse: function(t2) {
  var s2, i2, a2, h2, e2, n2, r2, o2, l2;
  if (a2 = t2.x - this.x0, h2 = t2.y - this.y0, this.sphere)
    if (Math.abs(h2 + this.a * this.lat0) <= 1e-10)
      s2 = O(a2 / this.a + this.long0), i2 = 0;
    else {
      var c2;
      for (n2 = this.lat0 + h2 / this.a, r2 = a2 * a2 / this.a / this.a + n2 * n2, o2 = n2, e2 = 20; e2; --e2)
        if (o2 += l2 = -1 * (n2 * (o2 * (c2 = Math.tan(o2)) + 1) - o2 - 0.5 * (o2 * o2 + r2) * c2) / ((o2 - n2) / c2 - 1), Math.abs(l2) <= 1e-10) {
          i2 = o2;
          break;
        }
      s2 = O(this.long0 + Math.asin(a2 * Math.tan(o2) / this.a) / Math.sin(i2));
    }
  else if (Math.abs(h2 + this.ml0) <= 1e-10)
    i2 = 0, s2 = O(this.long0 + a2 / this.a);
  else {
    var u2, M2, d2, f2, p2;
    for (n2 = (this.ml0 + h2) / this.a, r2 = a2 * a2 / this.a / this.a + n2 * n2, o2 = n2, e2 = 20; e2; --e2)
      if (p2 = this.e * Math.sin(o2), u2 = Math.sqrt(1 - p2 * p2) * Math.tan(o2), M2 = this.a * Dt(this.e0, this.e1, this.e2, this.e3, o2), d2 = this.e0 - 2 * this.e1 * Math.cos(2 * o2) + 4 * this.e2 * Math.cos(4 * o2) - 6 * this.e3 * Math.cos(6 * o2), o2 -= l2 = (n2 * (u2 * (f2 = M2 / this.a) + 1) - f2 - 0.5 * u2 * (f2 * f2 + r2)) / (this.es * Math.sin(2 * o2) * (f2 * f2 + r2 - 2 * n2 * f2) / (4 * u2) + (n2 - f2) * (u2 * d2 - 2 / Math.sin(2 * o2)) - d2), Math.abs(l2) <= 1e-10) {
        i2 = o2;
        break;
      }
    u2 = Math.sqrt(1 - this.es * Math.pow(Math.sin(i2), 2)) * Math.tan(i2), s2 = O(this.long0 + Math.asin(a2 * u2 / this.a) / Math.sin(i2));
  }
  return t2.x = s2, t2.y = i2, t2;
}, names: ["Polyconic", "poly"] };
var es = { init: function() {
  this.A = [], this.A[1] = 0.6399175073, this.A[2] = -0.1358797613, this.A[3] = 0.063294409, this.A[4] = -0.02526853, this.A[5] = 0.0117879, this.A[6] = -55161e-7, this.A[7] = 26906e-7, this.A[8] = -1333e-6, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = 0.7557853228, this.B_im[1] = 0, this.B_re[2] = 0.249204646, this.B_im[2] = 3371507e-9, this.B_re[3] = -1541739e-9, this.B_im[3] = 0.04105856, this.B_re[4] = -0.10162907, this.B_im[4] = 0.01727609, this.B_re[5] = -0.26623489, this.B_im[5] = -0.36249218, this.B_re[6] = -0.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -0.577245789, this.C_im[2] = -7809598e-9, this.C_re[3] = 0.508307513, this.C_im[3] = -0.112208952, this.C_re[4] = -0.15094762, this.C_im[4] = 0.18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = 0.5185406398, this.D[3] = -0.03333098, this.D[4] = -0.1052906, this.D[5] = -0.0368594, this.D[6] = 7317e-6, this.D[7] = 0.0122, this.D[8] = 394e-5, this.D[9] = -13e-4;
}, forward: function(t2) {
  var s2, i2 = t2.x, h2 = t2.y - this.lat0, e2 = i2 - this.long0, n2 = h2 / a * 1e-5, r2 = e2, o2 = 1, l2 = 0;
  for (s2 = 1; s2 <= 10; s2++)
    o2 *= n2, l2 += this.A[s2] * o2;
  var c2, u2 = l2, M2 = r2, d2 = 1, f2 = 0, p2 = 0, m2 = 0;
  for (s2 = 1; s2 <= 6; s2++)
    c2 = f2 * u2 + d2 * M2, d2 = d2 * u2 - f2 * M2, f2 = c2, p2 = p2 + this.B_re[s2] * d2 - this.B_im[s2] * f2, m2 = m2 + this.B_im[s2] * d2 + this.B_re[s2] * f2;
  return t2.x = m2 * this.a + this.x0, t2.y = p2 * this.a + this.y0, t2;
}, inverse: function(t2) {
  var s2, i2, h2 = t2.x, e2 = t2.y, n2 = h2 - this.x0, r2 = (e2 - this.y0) / this.a, o2 = n2 / this.a, l2 = 1, c2 = 0, u2 = 0, M2 = 0;
  for (s2 = 1; s2 <= 6; s2++)
    i2 = c2 * r2 + l2 * o2, l2 = l2 * r2 - c2 * o2, c2 = i2, u2 = u2 + this.C_re[s2] * l2 - this.C_im[s2] * c2, M2 = M2 + this.C_im[s2] * l2 + this.C_re[s2] * c2;
  for (var d2 = 0; d2 < this.iterations; d2++) {
    var f2, p2 = u2, m2 = M2, y2 = r2, _2 = o2;
    for (s2 = 2; s2 <= 6; s2++)
      f2 = m2 * u2 + p2 * M2, p2 = p2 * u2 - m2 * M2, m2 = f2, y2 += (s2 - 1) * (this.B_re[s2] * p2 - this.B_im[s2] * m2), _2 += (s2 - 1) * (this.B_im[s2] * p2 + this.B_re[s2] * m2);
    p2 = 1, m2 = 0;
    var g2 = this.B_re[1], x2 = this.B_im[1];
    for (s2 = 2; s2 <= 6; s2++)
      f2 = m2 * u2 + p2 * M2, p2 = p2 * u2 - m2 * M2, m2 = f2, g2 += s2 * (this.B_re[s2] * p2 - this.B_im[s2] * m2), x2 += s2 * (this.B_im[s2] * p2 + this.B_re[s2] * m2);
    var v2 = g2 * g2 + x2 * x2;
    u2 = (y2 * g2 + _2 * x2) / v2, M2 = (_2 * g2 - y2 * x2) / v2;
  }
  var b2 = u2, w2 = M2, S2 = 1, P2 = 0;
  for (s2 = 1; s2 <= 9; s2++)
    S2 *= b2, P2 += this.D[s2] * S2;
  var N2 = this.lat0 + P2 * a * 1e5, E2 = this.long0 + w2;
  return t2.x = E2, t2.y = N2, t2;
}, names: ["New_Zealand_Map_Grid", "nzmg"] };
var ns = { init: function() {
}, forward: function(t2) {
  var s2 = t2.x, i2 = t2.y, a2 = O(s2 - this.long0), h2 = this.x0 + this.a * a2, e2 = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + i2 / 2.5)) * 1.25;
  return t2.x = h2, t2.y = e2, t2;
}, inverse: function(t2) {
  t2.x -= this.x0, t2.y -= this.y0;
  var s2 = O(this.long0 + t2.x / this.a), i2 = 2.5 * (Math.atan(Math.exp(0.8 * t2.y / this.a)) - Math.PI / 4);
  return t2.x = s2, t2.y = i2, t2;
}, names: ["Miller_Cylindrical", "mill"] };
var rs = { init: function() {
  this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = St(this.es);
}, forward: function(t2) {
  var s2, i2, a2 = t2.x, h2 = t2.y;
  if (a2 = O(a2 - this.long0), this.sphere) {
    if (this.m)
      for (var e2 = this.n * Math.sin(h2), n2 = 20; n2; --n2) {
        var r2 = (this.m * h2 + Math.sin(h2) - e2) / (this.m + Math.cos(h2));
        if (h2 -= r2, Math.abs(r2) < 1e-10)
          break;
      }
    else
      h2 = 1 !== this.n ? Math.asin(this.n * Math.sin(h2)) : h2;
    s2 = this.a * this.C_x * a2 * (this.m + Math.cos(h2)), i2 = this.a * this.C_y * h2;
  } else {
    var o2 = Math.sin(h2), l2 = Math.cos(h2);
    i2 = this.a * Pt(h2, o2, l2, this.en), s2 = this.a * a2 * l2 / Math.sqrt(1 - this.es * o2 * o2);
  }
  return t2.x = s2, t2.y = i2, t2;
}, inverse: function(t2) {
  var s2, i2, a2;
  return t2.x -= this.x0, i2 = t2.x / this.a, t2.y -= this.y0, s2 = t2.y / this.a, this.sphere ? (s2 /= this.C_y, i2 /= this.C_x * (this.m + Math.cos(s2)), this.m ? s2 = Zt((this.m * s2 + Math.sin(s2)) / this.n) : 1 !== this.n && (s2 = Zt(Math.sin(s2) / this.n)), i2 = O(i2 + this.long0), s2 = Jt(s2)) : (s2 = Nt(t2.y / this.a, this.es, this.en), (a2 = Math.abs(s2)) < h ? (a2 = Math.sin(s2), i2 = O(this.long0 + t2.x * Math.sqrt(1 - this.es * a2 * a2) / (this.a * Math.cos(s2)))) : a2 - 1e-10 < h && (i2 = this.long0)), t2.x = i2, t2.y = s2, t2;
}, names: ["Sinusoidal", "sinu"] };
var os = { init: function() {
}, forward: function(t2) {
  for (var s2 = t2.x, i2 = t2.y, a2 = O(s2 - this.long0), h2 = i2, e2 = Math.PI * Math.sin(i2); ; ) {
    var n2 = -(h2 + Math.sin(h2) - e2) / (1 + Math.cos(h2));
    if (h2 += n2, Math.abs(n2) < 1e-10)
      break;
  }
  h2 /= 2, Math.PI / 2 - Math.abs(i2) < 1e-10 && (a2 = 0);
  var r2 = 0.900316316158 * this.a * a2 * Math.cos(h2) + this.x0, o2 = 1.4142135623731 * this.a * Math.sin(h2) + this.y0;
  return t2.x = r2, t2.y = o2, t2;
}, inverse: function(t2) {
  var s2, i2;
  t2.x -= this.x0, t2.y -= this.y0, i2 = t2.y / (1.4142135623731 * this.a), Math.abs(i2) > 0.999999999999 && (i2 = 0.999999999999), s2 = Math.asin(i2);
  var a2 = O(this.long0 + t2.x / (0.900316316158 * this.a * Math.cos(s2)));
  a2 < -Math.PI && (a2 = -Math.PI), a2 > Math.PI && (a2 = Math.PI), i2 = (2 * s2 + Math.sin(2 * s2)) / Math.PI, Math.abs(i2) > 1 && (i2 = 1);
  var h2 = Math.asin(i2);
  return t2.x = a2, t2.y = h2, t2;
}, names: ["Mollweide", "moll"] };
var ls = { init: function() {
  Math.abs(this.lat1 + this.lat2) < 1e-10 || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Ft(this.es), this.e1 = $t(this.es), this.e2 = Ht(this.es), this.e3 = Wt(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = k(this.e, this.sinphi, this.cosphi), this.ml1 = Dt(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < 1e-10 ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = k(this.e, this.sinphi, this.cosphi), this.ml2 = Dt(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = Dt(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0));
}, forward: function(t2) {
  var s2, i2 = t2.x, a2 = t2.y;
  if (this.sphere)
    s2 = this.a * (this.g - a2);
  else {
    var h2 = Dt(this.e0, this.e1, this.e2, this.e3, a2);
    s2 = this.a * (this.g - h2);
  }
  var e2 = this.ns * O(i2 - this.long0), n2 = this.x0 + s2 * Math.sin(e2), r2 = this.y0 + this.rh - s2 * Math.cos(e2);
  return t2.x = n2, t2.y = r2, t2;
}, inverse: function(t2) {
  var s2, i2, a2, h2;
  t2.x -= this.x0, t2.y = this.rh - t2.y + this.y0, this.ns >= 0 ? (i2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y), s2 = 1) : (i2 = -Math.sqrt(t2.x * t2.x + t2.y * t2.y), s2 = -1);
  var e2 = 0;
  return 0 !== i2 && (e2 = Math.atan2(s2 * t2.x, s2 * t2.y)), this.sphere ? (h2 = O(this.long0 + e2 / this.ns), a2 = Jt(this.g - i2 / this.a), t2.x = h2, t2.y = a2, t2) : (a2 = Xt(this.g - i2 / this.a, this.e0, this.e1, this.e2, this.e3), h2 = O(this.long0 + e2 / this.ns), t2.x = h2, t2.y = a2, t2);
}, names: ["Equidistant_Conic", "eqdc"] };
var cs = { init: function() {
  this.R = this.a;
}, forward: function(t2) {
  var s2, i2, a2 = t2.x, e2 = t2.y, n2 = O(a2 - this.long0);
  Math.abs(e2) <= 1e-10 && (s2 = this.x0 + this.R * n2, i2 = this.y0);
  var r2 = Zt(2 * Math.abs(e2 / Math.PI));
  (Math.abs(n2) <= 1e-10 || Math.abs(Math.abs(e2) - h) <= 1e-10) && (s2 = this.x0, i2 = e2 >= 0 ? this.y0 + Math.PI * this.R * Math.tan(0.5 * r2) : this.y0 + Math.PI * this.R * -Math.tan(0.5 * r2));
  var o2 = 0.5 * Math.abs(Math.PI / n2 - n2 / Math.PI), l2 = o2 * o2, c2 = Math.sin(r2), u2 = Math.cos(r2), M2 = u2 / (c2 + u2 - 1), d2 = M2 * M2, f2 = M2 * (2 / c2 - 1), p2 = f2 * f2, m2 = Math.PI * this.R * (o2 * (M2 - p2) + Math.sqrt(l2 * (M2 - p2) * (M2 - p2) - (p2 + l2) * (d2 - p2))) / (p2 + l2);
  n2 < 0 && (m2 = -m2), s2 = this.x0 + m2;
  var y2 = l2 + M2;
  return m2 = Math.PI * this.R * (f2 * y2 - o2 * Math.sqrt((p2 + l2) * (l2 + 1) - y2 * y2)) / (p2 + l2), i2 = e2 >= 0 ? this.y0 + m2 : this.y0 - m2, t2.x = s2, t2.y = i2, t2;
}, inverse: function(t2) {
  var s2, i2, a2, h2, e2, n2, r2, o2, l2, c2, u2, M2;
  return t2.x -= this.x0, t2.y -= this.y0, u2 = Math.PI * this.R, e2 = (a2 = t2.x / u2) * a2 + (h2 = t2.y / u2) * h2, u2 = 3 * (h2 * h2 / (o2 = -2 * (n2 = -Math.abs(h2) * (1 + e2)) + 1 + 2 * h2 * h2 + e2 * e2) + (2 * (r2 = n2 - 2 * h2 * h2 + a2 * a2) * r2 * r2 / o2 / o2 / o2 - 9 * n2 * r2 / o2 / o2) / 27) / (l2 = (n2 - r2 * r2 / 3 / o2) / o2) / (c2 = 2 * Math.sqrt(-l2 / 3)), Math.abs(u2) > 1 && (u2 = u2 >= 0 ? 1 : -1), M2 = Math.acos(u2) / 3, i2 = t2.y >= 0 ? (-c2 * Math.cos(M2 + Math.PI / 3) - r2 / 3 / o2) * Math.PI : -(-c2 * Math.cos(M2 + Math.PI / 3) - r2 / 3 / o2) * Math.PI, s2 = Math.abs(a2) < 1e-10 ? this.long0 : O(this.long0 + Math.PI * (e2 - 1 + Math.sqrt(1 + 2 * (a2 * a2 - h2 * h2) + e2 * e2)) / 2 / a2), t2.x = s2, t2.y = i2, t2;
}, names: ["Van_der_Grinten_I", "VanDerGrinten", "vandg"] };
var us = { init: function() {
  this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0);
}, forward: function(t2) {
  var s2, i2, a2, e2, n2, r2, o2, l2, c2, u2, M2, d2, f2, p2, m2, y2, _2, g2, x2, v2, b2, w2, S2 = t2.x, P2 = t2.y, N2 = Math.sin(t2.y), E2 = Math.cos(t2.y), A2 = O(S2 - this.long0);
  return this.sphere ? Math.abs(this.sin_p12 - 1) <= 1e-10 ? (t2.x = this.x0 + this.a * (h - P2) * Math.sin(A2), t2.y = this.y0 - this.a * (h - P2) * Math.cos(A2), t2) : Math.abs(this.sin_p12 + 1) <= 1e-10 ? (t2.x = this.x0 + this.a * (h + P2) * Math.sin(A2), t2.y = this.y0 + this.a * (h + P2) * Math.cos(A2), t2) : (g2 = this.sin_p12 * N2 + this.cos_p12 * E2 * Math.cos(A2), _2 = (y2 = Math.acos(g2)) ? y2 / Math.sin(y2) : 1, t2.x = this.x0 + this.a * _2 * E2 * Math.sin(A2), t2.y = this.y0 + this.a * _2 * (this.cos_p12 * N2 - this.sin_p12 * E2 * Math.cos(A2)), t2) : (s2 = Ft(this.es), i2 = $t(this.es), a2 = Ht(this.es), e2 = Wt(this.es), Math.abs(this.sin_p12 - 1) <= 1e-10 ? (n2 = this.a * Dt(s2, i2, a2, e2, h), r2 = this.a * Dt(s2, i2, a2, e2, P2), t2.x = this.x0 + (n2 - r2) * Math.sin(A2), t2.y = this.y0 - (n2 - r2) * Math.cos(A2), t2) : Math.abs(this.sin_p12 + 1) <= 1e-10 ? (n2 = this.a * Dt(s2, i2, a2, e2, h), r2 = this.a * Dt(s2, i2, a2, e2, P2), t2.x = this.x0 + (n2 + r2) * Math.sin(A2), t2.y = this.y0 + (n2 + r2) * Math.cos(A2), t2) : (o2 = N2 / E2, l2 = Qt(this.a, this.e, this.sin_p12), c2 = Qt(this.a, this.e, N2), u2 = Math.atan((1 - this.es) * o2 + this.es * l2 * this.sin_p12 / (c2 * E2)), x2 = 0 === (M2 = Math.atan2(Math.sin(A2), this.cos_p12 * Math.tan(u2) - this.sin_p12 * Math.cos(A2))) ? Math.asin(this.cos_p12 * Math.sin(u2) - this.sin_p12 * Math.cos(u2)) : Math.abs(Math.abs(M2) - Math.PI) <= 1e-10 ? -Math.asin(this.cos_p12 * Math.sin(u2) - this.sin_p12 * Math.cos(u2)) : Math.asin(Math.sin(A2) * Math.cos(u2) / Math.sin(M2)), d2 = this.e * this.sin_p12 / Math.sqrt(1 - this.es), y2 = l2 * x2 * (1 - (v2 = x2 * x2) * (m2 = (f2 = this.e * this.cos_p12 * Math.cos(M2) / Math.sqrt(1 - this.es)) * f2) * (1 - m2) / 6 + (b2 = v2 * x2) / 8 * (p2 = d2 * f2) * (1 - 2 * m2) + (w2 = b2 * x2) / 120 * (m2 * (4 - 7 * m2) - 3 * d2 * d2 * (1 - 7 * m2)) - w2 * x2 / 48 * p2), t2.x = this.x0 + y2 * Math.sin(M2), t2.y = this.y0 + y2 * Math.cos(M2), t2));
}, inverse: function(t2) {
  var s2, i2, a2, e2, n2, r2, o2, l2, c2, u2, M2, d2, f2, p2, m2, y2, _2, g2, x2, v2, b2, w2, S2;
  if (t2.x -= this.x0, t2.y -= this.y0, this.sphere) {
    if ((s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y)) > 2 * h * this.a)
      return;
    return i2 = s2 / this.a, a2 = Math.sin(i2), e2 = Math.cos(i2), n2 = this.long0, Math.abs(s2) <= 1e-10 ? r2 = this.lat0 : (r2 = Zt(e2 * this.sin_p12 + t2.y * a2 * this.cos_p12 / s2), o2 = Math.abs(this.lat0) - h, n2 = Math.abs(o2) <= 1e-10 ? this.lat0 >= 0 ? O(this.long0 + Math.atan2(t2.x, -t2.y)) : O(this.long0 - Math.atan2(-t2.x, t2.y)) : O(this.long0 + Math.atan2(t2.x * a2, s2 * this.cos_p12 * e2 - t2.y * this.sin_p12 * a2))), t2.x = n2, t2.y = r2, t2;
  }
  return l2 = Ft(this.es), c2 = $t(this.es), u2 = Ht(this.es), M2 = Wt(this.es), Math.abs(this.sin_p12 - 1) <= 1e-10 ? (r2 = Xt(((d2 = this.a * Dt(l2, c2, u2, M2, h)) - (s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y))) / this.a, l2, c2, u2, M2), n2 = O(this.long0 + Math.atan2(t2.x, -1 * t2.y)), t2.x = n2, t2.y = r2, t2) : Math.abs(this.sin_p12 + 1) <= 1e-10 ? (d2 = this.a * Dt(l2, c2, u2, M2, h), r2 = Xt(((s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y)) - d2) / this.a, l2, c2, u2, M2), n2 = O(this.long0 + Math.atan2(t2.x, t2.y)), t2.x = n2, t2.y = r2, t2) : (s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y), m2 = Math.atan2(t2.x, t2.y), f2 = Qt(this.a, this.e, this.sin_p12), y2 = Math.cos(m2), g2 = -(_2 = this.e * this.cos_p12 * y2) * _2 / (1 - this.es), x2 = 3 * this.es * (1 - g2) * this.sin_p12 * this.cos_p12 * y2 / (1 - this.es), w2 = 1 - g2 * (b2 = (v2 = s2 / f2) - g2 * (1 + g2) * Math.pow(v2, 3) / 6 - x2 * (1 + 3 * g2) * Math.pow(v2, 4) / 24) * b2 / 2 - v2 * b2 * b2 * b2 / 6, p2 = Math.asin(this.sin_p12 * Math.cos(b2) + this.cos_p12 * Math.sin(b2) * y2), n2 = O(this.long0 + Math.asin(Math.sin(m2) * Math.sin(b2) / Math.cos(p2))), S2 = Math.sin(p2), r2 = Math.atan2((S2 - this.es * w2 * this.sin_p12) * Math.tan(p2), S2 * (1 - this.es)), t2.x = n2, t2.y = r2, t2);
}, names: ["Azimuthal_Equidistant", "aeqd"] };
var Ms = { init: function() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
}, forward: function(t2) {
  var s2, i2, a2, h2, e2, n2, r2, o2 = t2.x, l2 = t2.y;
  return a2 = O(o2 - this.long0), s2 = Math.sin(l2), i2 = Math.cos(l2), h2 = Math.cos(a2), ((e2 = this.sin_p14 * s2 + this.cos_p14 * i2 * h2) > 0 || Math.abs(e2) <= 1e-10) && (n2 = 1 * this.a * i2 * Math.sin(a2), r2 = this.y0 + 1 * this.a * (this.cos_p14 * s2 - this.sin_p14 * i2 * h2)), t2.x = n2, t2.y = r2, t2;
}, inverse: function(t2) {
  var s2, i2, a2, e2, n2, r2, o2;
  return t2.x -= this.x0, t2.y -= this.y0, i2 = Zt((s2 = Math.sqrt(t2.x * t2.x + t2.y * t2.y)) / this.a), a2 = Math.sin(i2), e2 = Math.cos(i2), r2 = this.long0, Math.abs(s2) <= 1e-10 ? (o2 = this.lat0, t2.x = r2, t2.y = o2, t2) : (o2 = Zt(e2 * this.sin_p14 + t2.y * a2 * this.cos_p14 / s2), n2 = Math.abs(this.lat0) - h, Math.abs(n2) <= 1e-10 ? (r2 = this.lat0 >= 0 ? O(this.long0 + Math.atan2(t2.x, -t2.y)) : O(this.long0 - Math.atan2(-t2.x, t2.y)), t2.x = r2, t2.y = o2, t2) : (r2 = O(this.long0 + Math.atan2(t2.x * a2, s2 * this.cos_p14 * e2 - t2.y * this.sin_p14 * a2)), t2.x = r2, t2.y = o2, t2));
}, names: ["ortho"] };
function ds(t2, s2, i2, a2) {
  var e2;
  return t2 < 1e-10 ? (a2.value = 1, e2 = 0) : (e2 = Math.atan2(s2, i2), Math.abs(e2) <= r ? a2.value = 1 : e2 > r && e2 <= h + r ? (a2.value = 2, e2 -= h) : e2 > h + r || e2 <= -(h + r) ? (a2.value = 3, e2 = e2 >= 0 ? e2 - l : e2 + l) : (a2.value = 4, e2 += h)), e2;
}
function fs(t2, s2) {
  var i2 = t2 + s2;
  return i2 < -l ? i2 += o : i2 > +l && (i2 -= o), i2;
}
var ps = { init: function() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= h - r / 2 ? this.face = 5 : this.lat0 <= -(h - r / 2) ? this.face = 6 : Math.abs(this.long0) <= r ? this.face = 1 : Math.abs(this.long0) <= h + r ? this.face = this.long0 > 0 ? 2 : 4 : this.face = 3, 0 !== this.es && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
}, forward: function(t2) {
  var s2, i2, a2, e2, n2, o2, c2 = { x: 0, y: 0 }, u2 = { value: 0 };
  if (t2.x -= this.long0, s2 = 0 !== this.es ? Math.atan(this.one_minus_f_squared * Math.tan(t2.y)) : t2.y, i2 = t2.x, 5 === this.face)
    e2 = h - s2, i2 >= r && i2 <= h + r ? (u2.value = 1, a2 = i2 - h) : i2 > h + r || i2 <= -(h + r) ? (u2.value = 2, a2 = i2 > 0 ? i2 - l : i2 + l) : i2 > -(h + r) && i2 <= -r ? (u2.value = 3, a2 = i2 + h) : (u2.value = 4, a2 = i2);
  else if (6 === this.face)
    e2 = h + s2, i2 >= r && i2 <= h + r ? (u2.value = 1, a2 = -i2 + h) : i2 < r && i2 >= -r ? (u2.value = 2, a2 = -i2) : i2 < -r && i2 >= -(h + r) ? (u2.value = 3, a2 = -i2 - h) : (u2.value = 4, a2 = i2 > 0 ? -i2 + l : -i2 - l);
  else {
    var M2, d2, f2, p2, m2, y2;
    2 === this.face ? i2 = fs(i2, +h) : 3 === this.face ? i2 = fs(i2, +l) : 4 === this.face && (i2 = fs(i2, -h)), p2 = Math.sin(s2), m2 = Math.cos(s2), y2 = Math.sin(i2), M2 = m2 * Math.cos(i2), d2 = m2 * y2, f2 = p2, 1 === this.face ? a2 = ds(e2 = Math.acos(M2), f2, d2, u2) : 2 === this.face ? a2 = ds(e2 = Math.acos(d2), f2, -M2, u2) : 3 === this.face ? a2 = ds(e2 = Math.acos(-M2), f2, -d2, u2) : 4 === this.face ? a2 = ds(e2 = Math.acos(-d2), f2, M2, u2) : (e2 = a2 = 0, u2.value = 1);
  }
  return o2 = Math.atan(12 / l * (a2 + Math.acos(Math.sin(a2) * Math.cos(r)) - h)), n2 = Math.sqrt((1 - Math.cos(e2)) / (Math.cos(o2) * Math.cos(o2)) / (1 - Math.cos(Math.atan(1 / Math.cos(a2))))), 2 === u2.value ? o2 += h : 3 === u2.value ? o2 += l : 4 === u2.value && (o2 += 1.5 * l), c2.x = n2 * Math.cos(o2), c2.y = n2 * Math.sin(o2), c2.x = c2.x * this.a + this.x0, c2.y = c2.y * this.a + this.y0, t2.x = c2.x, t2.y = c2.y, t2;
}, inverse: function(t2) {
  var s2, i2, a2, e2, n2, r2, o2, c2, u2, M2, d2, f2, p2 = { lam: 0, phi: 0 }, m2 = { value: 0 };
  if (t2.x = (t2.x - this.x0) / this.a, t2.y = (t2.y - this.y0) / this.a, i2 = Math.atan(Math.sqrt(t2.x * t2.x + t2.y * t2.y)), s2 = Math.atan2(t2.y, t2.x), t2.x >= 0 && t2.x >= Math.abs(t2.y) ? m2.value = 1 : t2.y >= 0 && t2.y >= Math.abs(t2.x) ? (m2.value = 2, s2 -= h) : t2.x < 0 && -t2.x >= Math.abs(t2.y) ? (m2.value = 3, s2 = s2 < 0 ? s2 + l : s2 - l) : (m2.value = 4, s2 += h), u2 = l / 12 * Math.tan(s2), n2 = Math.sin(u2) / (Math.cos(u2) - 1 / Math.sqrt(2)), r2 = Math.atan(n2), (o2 = 1 - (a2 = Math.cos(s2)) * a2 * (e2 = Math.tan(i2)) * e2 * (1 - Math.cos(Math.atan(1 / Math.cos(r2))))) < -1 ? o2 = -1 : o2 > 1 && (o2 = 1), 5 === this.face)
    c2 = Math.acos(o2), p2.phi = h - c2, 1 === m2.value ? p2.lam = r2 + h : 2 === m2.value ? p2.lam = r2 < 0 ? r2 + l : r2 - l : 3 === m2.value ? p2.lam = r2 - h : p2.lam = r2;
  else if (6 === this.face)
    c2 = Math.acos(o2), p2.phi = c2 - h, 1 === m2.value ? p2.lam = -r2 + h : 2 === m2.value ? p2.lam = -r2 : 3 === m2.value ? p2.lam = -r2 - h : p2.lam = r2 < 0 ? -r2 - l : -r2 + l;
  else {
    var y2, _2, g2;
    u2 = (y2 = o2) * y2, _2 = (u2 += (g2 = u2 >= 1 ? 0 : Math.sqrt(1 - u2) * Math.sin(r2)) * g2) >= 1 ? 0 : Math.sqrt(1 - u2), 2 === m2.value ? (u2 = _2, _2 = -g2, g2 = u2) : 3 === m2.value ? (_2 = -_2, g2 = -g2) : 4 === m2.value && (u2 = _2, _2 = g2, g2 = -u2), 2 === this.face ? (u2 = y2, y2 = -_2, _2 = u2) : 3 === this.face ? (y2 = -y2, _2 = -_2) : 4 === this.face && (u2 = y2, y2 = _2, _2 = -u2), p2.phi = Math.acos(-g2) - h, p2.lam = Math.atan2(_2, y2), 2 === this.face ? p2.lam = fs(p2.lam, -h) : 3 === this.face ? p2.lam = fs(p2.lam, -l) : 4 === this.face && (p2.lam = fs(p2.lam, +h));
  }
  return 0 !== this.es && (M2 = p2.phi < 0 ? 1 : 0, d2 = Math.tan(p2.phi), f2 = this.b / Math.sqrt(d2 * d2 + this.one_minus_f_squared), p2.phi = Math.atan(Math.sqrt(this.a * this.a - f2 * f2) / (this.one_minus_f * f2)), M2 && (p2.phi = -p2.phi)), p2.lam += this.long0, t2.x = p2.lam, t2.y = p2.phi, t2;
}, names: ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"] };
var ms = [[1, 22199e-21, -715515e-10, 31103e-10], [0.9986, -482243e-9, -24897e-9, -13309e-10], [0.9954, -83103e-8, -448605e-10, -986701e-12], [0.99, -135364e-8, -59661e-9, 36777e-10], [0.9822, -167442e-8, -449547e-11, -572411e-11], [0.973, -214868e-8, -903571e-10, 18736e-12], [0.96, -305085e-8, -900761e-10, 164917e-11], [0.9427, -382792e-8, -653386e-10, -26154e-10], [0.9216, -467746e-8, -10457e-8, 481243e-11], [0.8962, -536223e-8, -323831e-10, -543432e-11], [0.8679, -609363e-8, -113898e-9, 332484e-11], [0.835, -698325e-8, -640253e-10, 934959e-12], [0.7986, -755338e-8, -500009e-10, 935324e-12], [0.7597, -798324e-8, -35971e-9, -227626e-11], [0.7186, -851367e-8, -701149e-10, -86303e-10], [0.6732, -986209e-8, -199569e-9, 191974e-10], [0.6213, -0.010418, 883923e-10, 624051e-11], [0.5722, -906601e-8, 182e-6, 624051e-11], [0.5322, -677797e-8, 275608e-9, 624051e-11]];
var ys = [[-520417e-23, 0.0124, 121431e-23, -845284e-16], [0.062, 0.0124, -126793e-14, 422642e-15], [0.124, 0.0124, 507171e-14, -160604e-14], [0.186, 0.0123999, -190189e-13, 600152e-14], [0.248, 0.0124002, 710039e-13, -224e-10], [0.31, 0.0123992, -264997e-12, 835986e-13], [0.372, 0.0124029, 988983e-12, -311994e-12], [0.434, 0.0123893, -369093e-11, -435621e-12], [0.4958, 0.0123198, -102252e-10, -345523e-12], [0.5571, 0.0121916, -154081e-10, -582288e-12], [0.6176, 0.0119938, -241424e-10, -525327e-12], [0.6769, 0.011713, -320223e-10, -516405e-12], [0.7346, 0.0113541, -397684e-10, -609052e-12], [0.7903, 0.0109107, -489042e-10, -104739e-11], [0.8435, 0.0103431, -64615e-9, -140374e-14], [0.8936, 969686e-8, -64636e-9, -8547e-9], [0.9394, 840947e-8, -192841e-9, -42106e-10], [0.9761, 616527e-8, -256e-6, -42106e-10], [1, 328947e-8, -319159e-9, -42106e-10]];
var _s = function(t2, s2) {
  return t2[0] + s2 * (t2[1] + s2 * (t2[2] + s2 * t2[3]));
};
var gs = { init: function() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson";
}, forward: function(t2) {
  var s2 = O(t2.x - this.long0), i2 = Math.abs(t2.y), a2 = Math.floor(11.459155902616464 * i2);
  a2 < 0 ? a2 = 0 : a2 >= 18 && (a2 = 17);
  var h2 = { x: _s(ms[a2], i2 = n * (i2 - 0.08726646259971647 * a2)) * s2, y: _s(ys[a2], i2) };
  return t2.y < 0 && (h2.y = -h2.y), h2.x = h2.x * this.a * 0.8487 + this.x0, h2.y = h2.y * this.a * 1.3523 + this.y0, h2;
}, inverse: function(t2) {
  var s2 = { x: (t2.x - this.x0) / (0.8487 * this.a), y: Math.abs(t2.y - this.y0) / (1.3523 * this.a) };
  if (s2.y >= 1)
    s2.x /= ms[18][0], s2.y = t2.y < 0 ? -h : h;
  else {
    var i2 = Math.floor(18 * s2.y);
    for (i2 < 0 ? i2 = 0 : i2 >= 18 && (i2 = 17); ; )
      if (ys[i2][0] > s2.y)
        --i2;
      else {
        if (!(ys[i2 + 1][0] <= s2.y))
          break;
        ++i2;
      }
    var a2 = ys[i2], n2 = 5 * (s2.y - a2[0]) / (ys[i2 + 1][0] - a2[0]);
    n2 = function(t3, s3, i3, a3) {
      for (var h2 = s3; a3; --a3) {
        var e2 = t3(h2);
        if (h2 -= e2, Math.abs(e2) < 1e-10)
          break;
      }
      return h2;
    }(function(t3) {
      return (_s(a2, t3) - s2.y) / function(t4, s3) {
        return t4[1] + s3 * (2 * t4[2] + 3 * s3 * t4[3]);
      }(a2, t3);
    }, n2, 0, 100), s2.x /= _s(ms[i2], n2), s2.y = (5 * i2 + n2) * e, t2.y < 0 && (s2.y = -s2.y);
  }
  return s2.x = O(s2.x + this.long0), s2;
}, names: ["Robinson", "robin"] };
var xs = { init: function() {
  this.name = "geocent";
}, forward: function(t2) {
  return V(t2, this.es, this.a);
}, inverse: function(t2) {
  return Z(t2, this.es, this.a, this.b);
}, names: ["Geocentric", "geocentric", "geocent", "Geocent"] };
var vs = { h: { def: 1e5, num: true }, azi: { def: 0, num: true, degrees: true }, tilt: { def: 0, num: true, degrees: true }, long0: { def: 0, num: true }, lat0: { def: 0, num: true } };
var bs = { init: function() {
  if (Object.keys(vs).forEach((function(t3) {
    if (void 0 === this[t3])
      this[t3] = vs[t3].def;
    else {
      if (vs[t3].num && isNaN(this[t3]))
        throw new Error("Invalid parameter value, must be numeric " + t3 + " = " + this[t3]);
      vs[t3].num && (this[t3] = parseFloat(this[t3]));
    }
    vs[t3].degrees && (this[t3] = this[t3] * e);
  }).bind(this)), Math.abs(Math.abs(this.lat0) - h) < 1e-10 ? this.mode = this.lat0 < 0 ? 1 : 0 : Math.abs(this.lat0) < 1e-10 ? this.mode = 2 : (this.mode = 3, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10)
    throw new Error("Invalid height");
  this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0;
  var t2 = this.tilt, s2 = this.azi;
  this.cg = Math.cos(s2), this.sg = Math.sin(s2), this.cw = Math.cos(t2), this.sw = Math.sin(t2);
}, forward: function(t2) {
  t2.x -= this.long0;
  var s2, i2, a2, h2, e2 = Math.sin(t2.y), n2 = Math.cos(t2.y), r2 = Math.cos(t2.x);
  switch (this.mode) {
    case 3:
      i2 = this.sinph0 * e2 + this.cosph0 * n2 * r2;
      break;
    case 2:
      i2 = n2 * r2;
      break;
    case 1:
      i2 = -e2;
      break;
    case 0:
      i2 = e2;
  }
  switch (s2 = (i2 = this.pn1 / (this.p - i2)) * n2 * Math.sin(t2.x), this.mode) {
    case 3:
      i2 *= this.cosph0 * e2 - this.sinph0 * n2 * r2;
      break;
    case 2:
      i2 *= e2;
      break;
    case 0:
      i2 *= -n2 * r2;
      break;
    case 1:
      i2 *= n2 * r2;
  }
  return h2 = 1 / ((a2 = i2 * this.cg + s2 * this.sg) * this.sw * this.h1 + this.cw), s2 = (s2 * this.cg - i2 * this.sg) * this.cw * h2, i2 = a2 * h2, t2.x = s2 * this.a, t2.y = i2 * this.a, t2;
}, inverse: function(t2) {
  t2.x /= this.a, t2.y /= this.a;
  var s2, i2, a2, h2 = { x: t2.x, y: t2.y };
  a2 = 1 / (this.pn1 - t2.y * this.sw), s2 = this.pn1 * t2.x * a2, i2 = this.pn1 * t2.y * this.cw * a2, t2.x = s2 * this.cg + i2 * this.sg, t2.y = i2 * this.cg - s2 * this.sg;
  var e2 = Ct(t2.x, t2.y);
  if (Math.abs(e2) < 1e-10)
    h2.x = 0, h2.y = t2.y;
  else {
    var n2, r2;
    switch (r2 = 1 - e2 * e2 * this.pfact, r2 = (this.p - Math.sqrt(r2)) / (this.pn1 / e2 + e2 / this.pn1), n2 = Math.sqrt(1 - r2 * r2), this.mode) {
      case 3:
        h2.y = Math.asin(n2 * this.sinph0 + t2.y * r2 * this.cosph0 / e2), t2.y = (n2 - this.sinph0 * Math.sin(h2.y)) * e2, t2.x *= r2 * this.cosph0;
        break;
      case 2:
        h2.y = Math.asin(t2.y * r2 / e2), t2.y = n2 * e2, t2.x *= r2;
        break;
      case 0:
        h2.y = Math.asin(n2), t2.y = -t2.y;
        break;
      case 1:
        h2.y = -Math.asin(n2);
    }
    h2.x = Math.atan2(t2.x, t2.y);
  }
  return t2.x = h2.x + this.long0, t2.y = h2.y, t2;
}, names: ["Tilted_Perspective", "tpers"] };
var ws = { init: function() {
  if (this.flip_axis = "x" === this.sweep ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, this.radius_g_1 <= 0 || this.radius_g_1 > 1e10)
    throw new Error();
  if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, 0 !== this.es) {
    var t2 = 1 - this.es, s2 = 1 / t2;
    this.radius_p = Math.sqrt(t2), this.radius_p2 = t2, this.radius_p_inv2 = s2, this.shape = "ellipse";
  } else
    this.radius_p = 1, this.radius_p2 = 1, this.radius_p_inv2 = 1, this.shape = "sphere";
  this.title || (this.title = "Geostationary Satellite View");
}, forward: function(t2) {
  var s2, i2, a2, h2, e2 = t2.x, n2 = t2.y;
  if (e2 -= this.long0, "ellipse" === this.shape) {
    n2 = Math.atan(this.radius_p2 * Math.tan(n2));
    var r2 = this.radius_p / Ct(this.radius_p * Math.cos(n2), Math.sin(n2));
    if (i2 = r2 * Math.cos(e2) * Math.cos(n2), a2 = r2 * Math.sin(e2) * Math.cos(n2), h2 = r2 * Math.sin(n2), (this.radius_g - i2) * i2 - a2 * a2 - h2 * h2 * this.radius_p_inv2 < 0)
      return t2.x = Number.NaN, t2.y = Number.NaN, t2;
    s2 = this.radius_g - i2, this.flip_axis ? (t2.x = this.radius_g_1 * Math.atan(a2 / Ct(h2, s2)), t2.y = this.radius_g_1 * Math.atan(h2 / s2)) : (t2.x = this.radius_g_1 * Math.atan(a2 / s2), t2.y = this.radius_g_1 * Math.atan(h2 / Ct(a2, s2)));
  } else
    "sphere" === this.shape && (s2 = Math.cos(n2), i2 = Math.cos(e2) * s2, a2 = Math.sin(e2) * s2, h2 = Math.sin(n2), s2 = this.radius_g - i2, this.flip_axis ? (t2.x = this.radius_g_1 * Math.atan(a2 / Ct(h2, s2)), t2.y = this.radius_g_1 * Math.atan(h2 / s2)) : (t2.x = this.radius_g_1 * Math.atan(a2 / s2), t2.y = this.radius_g_1 * Math.atan(h2 / Ct(a2, s2))));
  return t2.x = t2.x * this.a, t2.y = t2.y * this.a, t2;
}, inverse: function(t2) {
  var s2, i2, a2, h2, e2 = -1, n2 = 0, r2 = 0;
  if (t2.x = t2.x / this.a, t2.y = t2.y / this.a, "ellipse" === this.shape) {
    this.flip_axis ? (r2 = Math.tan(t2.y / this.radius_g_1), n2 = Math.tan(t2.x / this.radius_g_1) * Ct(1, r2)) : (n2 = Math.tan(t2.x / this.radius_g_1), r2 = Math.tan(t2.y / this.radius_g_1) * Ct(1, n2));
    var o2 = r2 / this.radius_p;
    if (s2 = n2 * n2 + o2 * o2 + e2 * e2, (a2 = (i2 = 2 * this.radius_g * e2) * i2 - 4 * s2 * this.C) < 0)
      return t2.x = Number.NaN, t2.y = Number.NaN, t2;
    h2 = (-i2 - Math.sqrt(a2)) / (2 * s2), e2 = this.radius_g + h2 * e2, n2 *= h2, r2 *= h2, t2.x = Math.atan2(n2, e2), t2.y = Math.atan(r2 * Math.cos(t2.x) / e2), t2.y = Math.atan(this.radius_p_inv2 * Math.tan(t2.y));
  } else if ("sphere" === this.shape) {
    if (this.flip_axis ? (r2 = Math.tan(t2.y / this.radius_g_1), n2 = Math.tan(t2.x / this.radius_g_1) * Math.sqrt(1 + r2 * r2)) : (n2 = Math.tan(t2.x / this.radius_g_1), r2 = Math.tan(t2.y / this.radius_g_1) * Math.sqrt(1 + n2 * n2)), s2 = n2 * n2 + r2 * r2 + e2 * e2, (a2 = (i2 = 2 * this.radius_g * e2) * i2 - 4 * s2 * this.C) < 0)
      return t2.x = Number.NaN, t2.y = Number.NaN, t2;
    h2 = (-i2 - Math.sqrt(a2)) / (2 * s2), e2 = this.radius_g + h2 * e2, n2 *= h2, r2 *= h2, t2.x = Math.atan2(n2, e2), t2.y = Math.atan(r2 * Math.cos(t2.x) / e2);
  }
  return t2.x = t2.x + this.long0, t2;
}, names: ["Geostationary Satellite View", "Geostationary_Satellite", "geos"] };
async function* Ss(t2, s2) {
  const i2 = await fetch(t2, s2);
  if (!i2.ok)
    throw new Error(`Failed to retreive scene metadata: ${i2.status} ${i2.statusText}`);
  if (i2.body) {
    const t3 = i2.body.getReader(), s3 = new TextDecoder("utf-8");
    let { value: a2, done: h2 } = await t3.read(), e2 = a2 ? s3.decode(a2) : "", n2 = /\r\n|\n|\r/gm, r2 = 0;
    for (; ; ) {
      let i3 = n2.exec(e2);
      if (i3)
        yield e2.substring(r2, i3.index), r2 = n2.lastIndex;
      else {
        if (h2)
          break;
        let i4 = e2.substr(r2);
        ({ value: a2, done: h2 } = await t3.read()), e2 = i4 + (a2 ? s3.decode(a2) : ""), r2 = n2.lastIndex = 0;
      }
    }
    r2 < e2.length && (yield e2.substr(r2));
  }
}
function Ps(t2) {
  try {
    return JSON.parse(t2);
  } catch (t3) {
    return;
  }
}
ut.defaultDatum = "WGS84", ut.Proj = K, ut.WGS84 = new ut.Proj("WGS84"), ut.Point = bt, ut.toPoint = et, ut.defs = P, ut.nadgrid = function(t2, s2) {
  var i2 = new DataView(s2), a2 = function(t3) {
    var s3 = t3.getInt32(8, false);
    return 11 !== s3 && (s3 = t3.getInt32(8, true), true);
  }(i2), h2 = function(t3, s3) {
    return { nFields: t3.getInt32(8, s3), nSubgridFields: t3.getInt32(24, s3), nSubgrids: t3.getInt32(40, s3), shiftType: Q(t3, 56, 64).trim(), fromSemiMajorAxis: t3.getFloat64(120, s3), fromSemiMinorAxis: t3.getFloat64(136, s3), toSemiMajorAxis: t3.getFloat64(152, s3), toSemiMinorAxis: t3.getFloat64(168, s3) };
  }(i2, a2);
  h2.nSubgrids;
  var e2 = { header: h2, subgrids: function(t3, s3, i3) {
    for (var a3 = [], h3 = 0; h3 < s3.nSubgrids; h3++) {
      var e3 = X(t3, 176, i3), n2 = Y(t3, 176, e3, i3), r2 = Math.round(1 + (e3.upperLongitude - e3.lowerLongitude) / e3.longitudeInterval), o2 = Math.round(1 + (e3.upperLatitude - e3.lowerLatitude) / e3.latitudeInterval);
      a3.push({ ll: [W(e3.lowerLongitude), W(e3.lowerLatitude)], del: [W(e3.longitudeInterval), W(e3.latitudeInterval)], lim: [r2, o2], count: e3.gridNodeCount, cvs: J(n2) });
    }
    return a3;
  }(i2, h2, a2) };
  return $[t2] = e2, e2;
}, ut.transform = rt, ut.mgrs = Mt, ut.version = "__VERSION__", function(t2) {
  t2.Proj.projections.add(Et), t2.Proj.projections.add(Ot), t2.Proj.projections.add(Tt), t2.Proj.projections.add(qt), t2.Proj.projections.add(jt), t2.Proj.projections.add(Ut), t2.Proj.projections.add(Lt), t2.Proj.projections.add(zt), t2.Proj.projections.add(Bt), t2.Proj.projections.add(Yt), t2.Proj.projections.add(Vt), t2.Proj.projections.add(ts), t2.Proj.projections.add(ss), t2.Proj.projections.add(is), t2.Proj.projections.add(as), t2.Proj.projections.add(hs), t2.Proj.projections.add(es), t2.Proj.projections.add(ns), t2.Proj.projections.add(rs), t2.Proj.projections.add(os), t2.Proj.projections.add(ls), t2.Proj.projections.add(cs), t2.Proj.projections.add(us), t2.Proj.projections.add(Ms), t2.Proj.projections.add(ps), t2.Proj.projections.add(gs), t2.Proj.projections.add(xs), t2.Proj.projections.add(bs), t2.Proj.projections.add(ws);
}(ut), t = Array;
var Ns = class {
  constructor(t2, s2, i2) {
    this.url = t2, this.auth = s2, this.assetUrl = i2, this.db = {}, this.save = async (t3) => {
      const s3 = { name: t3.name, path: t3.path, properties: t3.properties, url: t3.url, description: t3.description, id: t3.id, type: t3.type, bounds: t3.bounds }, i3 = new Blob([JSON.stringify(s3)], { type: "application/json" }), a2 = await this.auth({ method: "POST", body: i3 });
      return (await fetch(this.url, a2)).ok;
    }, this.loadCompleteMetadata = async (t3) => {
      let s3 = this.db[t3];
      if (!s3 || !s3.name) {
        const i3 = await fetch(`${this.url}/${t3}`, await this.auth());
        if (!i3.ok)
          throw new Error(i3.statusText);
        const a2 = await i3.json();
        s3 ? (s3.name = a2.name, s3.path = a2.path, s3.properties = a2.properties, s3.url = a2.url, s3.description = a2.description, s3.id = a2.id, s3.type = a2.type, s3.bounds = a2.bounds) : (s3 = a2, this.db[t3] = s3), s3.loadMetaData = this.loadMetaData, s3.save = async () => await this.save(s3);
      }
      return s3;
    };
  }
  loadMetaData() {
    return Promise.resolve(this);
  }
  getObjectMetdata(t2) {
    return this.loadCompleteMetadata(t2);
  }
  search(t2, s2) {
    return async function* (t3, s3, i2, a2, h2, e2) {
      let n2 = "";
      for (; ; ) {
        const r2 = new Blob([JSON.stringify({ path: h2.parentPath, descendants: h2.descentDepth, search: h2.searchPattern, continuation: n2, full: h2.full })], { type: "application/json" }), o2 = Ss(i2 + "/search", await a2({ method: "POST", headers: [["Accept", "text/plain"]], signal: e2, body: r2 }));
        n2 = (await o2.next()).value;
        for await (const i3 of o2) {
          if (null == e2 ? void 0 : e2.aborted)
            break;
          const a3 = Ps(i3);
          if (!a3)
            continue;
          let n3 = t3[a3.id];
          if (h2.full) {
            if (n3) {
              const t4 = n3, s4 = a3;
              t4.name = s4.name, t4.path = s4.path, t4.properties = s4.properties, t4.url = s4.url, t4.description = s4.description, t4.id = s4.id, t4.type = s4.type, t4.bounds = s4.bounds;
            } else
              n3 = a3, t3[a3.id] = n3;
            n3.loadMetaData = s3;
          } else
            n3 || (n3 = a3, n3.loadMetaData = () => s3(a3.id), t3[a3.id] = n3);
          yield n3;
        }
        if (!n2)
          break;
      }
    }(this.db, t2.full ? this.loadMetaData : this.loadCompleteMetadata, this.url, this.auth, t2, s2);
  }
  async descendants(t2, s2) {
    var i2;
    if (!t2.descendants)
      try {
        const i3 = new URL(this.assetUrl);
        i3.pathname += "descendants/" + t2.id;
        const a2 = [], h2 = Ss(i3.toString(), { signal: s2 });
        for await (const t3 of h2)
          a2.push(parseInt(t3));
        t2.descendants = a2;
      } catch {
        t2.descendants = [];
      }
    return null !== (i2 = t2.descendants) && void 0 !== i2 ? i2 : [];
  }
};
var Es = class {
  constructor(t2, s2) {
    this.authHeader = t2, this.serviceUrl = s2, this.lastAppToken = "-1", this.token = "", this.auth = async (t3) => {
      const s3 = this.authHeader ? await this.authHeader() : void 0;
      if (!(null == s3 ? void 0 : s3.header) || !(null == s3 ? void 0 : s3.value))
        return t3;
      const i2 = s3.header;
      return this.token = s3.value, t3 || (t3 = {}), t3.mode || (t3.mode = "cors"), t3.headers ? t3.headers instanceof Headers ? t3.headers.append(i2, this.token) : Array.isArray(t3.headers) ? t3.headers.push([i2, this.token]) : t3.headers[i2] = this.token : t3.headers = [[i2, this.token]], t3;
    };
  }
  async getUserInformation() {
    const t2 = await fetch(this.serviceUrl + "/user", await this.auth()), s2 = await t2.json();
    return { name: null == s2 ? void 0 : s2.user, organization: null == s2 ? void 0 : s2.organization, role: (null == s2 ? void 0 : s2.role) || void 0, features: null == s2 ? void 0 : s2.features };
  }
  async getScenes() {
    const t2 = await fetch(this.serviceUrl + "/scenes", await this.auth());
    return await t2.json();
  }
  async loadScene(t2) {
    var a2, h2;
    const e2 = await fetch(`${this.serviceUrl}/scenes/${t2}`, await this.auth()), n2 = await e2.json(), r2 = new Ns(`${this.serviceUrl}/metadata/${t2}`, this.auth, n2.url);
    n2.db = r2;
    const { settings: o2, selectedObjects: l2, hiddenObjects: c2, cameraBookmarks: u2 } = n2;
    if (n2.objectGroups) {
      for (const t3 of n2.objectGroups)
        if (!t3.id && "default" !== t3.name && "defaultHidden" !== t3.name) {
          var M2 = (/* @__PURE__ */ new Date()).getTime(), d2 = 1e3 * (null !== (h2 = null === performance || void 0 === performance ? void 0 : performance.now()) && void 0 !== h2 ? h2 : 0);
          t3.id = "xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g, function(t4) {
            var s2 = 16 * Math.random();
            return M2 > 0 ? (s2 = (M2 + s2) % 16 | 0, M2 = Math.floor(M2 / 16)) : (s2 = (d2 + s2) % 16 | 0, d2 = Math.floor(d2 / 16)), ("x" === t4 ? s2 : 3 & s2 | 8).toString(16);
          });
        }
    } else if (n2.objectGroups = [], o2) {
      const t3 = { id: "", name: "default", ids: [], color: [1, 0, 0], selected: true, hidden: false };
      let h3 = false;
      (null === (a2 = o2.selectedObjects) || void 0 === a2 ? void 0 : a2.color) && (t3.color = i(s(), o2.selectedObjects.color), h3 = true), l2 && (t3.ids = l2, delete n2.selectedObjects, h3 = true), h3 && n2.objectGroups.push(t3), c2 && n2.objectGroups.push({ id: "", name: "defaultHidden", ids: c2, color: [1, 0, 0], selected: false, hidden: true });
    }
    return (null == o2 ? void 0 : o2.clippingPlanes) && (o2.clippingPlanes.bounds = { min: i(s(), o2.clippingPlanes.bounds.min), max: i(s(), o2.clippingPlanes.bounds.max) }), u2 && (n2.bookmarks = u2.map(({ name: t3, properties: s2 }) => ({ name: t3, camera: s2 })), delete n2.cameraBookmarks), n2;
  }
  async putScene(t2) {
    const [s2, i2] = t2.url.split(":");
    t2.url = void 0;
    const a2 = new Blob([JSON.stringify(t2)], { type: "application/json" }), h2 = `${this.serviceUrl}/scenes/${s2}/ ${i2 ? "/" + i2 : ""}`, e2 = await this.auth({ method: "POST", body: a2 });
    return (await fetch(h2, e2)).ok;
  }
  async getBookmarks(t2, s2) {
    const i2 = await fetch(`${this.serviceUrl}/scenes/${t2}/${(null == s2 ? void 0 : s2.personal) ? "personal" : ""}bookmarks${(null == s2 ? void 0 : s2.group) ? "/" + s2.group : ""}`, await this.auth());
    return await i2.json();
  }
  async saveBookmarks(t2, s2, i2) {
    const a2 = new Blob([JSON.stringify(s2)], { type: "application/json" }), h2 = `${this.serviceUrl}/scenes/${t2}/${(null == i2 ? void 0 : i2.personal) ? "personal" : ""}bookmarks${(null == i2 ? void 0 : i2.group) ? "/" + i2.group : ""}`, e2 = await this.auth({ method: "POST", body: a2 });
    return (await fetch(h2, e2)).ok;
  }
  async getGroupIds(t2, s2) {
    const i2 = await fetch(`${this.serviceUrl}/scenes/${t2}/group/${s2}`, await this.auth());
    return await i2.json();
  }
  async deleteScene(t2) {
    const s2 = `${this.serviceUrl}/scenes/${t2}`, i2 = await this.auth({ method: "DELETE" });
    return (await fetch(s2, i2)).ok;
  }
  async getResources() {
    const t2 = await fetch(this.serviceUrl + "/resources", await this.auth());
    return (await t2.json()).map((t3) => (t3.tags && (t3.tags = t3.tags.split(";")), t3));
  }
  async updateResource(t2) {
    var s2;
    const i2 = this.serviceUrl + "/resources", a2 = { ...t2, tags: null === (s2 = t2.tags) || void 0 === s2 ? void 0 : s2.join(";") }, h2 = await this.auth({ method: "POST", body: JSON.stringify(a2), headers: [["content-type", "application/json"]] });
    return (await fetch(i2, h2)).ok;
  }
  async deleteResource(t2) {
    const s2 = `${this.serviceUrl}/resources/${t2}`, i2 = await this.auth({ method: "DELETE" });
    return (await fetch(s2, i2)).ok;
  }
  async getResource(t2) {
    const s2 = `${this.serviceUrl}/resources/${t2}`, i2 = await this.auth({}), a2 = await fetch(s2, i2);
    return await a2.json();
  }
  async uploadResource(t2, s2, i2, a2, h2) {
    try {
      const e2 = 1048576;
      s2(0);
      const n2 = Date.now().valueOf(), r2 = await this.auth({ method: "Get", cache: "no-cache", referrerPolicy: "origin-when-cross-origin", keepalive: true }), o2 = await fetch(`${this.serviceUrl}/upload/${n2}`, r2);
      if (!o2.ok)
        return { error: o2.statusText };
      const l2 = await o2.text();
      if (t2.size > e2) {
        const i3 = [];
        let a3 = 0;
        const h3 = [];
        let n3 = 0, r3 = 0;
        for (; a3 < t2.size; ) {
          const o4 = t2.slice(a3, Math.min(t2.size, a3 + e2)), c3 = "00000000000" + i3.length.toString(), u2 = btoa(c3.substr(c3.length - 12));
          for (i3.push(u2), a3 += e2; r3 > 15; )
            await new Promise((t3) => setTimeout(t3, 100));
          r3++, h3.push(fetch(`${l2}&comp=block&blockid=${u2}`, { method: "PUT", body: o4, referrerPolicy: "origin-when-cross-origin", headers: [["x-ms-blob-type", "BlockBlob"]] }).then((i4) => {
            if (r3--, !i4.ok)
              throw new Error(i4.statusText);
            return n3 += e2, s2(n3 / t2.size), i4;
          }));
        }
        try {
          await Promise.all(h3);
        } catch (t3) {
          return { error: "Failed" };
        }
        const o3 = await fetch(l2 + "&comp=blocklist", { method: "PUT", body: `<?xml version="1.0" encoding="utf-8"?><BlockList>${i3.map((t3) => `<Latest>${t3}</Latest>`).join("")}</BlockList>`, referrerPolicy: "origin-when-cross-origin", headers: [["x-ms-blob-content-type", t2.type]] });
        if (!o3.ok)
          return { error: o3.statusText };
      } else {
        const s3 = await fetch(l2, { method: "PUT", body: t2, referrerPolicy: "origin-when-cross-origin", headers: [["x-ms-blob-type", "BlockBlob"]] });
        if (!s3.ok)
          return { error: s3.statusText };
      }
      const c2 = await fetch(`${this.serviceUrl}/resource/${n2}?fileName=${encodeURIComponent(t2.name)}&size=${(t2.size / 1048576).toFixed(0)}&revision=${null != i2 ? i2 : ""}&path=${null != a2 ? a2 : ""}${h2 ? "&split=true" : ""}`, await this.auth({ method: "POST", body: "{}", headers: [["content-type", "application/json"]] }));
      return c2.ok ? { processId: n2.toString() } : { error: c2.statusText };
    } catch (t3) {
      return { error: "Failed" };
    }
  }
  async createScene(t2) {
    try {
      const s2 = await fetch(this.serviceUrl + "/process", await this.auth({ method: "POST", body: JSON.stringify(t2), headers: [["content-type", "application/json"]] }));
      return s2.ok ? await s2.json() : { error: s2.statusText };
    } catch (t3) {
      return { error: "Failed: " + JSON.stringify(t3) };
    }
  }
  async getSceneDefinition(t2) {
    const s2 = await fetch(`${this.serviceUrl}/scenes/${t2}/config`, await this.auth());
    return await s2.json();
  }
  async getProcesses() {
    const t2 = await fetch(this.serviceUrl + "/process", await this.auth());
    return await t2.json();
  }
  async getProcessProgress(t2, s2, i2) {
    try {
      const a2 = await fetch(`${this.serviceUrl}/progress/${t2}?position=${s2}`, await this.auth({ signal: i2, keepalive: true }));
      return a2.ok ? await a2.json() : { text: a2.statusText, complete: true, position: 0 };
    } catch (t3) {
      return { text: JSON.stringify(t3, void 0, "  "), complete: true, position: 0 };
    }
  }
  async fetch(t2, s2) {
    return await fetch(`${this.serviceUrl}/${t2}`, await this.auth(s2));
  }
  getWKZones() {
    return As.map((t2) => t2[0]);
  }
  latLon2tm(s2, i2) {
    const a2 = ut(i2).forward([s2.longitude, s2.latitude]);
    return h2 = a2[0], 0, e2 = -a2[1], (n2 = new t(3))[0] = h2, n2[1] = 0, n2[2] = e2, n2;
    var h2, e2, n2;
  }
  tm2LatLon(t2, s2) {
    const i2 = ut(s2).inverse([t2[0], -t2[2]]);
    return { longitude: i2[0], latitude: i2[1] };
  }
};
var As = Array.from(Array(60).keys()).map((t2) => {
  const s2 = t2 + 1;
  return [[`WGS 84 / UTM zone ${s2}N`, `PROJCS["WGS 84 / UTM zone ${s2}N",GEOGCS["WGS 84",DATUM["WGS_1984",SPHEROID["WGS 84",6378137,298.257223563,AUTHORITY["EPSG","7030"]],AUTHORITY["EPSG","6326"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4326"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",${6 * t2 - 177}],PARAMETER["scale_factor",0.9996],PARAMETER["false_easting",500000],PARAMETER["false_northing",0],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AXIS["Easting",EAST],AXIS["Northing",NORTH],AUTHORITY["EPSG","${32600 + s2}"]]`], [`WGS 84 / UTM zone ${s2}S`, `PROJCS["WGS 84 / UTM zone ${s2}S",GEOGCS["WGS 84",DATUM["WGS_1984",SPHEROID["WGS 84",6378137,298.257223563,AUTHORITY["EPSG","7030"]],AUTHORITY["EPSG","6326"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4326"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",${6 * t2 - 177}],PARAMETER["scale_factor",0.9996],PARAMETER["false_easting",500000],PARAMETER["false_northing",10000000],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AXIS["Easting",EAST],AXIS["Northing",NORTH],AUTHORITY["EPSG","${32700 + s2}"]]`]];
}).flat().concat(Array.from(Array(26).keys()).map((t2) => {
  const s2 = t2 + 5;
  return ["ETRS89 / NTM zone " + s2, `PROJCS["ETRS89 / NTM zone ${s2}",GEOGCS["ETRS89",DATUM["European_Terrestrial_Reference_System_1989",SPHEROID["GRS 1980",6378137,298.257222101,AUTHORITY["EPSG","7019"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY["EPSG","6258"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4258"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",58],PARAMETER["central_meridian",${s2 + 0.5}],PARAMETER["scale_factor",1],PARAMETER["false_easting",100000],PARAMETER["false_northing",1000000],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AUTHORITY["EPSG","${5100 + s2}"]]`];
}));
function Cs(t2) {
  var s2;
  return new Es(null == t2 ? void 0 : t2.authHeader, null !== (s2 = null == t2 ? void 0 : t2.serviceUrl) && void 0 !== s2 ? s2 : "https://novorender.com/api");
}
ut.defs(As);
export {
  Es as API,
  Cs as createAPI
};
//# sourceMappingURL=@novorender_data-js-api.js.map
